     1                                  ;硬盘主引导扇区代码
     2                                  ;也是内核代码的初始部分
     3                                                                      
     4                                  core_base_address equ 0x00040000   ;常数，内核加载的起始内存物理地址
     5                                  core_start_sector equ 0x00000001   ;常数，内核的起始逻辑扇区号。常数的声明不会占用汇编地址
     6                                  
     7                                  ;设置栈段和栈指针
     8 00000000 8CC8                    mov ax,cs               ;栈段寄存器指向cs代码段
     9 00000002 8ED0                    mov ss,ax
    10 00000004 BC007C                  mov sp,0x7c00           ;栈指针指向代码起始位置，栈是向下增长的，范围为0x7c00-0x00
    11                                  
    12                                  ;计算GDT所在逻辑段的地址
    13 00000007 2E66A1[9B7D]            mov eax,[cs:pgdt+0x7c00+0x02]   ;GDT的32位线性基地址 
    14 0000000C 6631D2                  xor edx,edx                     
    15 0000000F 66BB10000000            mov ebx,16
    16 00000015 66F7F3                  div ebx
    17 00000018 8ED8                    mov ds,eax                      ;商就是段地址
    18 0000001A 6689D3                  mov ebx,edx                     ;余数就是偏移地址
    19                                  
    20                                  ;跳过#0描述符，它是空描述符，处理器要求的
    21                                  
    22                                  ;创建#1描述符，这是一个数据段，对应0~4GB的线性地址空间
    23 0000001D 6667C74308FFFF0000      mov dword [ebx+0x08],0x0000ffff    ;基地址为0，段界限为0xFFFFF
    24 00000026 6667C7430C0092CF00      mov dword [ebx+0x0c],0x00cf9200    ;粒度为4KB，存储器段描述符 
    25                                  
    26                                  ;创建保护模式下初始代码段描述符
    27 0000002F 6667C74310FF01007C      mov dword [ebx+0x10],0x7c0001ff    ;基地址为0x00007c00，界限0x1FF 
    28 00000038 6667C7431400984000      mov dword [ebx+0x14],0x00409800    ;粒度为1个字节，代码段描述符 
    29                                  
    30                                  ;建立保护模式下的堆栈段描述符     
    31 00000041 6667C74318FEFF007C      mov dword [ebx+0x18],0x7c00fffe     ;基地址为0x00007C00，界限0xFFFFE     
    32 0000004A 6667C7431C0096CF00      mov dword [ebx+0x1c],0x00cf9600     ;粒度为4KB 
    33                                  
    34                                  ;建立保护模式下的显示缓冲区描述符   
    35 00000053 6667C74320FF7F0080      mov dword [ebx+0x20],0x80007fff    ;基地址为0x000B8000，界限0x07FFF 
    36 0000005C 6667C743240B924000      mov dword [ebx+0x24],0x0040920b    ;粒度为字节
    37                                  
    38                                  ;初始化描述符表寄存器GDTR，尚未进入守护模式，仍然可以向代码段内存写数据
    39 00000065 2EC706[997D]2700        mov word [cs:pgdt+0x7c00],39        ;描述符表的界限，总共5个描述符，总字节数：5*8=40，需要在-1，所以是39
    40 0000006C 2E0F0116[997D]          lgdt [cs:pgdt+0x7c00]               ;加载全局描述符表寄存器，正好需要加载48位
    41                                  
    42 00000072 E492                    in al,0x92                          ;南桥芯片内的端口 
    43 00000074 0C02                    or al,0000_0010B
    44 00000076 E692                    out 0x92,al                         ;打开A20，使地址线A20可用
    45                                  
    46 00000078 FA                      cli                                 ;实模式下的中断不能在保护模式下运行了，所以需要禁掉中断
    47                                  
    48 00000079 0F20C0                  mov eax,cr0                         ;cr0是控制寄存器0，位0用于控制是否开启保护模式
    49 0000007C 6683C801                or eax,1                            ;开启保护模式（PE）
    50 00000080 0F22C0                  mov cr0,eax
    51                                  
    52                                  ;以下进入保护模式
    53 00000083 66EA[8B000000]1000      jmp dword 0x0010:flush              ;16位描述符选择子（描述符表中的代码段，索引为2，因为每个描述符大小为8，所以需要乘以8）
    54                                                                      ;flush指的是32位偏移地址，jmp指令会清空流水线并串行化处理器
    55                                  
    56                                  [bits 32]                           ;按32位模式译码，也就是下面的代码是保护模式代码
    57                                  flush:
    58 0000008B B808000000                  mov eax,0x08                   ;16位描述符选择子，描述符表中的数据段，索引为1
    59 00000090 8ED8                        mov ds,eax
    60                                  
    61 00000092 B818000000                  mov eax,0x18                   ;16位描述符选择子，描述符表中的栈段，索引为3
    62 00000097 8ED0                        mov ss,eax
    63 00000099 31E4                        xor esp,esp                    ;栈指针设置为0
    64                                  
    65                                      ;以下加载内核程序
    66 0000009B BF00000400                  mov edi,core_base_address       ;edi目标索引寄存器,内核代码所在内存起始地址
    67                                  
    68 000000A0 B801000000                  mov eax,core_start_sector       ;内核程序所在扇区
    69 000000A5 89FB                        mov ebx,edi                     ;起始地址
    70 000000A7 E88D000000                  call read_hard_disk_0           ;读取程序的起始部分（一个扇区）
    71                                  
    72                                      ;以下判断整个程序有多大
    73 000000AC 8B07                        mov eax,[edi]                   ;内核起始地址数据，就是内核程序的长度
    74 000000AE 31D2                        xor edx,edx
    75 000000B0 B900020000                  mov ecx,512                     ;硬盘扇区大小
    76 000000B5 F7F1                        div ecx
    77                                  
    78 000000B7 09D2                        or edx,edx                      
    79 000000B9 7501                        jnz @1                          ;余数不为0表示未除尽，表示还有一个扇区需要读，不需要去减去一个扇区了，因为已经读了一个扇区了，直接跳转到@1
    80 000000BB 48                          dec eax                         ;已经读取过头扇区了，所以需要减去一个
    81                                  @1:
    82 000000BC 09C0                        or eax,eax                      ;商为0表示程序的大小刚好小于等于512字节
    83 000000BE 7410                        jz setup
    84                                  
    85                                      ;读取剩余扇区
    86 000000C0 89C1                        mov ecx,eax                     ;32位模式下的LOOP使用ECX
    87 000000C2 B801000000                  mov eax,core_start_sector
    88 000000C7 40                          inc eax                         ;扇区号+1,从下一个扇区接着读
    89                                  @2:
    90 000000C8 E86C000000                  call read_hard_disk_0
    91 000000CD 40                          inc eax                         ;扇区号+1
    92 000000CE E2F8                        loop @2                         ;先将ecx值减一，如果ecx的值不为0，则执行循环，否则向下继续执行
    93                                  
    94                                  setup:
    95 000000D0 8B35[9B7D0000]              mov esi,[0x7c00+pgdt+0x02]      ;已经进入保护模式了，不能在通过代码段进行内存读写了，但可以通过4G数据段访问
    96                                                                      ;+0x02是为了跳过描述符的界限
    97                                  
    98                                      ;创建内核通用例程段描述符
    99 000000D6 8B4704                      mov eax,[edi+0x04]              ;通用例程段汇编偏移地址
   100 000000D9 8B5F08                      mov ebx,[edi+0x08]              ;内核数据段汇编偏移地址
   101 000000DC 29C3                        sub ebx,eax
   102 000000DE 4B                          dec ebx                         ;两者差值再减一就是通用例程的段界限
   103 000000DF 01F8                        add eax,edi                     ;通用例程段基地址
   104 000000E1 B900984000                  mov ecx,0x00409800              ;字节粒度的代码段描述符
   105 000000E6 E893000000                  call make_gdt_descriptor        ;构造段描述符，结果在：edx:eax
   106 000000EB 894628                      mov [esi+0x28],eax              ;写入全局段描述符表
   107 000000EE 89562C                      mov [esi+0x2c],edx
   108                                  
   109                                      ;创建核心数据段描述符
   110 000000F1 8B4708                      mov eax,[edi+0x08]                 ;核心数据段起始汇编地址
   111 000000F4 8B5F0C                      mov ebx,[edi+0x0c]                 ;核心代码段汇编地址 
   112 000000F7 29C3                        sub ebx,eax
   113 000000F9 4B                          dec ebx                            ;核心数据段界限
   114 000000FA 01F8                        add eax,edi                        ;核心数据段基地址
   115 000000FC B900924000                  mov ecx,0x00409200                 ;字节粒度的数据段描述符 
   116 00000101 E878000000                  call make_gdt_descriptor
   117 00000106 894630                      mov [esi+0x30],eax
   118 00000109 895634                      mov [esi+0x34],edx 
   119                                  
   120                                      ;创建核心代码段描述符
   121 0000010C 8B470C                      mov eax,[edi+0x0c]                 ;核心代码段起始汇编地址
   122 0000010F 8B1F                        mov ebx,[edi+0x00]                 ;程序总长度
   123 00000111 29C3                        sub ebx,eax
   124 00000113 4B                          dec ebx                            ;核心代码段界限
   125 00000114 01F8                        add eax,edi                        ;核心代码段基地址
   126 00000116 B900984000                  mov ecx,0x00409800                 ;字节粒度的代码段描述符
   127 0000011B E85E000000                  call make_gdt_descriptor
   128 00000120 894638                      mov [esi+0x38],eax
   129 00000123 89563C                      mov [esi+0x3c],edx
   130                                  
   131 00000126 66C705[997D0000]3F-         mov word [0x7c00+pgdt],63           ;又增加3个描述符，总共8个描述符了
   131 0000012E 00                 
   132 0000012F 0F0115[997D0000]            lgdt [0x7c00+pgdt]                  ;重新加载到全局描述符表寄存器
   133                                  
   134 00000136 FF6F10                      jmp far [edi+0x10]                    ;跳转到内核程序入口处，将控制权交给内核程序
   135                                  
   136                                  ;-----------从硬盘读取一个逻辑扇区----------------------------------------------------------------
   137                                  read_hard_disk_0:               ;使用的逻辑扇区编址方法为LBA28，也就是用28位来表示扇区号，每个扇区512字节
   138                                                                  ;eax=逻辑扇区号
   139                                                                  ;ds:ebx=目标缓冲区地址，将读到的硬盘数据放到ds段指定的内存中
   140                                  
   141 00000139 50                          push eax                    ;将该过程会用到的寄存器入栈保存，函数返回时需要出栈还原
   142 0000013A 51                          push ecx
   143 0000013B 52                          push edx
   144                                  
   145 0000013C 50                          push eax                    ;在入栈一次eax的值
   146                                  
   147 0000013D 66BAF201                    mov dx,0x1f2                ;0x1f2端口表示要读取或写入的扇区数量，8位长度
   148 00000141 B001                        mov al,1                    ;每次要读取1个扇区
   149 00000143 EE                          out dx,al
   150                                  
   151                                      ;28位的扇区号太长，需要放到4个8位端口中，0x1f3存0-7位，0x1f4存8-15位，0x1f5存16-23位，
   152                                      ;0x1f6低4位存24-27位，第4位用于指示硬盘号，0是主盘、1是从盘,高三为全为1，表示LBA模式
   153 00000144 6642                        inc dx                      ;0x1f3
   154 00000146 58                          pop eax                     ;eax存放的是32位逻辑扇区号
   155 00000147 EE                          out dx,al                   ;LBA地址7-0
   156                                  
   157 00000148 6642                        inc dx                      ;0x1f4
   158 0000014A B108                        mov cl,8
   159 0000014C D3E8                        shr eax,cl
   160 0000014E EE                          out dx,al                    ;LBA地址15~8
   161                                  
   162 0000014F 6642                        inc dx                       ;0x1f5
   163 00000151 D3E8                        shr eax,cl
   164 00000153 EE                          out dx,al                    ;LBA地址23~16
   165                                  
   166 00000154 6642                        inc dx                      ;0x1f6
   167 00000156 D3E8                        shr eax,cl
   168 00000158 0CE0                        or al,0xe0                  ;因为al是1110 0000，ah高4位是0，0000 xxxx,使用or运算后al就是xxxx,表示LBA地址27-24
   169 0000015A EE                          out dx,al
   170                                  
   171 0000015B 6642                        inc dx                      ;0x1f7，既是命令端口也是状态端口，0x20表示读，0x30表示写
   172 0000015D B020                        mov al,0x20                 ;表示读硬盘
   173 0000015F EE                          out dx,al                  
   174                                  
   175                                      .waits:
   176 00000160 EC                              in al,dx                    ;读取硬盘状态，第7位是1表示硬盘在忙碌，第3位是1表示已经读取完可以传输数据了
   177 00000161 2488                            and al,0x88                 ;二进制值：1000 1000，保留第7位与第3位的值，其他位全清0
   178 00000163 3C08                            cmp al,0x08                 ;二进制值：0000 1000，是否已经准备好了
   179 00000165 75F9                            jnz .waits                  ;尚未准备好，继续循环等待
   180                                  
   181 00000167 B900010000                  mov ecx,256                  ;总共要读取的字数
   182 0000016C 66BAF001                    mov dx,0x1f0                 ;硬盘数据端口，长度为16位的
   183                                  
   184                                      .readw:
   185 00000170 66ED                            in ax,dx                    ;从硬盘读取一个字
   186 00000172 668903                          mov [ebx],ax                ;放到ds段内存中
   187 00000175 83C302                          add ebx,2                   ;bx偏移地址+2
   188 00000178 E2F6                            loop .readw                 ;先将ecx值减一，如果ecx的值不为0，则执行循环，否则向下继续执行
   189                                  
   190 0000017A 5A                          pop edx                      ;出栈，还原相关寄存器的原始值
   191 0000017B 59                          pop ecx
   192 0000017C 58                          pop eax
   193                                  
   194 0000017D C3                          ret                         ;返回
   195                                  
   196                                  ;-----------构造描述符--------------------------------------------------------------------
   197                                  make_gdt_descriptor:            ;输入：eax=线性基址，ebx=段界限,ecx=属性（各属性位都在原始位置，其它没用到的位置0） 
   198                                                                  ;输出edx:eax
   199 0000017E 89C2                        mov edx,eax
   200 00000180 C1E010                      shl eax,16                  ;描述符低32位中的高16位是基地址部分，所以左移16位使其基地址部分就位
   201 00000183 6609D8                      or ax,bx                    ;低16位是段界限，取的段界限
   202                                  
   203 00000186 81E20000FFFF                and edx,0xffff0000          ;清除低16位
   204 0000018C C1C208                      rol edx,8                   ;edx循环左移8位，循环左移会将左移出的位放到右边。这样edx中低8位的值就是原先高8位的值
   205 0000018F 0FCA                        bswap edx                   ;字节交换指令。装配基址的31~24和23~16  (80486+)
   206                                  
   207 00000191 6631DB                      xor bx,bx
   208 00000194 09DA                        or edx,ebx                  ;装配段界限的高4位
   209                                      
   210 00000196 09CA                        or edx,ecx                  ;装配段属性
   211                                  
   212 00000198 C3                          ret
   213                                  
   214                                  ;-----------描述符物理地址--------------------------------------------------------------------
   215 00000199 0000                    pgdt dw 0           ;描述符表的界限
   216 0000019B 007E0000                     dd 0x00007e00  ;全局描述符表起始物理地址，该地址刚好是主引导程序后面的地址。
   217                                                      ;总共是16位+32位=48位，正好与GDTR寄存器的位数匹配
   218                                  
   219                                  ;-------------------------------------------------------------------------------
   220 0000019F 00<rep 5Fh>             times 510-($-$$)  db  0 ;剩余的字节数用0填充，'$$'表示当前段的起始地址，'$-$$'正好是当前程序的字节大小
   221 000001FE 55AA                                      db  0x55,0xaa ;引导扇区结束标识
   222                                  
