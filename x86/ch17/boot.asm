;保护模式示例
;硬盘主引导扇区代码

core_base_address equ 0x00040000   ;常数，内核加载的起始内存地址 
core_start_sector equ 0x00000001   ;常数，内核的起始逻辑扇区号。常数的声明不会占用汇编地址

;-----------主引导程序代码段-----------------------------------------------------------------------
section mbr vstart=0x00007c00
    ;设置栈段和栈指针
    mov ax,cs               ;栈段寄存器指向cs代码段
    mov ss,ax
    mov sp,0x7c00           ;栈指针指向代码起始位置，栈是向下增长的，范围为0x7c00-0x00

    ;计算GDT所在的逻辑段地址
    mov eax,[cs:pgdt+0x02]             ;GDT的32位物理地址 
    xor edx,edx
    mov ebx,16
    div ebx                            ;分解成16位逻辑地址 

    mov ds,eax                         ;令DS指向该段以进行操作
    mov ebx,edx                        ;段内起始偏移地址 

    ;跳过0#号描述符的槽位 
    ;创建1#描述符，保护模式下的代码段描述符
    mov dword [ebx+0x08],0x0000ffff    ;基地址为0，界限0xFFFFF，DPL=00 
    mov dword [ebx+0x0c],0x00cf9800    ;4KB粒度，代码段描述符，向上扩展 

    ;创建2#描述符，保护模式下的数据段和堆栈段描述符 
    mov dword [ebx+0x10],0x0000ffff    ;基地址为0，界限0xFFFFF，DPL=00
    mov dword [ebx+0x14],0x00cf9200    ;4KB粒度，数据段描述符，向上扩展 

    ;初始化描述符表寄存器GDTR
    mov word [cs: pgdt],23              ;描述符表的界限，总共3个描述符，总字节数：3*8=24，需要在-1，所以是23
    lgdt [cs:pgdt]                      ;加载全局描述符表寄存器，正好需要加载48位

    in al,0x92                          ;南桥芯片内的端口 
    or al,0000_0010B
    out 0x92,al                         ;打开A20，使地址线A20可用

    cli                                 ;实模式下的中断不能在保护模式下运行了，所以需要禁掉中断

    mov eax,cr0                         ;cr0是控制寄存器0，位0用于控制是否开启保护模式
    or eax,1                            ;开启保护模式（PE）
    mov cr0,eax

    ;以下进入保护模式
    jmp dword 0x0008:flush              ;16位描述符选择子（描述符表中的代码段，索引为1，因为每个描述符大小为8，所以需要乘以8）
                                        ;flush指的是32位偏移地址，jmp指令会清空流水线并串行化处理器

;-----------按32位模式译码-----------------------------------------------------------------------
    [bits 32]                               ;按32位模式译码，也就是下面的代码是保护模式代码
    flush:
        mov eax,0x00010                    ;加载数据段(4GB)选择子
        mov ds,eax
        mov es,eax
        mov fs,eax
        mov gs,eax
        mov ss,eax                         ;加载堆栈段(4GB)选择子
        mov esp,0x7000                     ;堆栈指针                    

        ;以下加载内核程序
        mov edi,core_base_address       ;edi目标索引寄存器,内核代码所在内存起始地址

        mov eax,core_start_sector       ;内核程序所在扇区
        mov ebx,edi                     ;起始地址
        call read_hard_disk_0           ;读取程序的起始部分（一个扇区）

        ;以下判断整个程序有多大
        mov eax,[edi]                   ;内核起始地址数据，就是内核程序的长度
        xor edx,edx
        mov ecx,512                     ;硬盘扇区大小
        div ecx

        or edx,edx                      
        jnz @1                          ;余数不为0表示未除尽，表示还有一个扇区需要读，不需要去减去一个扇区了，因为已经读了一个扇区了，直接跳转到@1
        dec eax                         ;已经读取过头扇区了，所以需要减去一个
    @1:
        or eax,eax                      ;商为0表示程序的大小刚好小于等于512字节
        jz pge

        ;读取剩余扇区
        mov ecx,eax                     ;32位模式下的LOOP使用ECX
        mov eax,core_start_sector
        inc eax                         ;扇区号+1,从下一个扇区接着读
    @2:
        call read_hard_disk_0
        inc eax                         ;扇区号+1
        loop @2                         ;先将ecx值减一，如果ecx的值不为0，则执行循环，否则向下继续执行

;-----------打开分页机制----------------------------------------------------------------
    pge:                                ;准备打开分页机制。从此，再也不用在段之间转来转去，实在晕乎~
        ;创建系统内核的页目录表PDT
        mov ebx,0x00020000                 ;页目录表PDT的物理地址
        
        ;在页目录内创建指向自己的目录项
        mov dword [ebx+4092],0x00020003     ;每项的高20位才是物理地址，低16位为控制位，最后的0x0003表示页的属性，表示可读写以及不允许特权3访问的
        
        mov edx,0x00021003                  ;第一个页表物理地址为：0x00021000
        ;在页目录内创建与线性地址0x00000000对应的目录项
        mov [ebx+0x000],edx                 ;写入目录项（页表的物理地址和属性）      
                                            ;此目录项仅用于过渡。
        ;在页目录内创建与线性地址0x80000000对应的目录项
        mov [ebx+0x800],edx                 ;写入目录项（页表的物理地址和属性）

        ;创建与上面那个目录项相对应的页表，初始化页表项 
        mov ebx,0x00021000                 ;页表的物理地址
        xor eax,eax                        ;起始页的物理地址 
        xor esi,esi
    .b1:       
        mov edx,eax
        or edx,0x00000003                  ;页的属性都为11，表示可读写以及不允许特权3访问的                                    
        mov [ebx+esi*4],edx                ;登记页的物理地址
        add eax,0x1000                     ;下一个相邻页的物理地址 
        inc esi
        cmp esi,256                        ;仅低端1MB内存对应的页才是有效的
        jl .b1    

        ;令CR3寄存器指向页目录，并正式开启页功能 
        mov eax,0x00020000                 ;PCD=PWT=0
        mov cr3,eax

        ;将GDT的线性地址映射到从0x80000000开始的相同位置 
        sgdt [pgdt]                        ;将寄存器GDTR的值加载到内存pgdt出，此时给出的的pgdt是线性地址
        mov ebx,[pgdt+2]
        add dword [pgdt+2],0x80000000      ;GDTR也用的是线性地址
        lgdt [pgdt]                        ;将GDT新值写回GDTR寄存器

        ;开启分页功能
        mov eax,cr0
        or eax,0x80000000                   ;cr0的最高位设置为1表示开启分页
        mov cr0,eax

        ;将堆栈映射到高端，这是非常容易被忽略的一件事。应当把内核的所有东西
        ;都移到高端，否则，一定会和正在加载的用户任务局部空间里的内容冲突，
        ;而且很难想到问题会出在这里。 
        add esp,0x80000000                 
                                            
        jmp [0x80040004]                    ;跳转到内核程序，段内跳转

;-----------从硬盘读取一个逻辑扇区----------------------------------------------------------------
    read_hard_disk_0:               ;使用的逻辑扇区编址方法为LBA28，也就是用28位来表示扇区号，每个扇区512字节
                                    ;eax=逻辑扇区号
                                    ;ds:ebx=目标缓冲区地址，将读到的硬盘数据放到ds段指定的内存中

        push eax                    ;将该过程会用到的寄存器入栈保存，函数返回时需要出栈还原
        push ecx
        push edx

        push eax                    ;在入栈一次eax的值

        mov dx,0x1f2                ;0x1f2端口表示要读取或写入的扇区数量，8位长度
        mov al,1                    ;每次要读取1个扇区
        out dx,al

        ;28位的扇区号太长，需要放到4个8位端口中，0x1f3存0-7位，0x1f4存8-15位，0x1f5存16-23位，
        ;0x1f6低4位存24-27位，第4位用于指示硬盘号，0是主盘、1是从盘,高三为全为1，表示LBA模式
        inc dx                      ;0x1f3
        pop eax                     ;eax存放的是32位逻辑扇区号
        out dx,al                   ;LBA地址7-0

        inc dx                      ;0x1f4
        mov cl,8
        shr eax,cl
        out dx,al                    ;LBA地址15~8

        inc dx                       ;0x1f5
        shr eax,cl
        out dx,al                    ;LBA地址23~16

        inc dx                      ;0x1f6
        shr eax,cl
        or al,0xe0                  ;因为al是1110 0000，ah高4位是0，0000 xxxx,使用or运算后al就是xxxx,表示LBA地址27-24
        out dx,al

        inc dx                      ;0x1f7，既是命令端口也是状态端口，0x20表示读，0x30表示写
        mov al,0x20                 ;表示读硬盘
        out dx,al                  

        .waits:
            in al,dx                    ;读取硬盘状态，第7位是1表示硬盘在忙碌，第3位是1表示已经读取完可以传输数据了
            and al,0x88                 ;二进制值：1000 1000，保留第7位与第3位的值，其他位全清0
            cmp al,0x08                 ;二进制值：0000 1000，是否已经准备好了
            jnz .waits                  ;尚未准备好，继续循环等待

        mov ecx,256                  ;总共要读取的字数
        mov dx,0x1f0                 ;硬盘数据端口，长度为16位的

        .readw:
            in ax,dx                    ;从硬盘读取一个字
            mov [ebx],ax                ;放到ds段内存中
            add ebx,2                   ;bx偏移地址+2
            loop .readw                 ;先将ecx值减一，如果ecx的值不为0，则执行循环，否则向下继续执行

        pop edx                      ;出栈，还原相关寄存器的原始值
        pop ecx
        pop eax

        ret                         ;返回
;-----------数据区----------------------------------------------------------------
    pgdt dw 0               ;描述符表的界限
         dd 0x00008000  ;全局描述符表起始物理地址，该地址刚好是主引导程序后面的地址。
                            ;总共是16位+32位=48位，正好与GDTR寄存器的位数匹配

    times 510-($-$$)  db  0 ;剩余的字节数用0填充，'$$'表示当前段的起始地址，'$-$$'正好是当前程序的字节大小
                      db  0x55,0xaa ;引导扇区结束标识