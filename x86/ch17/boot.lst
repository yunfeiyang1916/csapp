     1                                  ;保护模式示例
     2                                  ;硬盘主引导扇区代码
     3                                  
     4                                  core_base_address equ 0x00040000   ;常数，内核加载的起始内存地址 
     5                                  core_start_sector equ 0x00000001   ;常数，内核的起始逻辑扇区号。常数的声明不会占用汇编地址
     6                                  
     7                                  ;-----------主引导程序代码段-----------------------------------------------------------------------
     8                                  section mbr vstart=0x00007c00
     9                                      ;设置栈段和栈指针
    10 00000000 8CC8                        mov ax,cs               ;栈段寄存器指向cs代码段
    11 00000002 8ED0                        mov ss,ax
    12 00000004 BC007C                      mov sp,0x7c00           ;栈指针指向代码起始位置，栈是向下增长的，范围为0x7c00-0x00
    13                                  
    14                                      ;计算GDT所在的逻辑段地址
    15 00000007 2E66A1[6F01]                mov eax,[cs:pgdt+0x02]             ;GDT的32位物理地址 
    16 0000000C 6631D2                      xor edx,edx
    17 0000000F 66BB10000000                mov ebx,16
    18 00000015 66F7F3                      div ebx                            ;分解成16位逻辑地址 
    19                                  
    20 00000018 8ED8                        mov ds,eax                         ;令DS指向该段以进行操作
    21 0000001A 6689D3                      mov ebx,edx                        ;段内起始偏移地址 
    22                                  
    23                                      ;跳过0#号描述符的槽位 
    24                                      ;创建1#描述符，保护模式下的代码段描述符
    25 0000001D 6667C74308FFFF0000          mov dword [ebx+0x08],0x0000ffff    ;基地址为0，界限0xFFFFF，DPL=00 
    26 00000026 6667C7430C0098CF00          mov dword [ebx+0x0c],0x00cf9800    ;4KB粒度，代码段描述符，向上扩展 
    27                                  
    28                                      ;创建2#描述符，保护模式下的数据段和堆栈段描述符 
    29 0000002F 6667C74310FFFF0000          mov dword [ebx+0x10],0x0000ffff    ;基地址为0，界限0xFFFFF，DPL=00
    30 00000038 6667C743140092CF00          mov dword [ebx+0x14],0x00cf9200    ;4KB粒度，数据段描述符，向上扩展 
    31                                  
    32                                      ;初始化描述符表寄存器GDTR
    33 00000041 2EC706[6D01]1700            mov word [cs: pgdt],23              ;描述符表的界限，总共3个描述符，总字节数：3*8=24，需要在-1，所以是23
    34 00000048 2E0F0116[6D01]              lgdt [cs:pgdt]                      ;加载全局描述符表寄存器，正好需要加载48位
    35                                  
    36 0000004E E492                        in al,0x92                          ;南桥芯片内的端口 
    37 00000050 0C02                        or al,0000_0010B
    38 00000052 E692                        out 0x92,al                         ;打开A20，使地址线A20可用
    39                                  
    40 00000054 FA                          cli                                 ;实模式下的中断不能在保护模式下运行了，所以需要禁掉中断
    41                                  
    42 00000055 0F20C0                      mov eax,cr0                         ;cr0是控制寄存器0，位0用于控制是否开启保护模式
    43 00000058 6683C801                    or eax,1                            ;开启保护模式（PE）
    44 0000005C 0F22C0                      mov cr0,eax
    45                                  
    46                                      ;以下进入保护模式
    47 0000005F 66EA[67000000]0800          jmp dword 0x0008:flush              ;16位描述符选择子（描述符表中的代码段，索引为1，因为每个描述符大小为8，所以需要乘以8）
    48                                                                          ;flush指的是32位偏移地址，jmp指令会清空流水线并串行化处理器
    49                                  
    50                                  ;-----------按32位模式译码-----------------------------------------------------------------------
    51                                      [bits 32]                               ;按32位模式译码，也就是下面的代码是保护模式代码
    52                                      flush:
    53 00000067 B810000000                      mov eax,0x00010                    ;加载数据段(4GB)选择子
    54 0000006C 8ED8                            mov ds,eax
    55 0000006E 8EC0                            mov es,eax
    56 00000070 8EE0                            mov fs,eax
    57 00000072 8EE8                            mov gs,eax
    58 00000074 8ED0                            mov ss,eax                         ;加载堆栈段(4GB)选择子
    59 00000076 BC00700000                      mov esp,0x7000                     ;堆栈指针                    
    60                                  
    61                                          ;以下加载内核程序
    62 0000007B BF00000400                      mov edi,core_base_address       ;edi目标索引寄存器,内核代码所在内存起始地址
    63                                  
    64 00000080 B801000000                      mov eax,core_start_sector       ;内核程序所在扇区
    65 00000085 89FB                            mov ebx,edi                     ;起始地址
    66 00000087 E89C000000                      call read_hard_disk_0           ;读取程序的起始部分（一个扇区）
    67                                  
    68                                          ;以下判断整个程序有多大
    69 0000008C 8B07                            mov eax,[edi]                   ;内核起始地址数据，就是内核程序的长度
    70 0000008E 31D2                            xor edx,edx
    71 00000090 B900020000                      mov ecx,512                     ;硬盘扇区大小
    72 00000095 F7F1                            div ecx
    73                                  
    74 00000097 09D2                            or edx,edx                      
    75 00000099 7501                            jnz @1                          ;余数不为0表示未除尽，表示还有一个扇区需要读，不需要去减去一个扇区了，因为已经读了一个扇区了，直接跳转到@1
    76 0000009B 48                              dec eax                         ;已经读取过头扇区了，所以需要减去一个
    77                                      @1:
    78 0000009C 09C0                            or eax,eax                      ;商为0表示程序的大小刚好小于等于512字节
    79 0000009E 7410                            jz pge
    80                                  
    81                                          ;读取剩余扇区
    82 000000A0 89C1                            mov ecx,eax                     ;32位模式下的LOOP使用ECX
    83 000000A2 B801000000                      mov eax,core_start_sector
    84 000000A7 40                              inc eax                         ;扇区号+1,从下一个扇区接着读
    85                                      @2:
    86 000000A8 E87B000000                      call read_hard_disk_0
    87 000000AD 40                              inc eax                         ;扇区号+1
    88 000000AE E2F8                            loop @2                         ;先将ecx值减一，如果ecx的值不为0，则执行循环，否则向下继续执行
    89                                  
    90                                  ;-----------打开分页机制----------------------------------------------------------------
    91                                      pge:                                ;准备打开分页机制。从此，再也不用在段之间转来转去，实在晕乎~
    92                                          ;创建系统内核的页目录表PDT
    93 000000B0 BB00000200                      mov ebx,0x00020000                 ;页目录表PDT的物理地址
    94                                          
    95                                          ;在页目录内创建指向自己的目录项
    96 000000B5 C783FC0F0000030002-             mov dword [ebx+4092],0x00020003     ;每项的高20位才是物理地址，低16位为控制位，最后的0x0003表示页的属性，表示可读写以及不允许特权3访问的
    96 000000BE 00                 
    97                                          
    98 000000BF BA03100200                      mov edx,0x00021003                  ;第一个页表物理地址为：0x00021000
    99                                          ;在页目录内创建与线性地址0x00000000对应的目录项
   100 000000C4 8913                            mov [ebx+0x000],edx                 ;写入目录项（页表的物理地址和属性）      
   101                                                                              ;此目录项仅用于过渡。
   102                                          ;在页目录内创建与线性地址0x80000000对应的目录项
   103 000000C6 899300080000                    mov [ebx+0x800],edx                 ;写入目录项（页表的物理地址和属性）
   104                                  
   105                                          ;创建与上面那个目录项相对应的页表，初始化页表项 
   106 000000CC BB00100200                      mov ebx,0x00021000                 ;页表的物理地址
   107 000000D1 31C0                            xor eax,eax                        ;起始页的物理地址 
   108 000000D3 31F6                            xor esi,esi
   109                                      .b1:       
   110 000000D5 89C2                            mov edx,eax
   111 000000D7 83CA03                          or edx,0x00000003                  ;页的属性都为11，表示可读写以及不允许特权3访问的                                    
   112 000000DA 8914B3                          mov [ebx+esi*4],edx                ;登记页的物理地址
   113 000000DD 0500100000                      add eax,0x1000                     ;下一个相邻页的物理地址 
   114 000000E2 46                              inc esi
   115 000000E3 81FE00010000                    cmp esi,256                        ;仅低端1MB内存对应的页才是有效的
   116 000000E9 7CEA                            jl .b1    
   117                                  
   118                                          ;令CR3寄存器指向页目录，并正式开启页功能 
   119 000000EB B800000200                      mov eax,0x00020000                 ;PCD=PWT=0
   120 000000F0 0F22D8                          mov cr3,eax
   121                                  
   122                                          ;将GDT的线性地址映射到从0x80000000开始的相同位置 
   123 000000F3 0F0105[6D010000]                sgdt [pgdt]                        ;将寄存器GDTR的值加载到内存pgdt出，此时给出的的pgdt是线性地址
   124 000000FA 8B1D[6F010000]                  mov ebx,[pgdt+2]
   125 00000100 8105[6F010000]0000-             add dword [pgdt+2],0x80000000      ;GDTR也用的是线性地址
   125 00000108 0080               
   126 0000010A 0F0115[6D010000]                lgdt [pgdt]                        ;将GDT新值写回GDTR寄存器
   127                                  
   128                                          ;开启分页功能
   129 00000111 0F20C0                          mov eax,cr0
   130 00000114 0D00000080                      or eax,0x80000000                   ;cr0的最高位设置为1表示开启分页
   131 00000119 0F22C0                          mov cr0,eax
   132                                  
   133                                          ;将堆栈映射到高端，这是非常容易被忽略的一件事。应当把内核的所有东西
   134                                          ;都移到高端，否则，一定会和正在加载的用户任务局部空间里的内容冲突，
   135                                          ;而且很难想到问题会出在这里。 
   136 0000011C 81C400000080                    add esp,0x80000000                 
   137                                                                              
   138 00000122 FF2504000480                    jmp [0x80040004]                    ;跳转到内核程序，段内跳转
   139                                  
   140                                  ;-----------从硬盘读取一个逻辑扇区----------------------------------------------------------------
   141                                      read_hard_disk_0:               ;使用的逻辑扇区编址方法为LBA28，也就是用28位来表示扇区号，每个扇区512字节
   142                                                                      ;eax=逻辑扇区号
   143                                                                      ;ds:ebx=目标缓冲区地址，将读到的硬盘数据放到ds段指定的内存中
   144                                  
   145 00000128 50                              push eax                    ;将该过程会用到的寄存器入栈保存，函数返回时需要出栈还原
   146 00000129 51                              push ecx
   147 0000012A 52                              push edx
   148                                  
   149 0000012B 50                              push eax                    ;在入栈一次eax的值
   150                                  
   151 0000012C 66BAF201                        mov dx,0x1f2                ;0x1f2端口表示要读取或写入的扇区数量，8位长度
   152 00000130 B001                            mov al,1                    ;每次要读取1个扇区
   153 00000132 EE                              out dx,al
   154                                  
   155                                          ;28位的扇区号太长，需要放到4个8位端口中，0x1f3存0-7位，0x1f4存8-15位，0x1f5存16-23位，
   156                                          ;0x1f6低4位存24-27位，第4位用于指示硬盘号，0是主盘、1是从盘,高三为全为1，表示LBA模式
   157 00000133 6642                            inc dx                      ;0x1f3
   158 00000135 58                              pop eax                     ;eax存放的是32位逻辑扇区号
   159 00000136 EE                              out dx,al                   ;LBA地址7-0
   160                                  
   161 00000137 6642                            inc dx                      ;0x1f4
   162 00000139 B108                            mov cl,8
   163 0000013B D3E8                            shr eax,cl
   164 0000013D EE                              out dx,al                    ;LBA地址15~8
   165                                  
   166 0000013E 6642                            inc dx                       ;0x1f5
   167 00000140 D3E8                            shr eax,cl
   168 00000142 EE                              out dx,al                    ;LBA地址23~16
   169                                  
   170 00000143 6642                            inc dx                      ;0x1f6
   171 00000145 D3E8                            shr eax,cl
   172 00000147 0CE0                            or al,0xe0                  ;因为al是1110 0000，ah高4位是0，0000 xxxx,使用or运算后al就是xxxx,表示LBA地址27-24
   173 00000149 EE                              out dx,al
   174                                  
   175 0000014A 6642                            inc dx                      ;0x1f7，既是命令端口也是状态端口，0x20表示读，0x30表示写
   176 0000014C B020                            mov al,0x20                 ;表示读硬盘
   177 0000014E EE                              out dx,al                  
   178                                  
   179                                          .waits:
   180 0000014F EC                                  in al,dx                    ;读取硬盘状态，第7位是1表示硬盘在忙碌，第3位是1表示已经读取完可以传输数据了
   181 00000150 2488                                and al,0x88                 ;二进制值：1000 1000，保留第7位与第3位的值，其他位全清0
   182 00000152 3C08                                cmp al,0x08                 ;二进制值：0000 1000，是否已经准备好了
   183 00000154 75F9                                jnz .waits                  ;尚未准备好，继续循环等待
   184                                  
   185 00000156 B900010000                      mov ecx,256                  ;总共要读取的字数
   186 0000015B 66BAF001                        mov dx,0x1f0                 ;硬盘数据端口，长度为16位的
   187                                  
   188                                          .readw:
   189 0000015F 66ED                                in ax,dx                    ;从硬盘读取一个字
   190 00000161 668903                              mov [ebx],ax                ;放到ds段内存中
   191 00000164 83C302                              add ebx,2                   ;bx偏移地址+2
   192 00000167 E2F6                                loop .readw                 ;先将ecx值减一，如果ecx的值不为0，则执行循环，否则向下继续执行
   193                                  
   194 00000169 5A                              pop edx                      ;出栈，还原相关寄存器的原始值
   195 0000016A 59                              pop ecx
   196 0000016B 58                              pop eax
   197                                  
   198 0000016C C3                              ret                         ;返回
   199                                  ;-----------数据区----------------------------------------------------------------
   200 0000016D 0000                        pgdt dw 0               ;描述符表的界限
   201 0000016F 00800000                         dd 0x00008000  ;全局描述符表起始物理地址，该地址刚好是主引导程序后面的地址。
   202                                                              ;总共是16位+32位=48位，正好与GDTR寄存器的位数匹配
   203                                  
   204 00000173 00<rep 8Bh>                 times 510-($-$$)  db  0 ;剩余的字节数用0填充，'$$'表示当前段的起始地址，'$-$$'正好是当前程序的字节大小
   205 000001FE 55AA                                          db  0x55,0xaa ;引导扇区结束标识
