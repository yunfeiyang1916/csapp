     1                                  ;保护模式微型内核程序 
     2                                  
     3                                  ;以下常量定义部分。内核的大部分内容都应当固定 
     4                                  core_code_seg_sel     equ  0x38    ;内核代码段选择子
     5                                  core_data_seg_sel     equ  0x30    ;内核数据段选择子 
     6                                  sys_routine_seg_sel   equ  0x28    ;系统公共例程代码段的选择子 
     7                                  video_ram_seg_sel     equ  0x20    ;视频显示缓冲区的段选择子
     8                                  core_stack_seg_sel    equ  0x18    ;内核堆栈段选择子
     9                                  mem_0_4_gb_seg_sel    equ  0x08    ;整个0-4GB内存的段的选择子
    10                                  
    11                                  ;-----------内核头部-----------------------------------------------------------------------
    12                                  ;以下是系统核心的头部，用于加载核心程序 
    13 00000000 [00000000]              core_length dd core_end                         ;[0x00]内核总长度，双字，32位
    14 00000004 [00000000]              sys_routine_seg dd section.sys_routine.start    ;[0x04]系统通用库偏移地址
    15 00000008 [00000000]              core_data_seg dd section.core_data.start        ;[0x08]内核数据段偏移地址
    16 0000000C [00000000]              core_code_seg dd section.core_code.start        ;[0x0c]内核代码段偏移地址
    17 00000010 [93030000]              core_entry dd start                             ;[0x10]内核代码段入口地址偏移量
    18 00000014 3800                               dw core_code_seg_sel                 ;[0x14]内核代码段选择子,16位的
    19                                  
    20                                  
    21                                  [bits 32]
    22                                  ;-----------系统通用库、提供字符串显示等功能-----------------------------------------------------------------------
    23                                  section sys_routine vstart=0
    24                                  ;-----------显示字符串--------------------------------------------------------------------
    25                                      put_string:                             ;显示0终止的字符串并移动光标 
    26                                                                              ;输入：DS:EBX=串地址
    27 00000000 51                              push ecx
    28                                      .getc:
    29 00000001 8A0B                            mov cl,[ebx]
    30 00000003 08C9                            or cl,cl
    31 00000005 7408                            jz .exit
    32 00000007 E805000000                      call put_char
    33 0000000C 43                              inc ebx
    34 0000000D EBF2                            jmp .getc
    35                                  
    36                                      .exit:
    37 0000000F 59                              pop ecx
    38 00000010 CB                              retf                               ;段间返回
    39                                  
    40                                      put_char:                               ;在当前光标处显示一个字符,并推进
    41                                                                      ;光标。仅用于段内调用 
    42                                                                      ;输入：CL=字符ASCII码 
    43 00000011 60                              pushad                        ;依次压入：EAX,ECX,EDX,EBX,ESP(初始值)，EBP,ESI,EDI     
    44                                  
    45                                          ;以下取当前光标位置
    46 00000012 66BAD403                        mov dx,0x3d4
    47 00000016 B00E                            mov al,0x0e
    48 00000018 EE                              out dx,al
    49 00000019 6642                            inc dx                             ;0x3d5
    50 0000001B EC                              in al,dx                           ;高字
    51 0000001C 88C4                            mov ah,al
    52                                  
    53 0000001E 664A                            dec dx                             ;0x3d4
    54 00000020 B00F                            mov al,0x0f
    55 00000022 EE                              out dx,al
    56 00000023 6642                            inc dx                             ;0x3d5
    57 00000025 EC                              in al,dx                           ;低字
    58 00000026 6689C3                          mov bx,ax                          ;BX=代表光标位置的16位数
    59                                  
    60 00000029 80F90D                          cmp cl,0x0d                        ;回车符？
    61 0000002C 750E                            jnz .put_0a
    62 0000002E 6689D8                          mov ax,bx
    63 00000031 B350                            mov bl,80
    64 00000033 F6F3                            div bl
    65 00000035 F6E3                            mul bl
    66 00000037 6689C3                          mov bx,ax
    67 0000003A EB60                            jmp .set_cursor
    68                                  
    69                                      .put_0a:
    70 0000003C 80F90A                          cmp cl,0x0a                        ;换行符？
    71 0000003F 7506                            jnz .put_other
    72 00000041 6683C350                        add bx,80
    73 00000045 EB15                            jmp .roll_screen
    74                                  
    75                                      .put_other:                               ;正常显示字符
    76 00000047 06                              push es
    77 00000048 B820000000                      mov eax,video_ram_seg_sel          ;0xb8000段的选择子
    78 0000004D 8EC0                            mov es,eax
    79 0000004F 66D1E3                          shl bx,1
    80 00000052 2667880F                        mov [es:bx],cl
    81 00000056 07                              pop es
    82                                  
    83                                          ;以下将光标位置推进一个字符
    84 00000057 66D1EB                          shr bx,1
    85 0000005A 6643                            inc bx
    86                                  
    87                                      .roll_screen:
    88 0000005C 6681FBD007                      cmp bx,2000                        ;光标超出屏幕？滚屏
    89 00000061 7C39                            jl .set_cursor
    90                                  
    91 00000063 1E                              push ds
    92 00000064 06                              push es
    93 00000065 B820000000                      mov eax,video_ram_seg_sel
    94 0000006A 8ED8                            mov ds,eax
    95 0000006C 8EC0                            mov es,eax
    96 0000006E FC                              cld
    97 0000006F BEA0000000                      mov esi,0xa0                       ;小心！32位模式下movsb/w/d 
    98 00000074 BF00000000                      mov edi,0x00                       ;使用的是esi/edi/ecx 
    99 00000079 B980070000                      mov ecx,1920
   100 0000007E F3A5                            rep movsd
   101 00000080 66BB000F                        mov bx,3840                        ;清除屏幕最底一行
   102 00000084 B950000000                  mov ecx,80                         ;32位程序应该使用ECX
   103                                      .cls:
   104 00000089 266667C7072007                  mov word[es:bx],0x0720
   105 00000090 6683C302                        add bx,2
   106 00000094 E2F3                            loop .cls
   107                                  
   108 00000096 07                              pop es
   109 00000097 1F                              pop ds
   110                                  
   111 00000098 66BB8007                        mov bx,1920
   112                                  
   113                                      .set_cursor:
   114 0000009C 66BAD403                        mov dx,0x3d4
   115 000000A0 B00E                            mov al,0x0e
   116 000000A2 EE                              out dx,al
   117 000000A3 6642                            inc dx                             ;0x3d5
   118 000000A5 88F8                            mov al,bh
   119 000000A7 EE                              out dx,al
   120 000000A8 664A                            dec dx                             ;0x3d4
   121 000000AA B00F                            mov al,0x0f
   122 000000AC EE                              out dx,al
   123 000000AD 6642                            inc dx                             ;0x3d5
   124 000000AF 88D8                            mov al,bl
   125 000000B1 EE                              out dx,al
   126                                  
   127 000000B2 61                              popad
   128 000000B3 C3                              ret 
   129                                  
   130                                  ;-----------从硬盘读取一个逻辑扇区----------------------------------------------------------------
   131                                      read_hard_disk_0:               ;使用的逻辑扇区编址方法为LBA28，也就是用28位来表示扇区号，每个扇区512字节
   132                                                                      ;eax=逻辑扇区号
   133                                                                      ;ds:ebx=目标缓冲区地址，将读到的硬盘数据放到ds段指定的内存中
   134                                  
   135 000000B4 50                              push eax                    ;将该过程会用到的寄存器入栈保存，函数返回时需要出栈还原
   136 000000B5 51                              push ecx
   137 000000B6 52                              push edx
   138                                  
   139 000000B7 50                              push eax                    ;在入栈一次eax的值
   140                                  
   141 000000B8 66BAF201                        mov dx,0x1f2                ;0x1f2端口表示要读取或写入的扇区数量，8位长度
   142 000000BC B001                            mov al,1                    ;每次要读取1个扇区
   143 000000BE EE                              out dx,al
   144                                  
   145                                          ;28位的扇区号太长，需要放到4个8位端口中，0x1f3存0-7位，0x1f4存8-15位，0x1f5存16-23位，
   146                                          ;0x1f6低4位存24-27位，第4位用于指示硬盘号，0是主盘、1是从盘,高三为全为1，表示LBA模式
   147 000000BF 6642                            inc dx                      ;0x1f3
   148 000000C1 58                              pop eax                     ;eax存放的是32位逻辑扇区号
   149 000000C2 EE                              out dx,al                   ;LBA地址7-0
   150                                  
   151 000000C3 6642                            inc dx                      ;0x1f4
   152 000000C5 B108                            mov cl,8
   153 000000C7 D3E8                            shr eax,cl
   154 000000C9 EE                              out dx,al                    ;LBA地址15~8
   155                                  
   156 000000CA 6642                            inc dx                       ;0x1f5
   157 000000CC D3E8                            shr eax,cl
   158 000000CE EE                              out dx,al                    ;LBA地址23~16
   159                                  
   160 000000CF 6642                            inc dx                      ;0x1f6
   161 000000D1 D3E8                            shr eax,cl
   162 000000D3 0CE0                            or al,0xe0                  ;因为al是1110 0000，ah高4位是0，0000 xxxx,使用or运算后al就是xxxx,表示LBA地址27-24
   163 000000D5 EE                              out dx,al
   164                                  
   165 000000D6 6642                            inc dx                      ;0x1f7，既是命令端口也是状态端口，0x20表示读，0x30表示写
   166 000000D8 B020                            mov al,0x20                 ;表示读硬盘
   167 000000DA EE                              out dx,al                  
   168                                  
   169                                          .waits:
   170 000000DB EC                                      in al,dx                    ;读取硬盘状态，第7位是1表示硬盘在忙碌，第3位是1表示已经读取完可以传输数据了
   171 000000DC 2488                                    and al,0x88                 ;二进制值：1000 1000，保留第7位与第3位的值，其他位全清0
   172 000000DE 3C08                                    cmp al,0x08                 ;二进制值：0000 1000，是否已经准备好了
   173 000000E0 75F9                                    jnz .waits                  ;尚未准备好，继续循环等待
   174                                  
   175 000000E2 B900010000                      mov ecx,256                  ;总共要读取的字数
   176 000000E7 66BAF001                        mov dx,0x1f0                 ;硬盘数据端口，长度为16位的
   177                                  
   178                                          .readw:
   179 000000EB 66ED                                    in ax,dx                    ;从硬盘读取一个字
   180 000000ED 668903                                  mov [ebx],ax                ;放到ds段内存中
   181 000000F0 83C302                                  add ebx,2                   ;bx偏移地址+2
   182 000000F3 E2F6                                    loop .readw                 ;先将ecx值减一，如果ecx的值不为0，则执行循环，否则向下继续执行
   183                                  
   184 000000F5 5A                              pop edx                      ;出栈，还原相关寄存器的原始值
   185 000000F6 59                              pop ecx
   186 000000F7 58                              pop eax
   187                                  
   188 000000F8 CB                              retf                         ;段间返回
   189                                  
   190                                  ;-----------输出调试信息-----------------------------------------------------------------------
   191                                      put_hex_dword:                      ;汇编语言程序是极难一次成功，而且调试非常困难。这个例程可以提供帮助 
   192                                                                          ;输入：EDX=要转换并显示的数字。在当前光标处以十六进制形式显示 ;一个双字并推进光标 
   193 000000F9 60                              pushad
   194 000000FA 1E                              push ds
   195                                  
   196 000000FB 66B83000                        mov ax,core_data_seg_sel           ;切换到核心数据段 
   197 000000FF 8ED8                            mov ds,ax
   198                                  
   199 00000101 BB[2B050000]                    mov ebx,bin_hex                    ;指向核心数据段内的转换表
   200 00000106 B908000000                      mov ecx,8
   201                                      .xlt:    
   202 0000010B C1C204                          rol edx,4
   203 0000010E 89D0                            mov eax,edx
   204 00000110 83E00F                          and eax,0x0000000f
   205 00000113 D7                              xlat
   206                                  
   207 00000114 51                              push ecx
   208 00000115 88C1                            mov cl,al                           
   209 00000117 E8F5FEFFFF                      call put_char
   210 0000011C 59                              pop ecx
   211                                  
   212 0000011D E2EC                            loop .xlt
   213                                  
   214 0000011F 1F                              pop ds
   215 00000120 61                              popad
   216 00000121 CB                              retf
   217                                  
   218                                  ;-----------分配内存-----------------------------------------------------------------------
   219                                      allocate_memory:
   220                                                                      ;输入ecx=希望分配的内存字节数，输出ecx=已分配的内存起始线性地址
   221 00000122 1E                              push ds
   222 00000123 50                              push eax
   223 00000124 53                              push ebx
   224                                  
   225 00000125 B830000000                      mov eax,core_data_seg_sel
   226 0000012A 8ED8                            mov ds,eax                  ;使ds指向4G内存选择子
   227                                  
   228 0000012C A1[06000000]                    mov eax,[ram_alloc]           
   229 00000131 01C8                            add eax,ecx                 ;下一次分配内存时的起始地址
   230                                  
   231                                          ;todo 这里应当有检测可用内存数量的指令
   232                                  
   233 00000133 8B0D[06000000]                  mov ecx,[ram_alloc]         ;返回分配的起始地址
   234                                  
   235 00000139 89C3                            mov ebx,eax
   236 0000013B 83E3FC                          and ebx,0xfffffffc
   237 0000013E 83E304                          and ebx,4                   ;强制4字节对齐
   238 00000141 A903000000                      test eax,0x00000003         ;测试下一次分配内存的起始地址是不是4字节对齐的
   239 00000146 0F45C3                          cmovnz eax,ebx              ;如果没有对齐，则强制对齐。cmovnz指令可以避免控制转移
   240 00000149 A3[06000000]                    mov [ram_alloc],eax         ;下次从该地址分配内存 
   241                                  
   242 0000014E 5B                              pop ebx
   243 0000014F 58                              pop eax
   244 00000150 1F                              pop ds
   245                                  
   246 00000151 CB                              retf
   247                                  
   248                                  ;-----------在GDT内安装一个新的描述符--------------------------------------------------------------------
   249                                      set_up_gdt_descriptor:             ;输入edx:eax=描述符，输出cx=描述符选择子
   250 00000152 50                              push eax
   251 00000153 53                              push ebx
   252 00000154 52                              push edx
   253                                  
   254 00000155 1E                              push ds
   255 00000156 06                              push es
   256                                  
   257 00000157 BB30000000                      mov ebx,core_data_seg_sel          ;切换到核心数据段
   258 0000015C 8EDB                            mov ds,ebx
   259                                  
   260 0000015E 0F0105[00000000]                sgdt [pgdt]                        ;读取寄存器GDTR，存放到内存
   261                                  
   262 00000165 BB08000000                      mov ebx,mem_0_4_gb_seg_sel
   263 0000016A 8EC3                            mov es,ebx
   264                                  
   265 0000016C 0FB71D[00000000]                movzx ebx,word [pgdt]              ;GDT界限 
   266 00000173 6643                            inc bx                             ;GDT总字节数，也是下一个描述符偏移 
   267 00000175 031D[02000000]                  add ebx,[pgdt+2]                   ;下一个描述符的线性地址 
   268                                  
   269 0000017B 268903                          mov [es:ebx],eax
   270 0000017E 26895304                        mov [es:ebx+4],edx
   271                                  
   272 00000182 668305[00000000]08              add word [pgdt],8                  ;增加一个描述符的大小   
   273                                  
   274 0000018A 0F0115[00000000]                lgdt [pgdt]                        ;对GDT的更改生效 
   275                                          
   276 00000191 66A1[00000000]                  mov ax,[pgdt]                      ;得到GDT界限值
   277 00000197 6631D2                          xor dx,dx
   278 0000019A 66BB0800                        mov bx,8
   279 0000019E 66F7F3                          div bx                             ;除以8，去掉余数
   280 000001A1 6689C1                          mov cx,ax                          
   281 000001A4 66C1E103                        shl cx,3                           ;将索引号移到正确位置 
   282                                  
   283 000001A8 07                              pop es
   284 000001A9 1F                              pop ds
   285                                  
   286 000001AA 5A                              pop edx
   287 000001AB 5B                              pop ebx
   288 000001AC 58                              pop eax
   289                                  
   290 000001AD CB                              retf        
   291                                  
   292                                  ;-----------构造描述符--------------------------------------------------------------------
   293                                      make_seg_descriptor:            ;输入：eax=线性基址，ebx=段界限,ecx=属性（各属性位都在原始位置，其它没用到的位置0） 
   294                                                                      ;输出edx:eax=完整的描述符
   295 000001AE 89C2                            mov edx,eax
   296 000001B0 C1E010                          shl eax,16                  ;描述符低32位中的高16位是基地址部分，所以左移16位使其基地址部分就位
   297 000001B3 6609D8                          or ax,bx                    ;低16位是段界限，取的段界限
   298                                  
   299 000001B6 81E20000FFFF                    and edx,0xffff0000          ;清除低16位
   300 000001BC C1C208                          rol edx,8                   ;edx循环左移8位，循环左移会将左移出的位放到右边。这样edx中低8位的值就是原先高8位的值
   301 000001BF 0FCA                            bswap edx                   ;字节交换指令。装配基址的31~24和23~16  (80486+)
   302                                  
   303 000001C1 6631DB                          xor bx,bx
   304 000001C4 09DA                            or edx,ebx                  ;装配段界限的高4位
   305                                          
   306 000001C6 09CA                            or edx,ecx                  ;装配段属性
   307                                  
   308 000001C8 CB                              retf
   309                                  
   310                                  ;-----------构造门的描述符（调用门等）--------------------------------------------------------------------
   311                                      make_gate_descriptor:           ;输入：eax=门代码在段内的偏移地址，bx=门代码的段选择子，cx=门属性
   312                                                                      ;输出：edx:eax=完整的描述符
   313 000001C9 53                              push ebx
   314 000001CA 51                              push ecx
   315                                  
   316 000001CB 89C2                            mov edx,eax
   317 000001CD 81E20000FFFF                    and edx,0xffff0000          ;得到偏移地址高16位 
   318 000001D3 6609CA                          or  dx,cx                   ;组装属性部分到edx
   319                                  
   320 000001D6 25FFFF0000                      and eax,0x0000ffff          ;得到偏移地址低16位
   321 000001DB C1E310                          shl ebx,16                  ;左移16位使段选择子位于它的高16位        
   322 000001DE 09D8                            or eax,ebx                  ;组装段选择子部分
   323                                      
   324 000001E0 59                              pop ecx
   325 000001E1 5B                              pop ebx
   326                                      
   327 000001E2 CB                              retf   
   328                                  
   329                                      sys_routine_end:
   330                                  
   331                                  ;-----------内核数据段-----------------------------------------------------------------------
   332                                  section core_data vstart=0                   
   333 00000000 0000                        pgdt            dw  0             ;用于设置和修改GDT 
   334 00000002 00000000                                    dd  0
   335                                  
   336 00000006 00001000                    ram_alloc       dd  0x00100000    ;下次分配内存时的起始地址
   337                                  
   338                                      ;符号地址检索表
   339                                      salt:
   340 0000000A 405072696E74537472-             salt_1          db  '@PrintString'      ;打印字符串函数别名
   340 00000013 696E67             
   341 00000016 00<rep F4h>                                 times 256-($-salt_1) db 0   ;不足256长度的补0
   342 0000010A [00000000]                                      dd  put_string          ;函数偏移量
   343 0000010E 2800                                            dw  sys_routine_seg_sel ;公共库代码段选择子，内核执行时会使用调用门段选择子替换
   344                                  
   345 00000110 40526561644469736B-             salt_2          db  '@ReadDiskData'
   345 00000119 44617461           
   346 0000011D 00<rep F3h>                                 times 256-($-salt_2) db 0
   347 00000210 [B4000000]                                      dd  read_hard_disk_0
   348 00000214 2800                                            dw  sys_routine_seg_sel
   349                                  
   350 00000216 405072696E7444776F-             salt_3          db  '@PrintDwordAsHexString'
   350 0000021F 726441734865785374-
   350 00000228 72696E67           
   351 0000022C 00<rep EAh>                                 times 256-($-salt_3) db 0
   352 00000316 [F9000000]                                      dd  put_hex_dword
   353 0000031A 2800                                            dw  sys_routine_seg_sel
   354                                  
   355 0000031C 405465726D696E6174-             salt_4          db  '@TerminateProgram'
   355 00000325 6550726F6772616D   
   356 0000032D 00<rep EFh>                                 times 256-($-salt_4) db 0
   357 0000041C [C3040000]                                      dd  return_point
   358 00000420 3800                                            dw  core_code_seg_sel
   359                                  
   360                                          salt_item_len   equ $-salt_4                ;单个符号表大小，262字节
   361                                          salt_items      equ ($-salt)/salt_item_len  ;符号表数量
   362                                  
   363 00000422 2020496620796F7520-         message_1       db  '  If you seen this message,that means we '
   363 0000042B 7365656E2074686973-
   363 00000434 206D6573736167652C-
   363 0000043D 74686174206D65616E-
   363 00000446 7320776520         
   364 0000044B 617265206E6F772069-                         db  'are now in protect mode,and the system '
   364 00000454 6E2070726F74656374-
   364 0000045D 206D6F64652C616E64-
   364 00000466 207468652073797374-
   364 0000046F 656D20             
   365 00000472 636F7265206973206C-                         db  'core is loaded,and the video display '
   365 0000047B 6F616465642C616E64-
   365 00000484 207468652076696465-
   365 0000048D 6F20646973706C6179-
   365 00000496 20                 
   366 00000497 726F7574696E652077-                         db  'routine works perfectly.',0x0d,0x0a,0
   366 000004A0 6F726B732070657266-
   366 000004A9 6563746C792E0D0A00 
   367                                  
   368 000004B2 202053797374656D20-         message_2       db  '  System wide CALL-GATE mounted.',0x0d,0x0a,0
   368 000004BB 776964652043414C4C-
   368 000004C4 2D47415445206D6F75-
   368 000004CD 6E7465642E0D0A00   
   369                                  
   370 000004D5 0D0A20204C6F616469-         message_3       db  0x0d,0x0a,'  Loading user program...',0
   370 000004DE 6E6720757365722070-
   370 000004E7 726F6772616D2E2E2E-
   370 000004F0 00                 
   371                                  
   372 000004F1 446F6E652E0D0A00            do_status       db  'Done.',0x0d,0x0a,0
   373                                  
   374 000004F9 0D0A0D0A0D0A                message_6       db  0x0d,0x0a,0x0d,0x0a,0x0d,0x0a
   375 000004FF 202055736572207072-                         db  '  User program terminated,control returned.',0
   375 00000508 6F6772616D20746572-
   375 00000511 6D696E617465642C63-
   375 0000051A 6F6E74726F6C207265-
   375 00000523 7475726E65642E00   
   376                                  
   377 0000052B 303132333435363738-         bin_hex         db '0123456789ABCDEF'
   377 00000534 39414243444546     
   378                                                                      ;put_hex_dword子过程用的查找表 
   379                                  
   380 0000053B 00<rep 800h>                core_buf   times 2048 db 0         ;内核用的缓冲区
   381                                  
   382 00000D3B 00000000                    esp_pointer     dd 0              ;内核用来临时保存自己的栈指针     
   383                                  
   384 00000D3F 0D0A202000                  cpu_brnd0       db 0x0d,0x0a,'  ',0
   385 00000D44 00<rep 34h>                 cpu_brand  times 52 db 0
   386 00000D78 0D0A0D0A00                  cpu_brnd1       db 0x0d,0x0a,0x0d,0x0a,0
   387                                  
   388                                      ;任务控制块链表头
   389 00000D7D 00000000                    tcb_chain       dd  0
   390                                  
   391                                      core_data_end:
   392                                  
   393                                  ;-----------内核代码段-----------------------------------------------------------------------
   394                                  section core_code vstart=0
   395                                  ;-----------在LDT内安装一个新的描述符-----------------------------------------------------------------------
   396                                      fill_descriptor_in_ldt:             ;输入：edx:eax=完整描述符，ebx=TCB基地址
   397                                                                          ;输出：cx=描述符选择子
   398 00000000 50                              push eax
   399 00000001 52                              push edx
   400 00000002 57                              push edi
   401 00000003 1E                              push ds
   402                                  
   403 00000004 B908000000                      mov ecx,mem_0_4_gb_seg_sel
   404 00000009 8ED9                            mov ds,ecx                      ;使ds指向4G数据段
   405                                  
   406 0000000B 8B7B0C                          mov edi,[ebx+0x0c]              ;获得LDT基地址
   407                                  
   408 0000000E 31C9                            xor ecx,ecx
   409 00000010 668B4B0A                        mov cx,[ebx+0x0a]               ;获得LDT界限
   410 00000014 6641                            inc cx                          ;LDT的总字节数，即新描述符偏移地址
   411                                  
   412 00000016 89040F                          mov [edi+ecx+0x00],eax
   413 00000019 89540F04                        mov [edi+ecx+0x04],edx          ;安装描述符
   414                                  
   415 0000001D 6683C108                        add cx,8                           
   416 00000021 6649                            dec cx                          ;得到新的LDT界限值 
   417                                  
   418 00000023 66894B0A                        mov [ebx+0x0a],cx               ;更新LDT界限值到TCB
   419                                  
   420 00000027 6689C8                          mov ax,cx
   421 0000002A 6631D2                          xor dx,dx
   422 0000002D 66B90800                        mov cx,8
   423 00000031 66F7F1                          div cx                          ;除以8，商就是新描述符的索引
   424                                  
   425 00000034 6689C1                          mov cx,ax
   426 00000037 66C1E103                        shl cx,3                         ;左移3位，并且
   427 0000003B 6683C904                        or cx,0000_0000_0000_0100B       ;使TI位=1，指向LDT，最后使RPL=00 
   428                                  
   429 0000003F 1F                              pop ds
   430 00000040 5F                              pop edi
   431 00000041 5A                              pop edx
   432 00000042 58                              pop eax
   433                                      
   434 00000043 C3                              ret
   435                                  
   436                                  ;-----------加载并重定位用户程序-----------------------------------------------------------------------
   437                                      load_relocate_program:              ;输入push:逻辑扇区号，push:任务控制块起始地址
   438                                                                          ;调用该函数时会先压入EIP
   439 00000044 60                              pushad                          ;依次压入：EAX,ECX,EDX,EBX,ESP(初始值)，EBP,ESI,EDI,共8个寄存器
   440 00000045 1E                              push ds
   441 00000046 06                              push es                         
   442                                  
   443 00000047 89E5                            mov ebp,esp                     ;使栈基址寄存器指向初始栈地址
   444 00000049 B908000000                      mov ecx,mem_0_4_gb_seg_sel
   445 0000004E 8EC1                            mov es,ecx                      ;es指向4G数据段
   446                                  
   447 00000050 8B752C                          mov esi,[ebp+11*4]              ;因为又压入了11个寄存器的值，所以取任务控制块起始地址需要从11偏移量开始
   448                                                                          ;用ebp寻址时，会使用段寄存器ss
   449                                  
   450                                          ;以下申请创建LDT局部描述符表内存
   451 00000053 B9A0000000                      mov ecx,160                     ;允许安装20个LDT,每个描述符占8字节
   452 00000058 9A[22010000]2800                call sys_routine_seg_sel:allocate_memory    ;分配内存，返回ecx=已分配起始内存地址
   453 0000005F 26894E0C                        mov [es:esi+0x0c],ecx           ;登记LDT基地址到TCB中
   454 00000063 2666C7460AFFFF                  mov word [es:esi+0x0a],0xffff   ;登记LDT初始的界限到TCB中 
   455                                  
   456                                          ;以下开始加载用户程序
   457 0000006A B830000000                      mov eax,core_data_seg_sel
   458 0000006F 8ED8                            mov ds,eax                      ;使ds指向内核数据段
   459                                  
   460 00000071 8B4530                          mov eax,[ebp+12*4]              ;读取起始扇区号
   461 00000074 BB[3B050000]                    mov ebx,core_buf                ;用于读取磁盘数据的内核缓冲区
   462 00000079 9A[B4000000]2800                call sys_routine_seg_sel:read_hard_disk_0
   463                                  
   464                                          ;以下判断整个程序有多大
   465 00000080 A1[3B050000]                    mov eax,[core_buf]                  ;程序尺寸
   466 00000085 89C3                            mov ebx,eax
   467 00000087 81E300FEFFFF                    and ebx,0xfffffe00                  ;使之512字节对齐（能被512整除的数低 
   468 0000008D 81C300020000                    add ebx,512                         ;9位都为0 
   469 00000093 A9FF010000                      test eax,0x000001ff                 ;程序的大小正好是512的倍数吗? 
   470 00000098 0F45C3                          cmovnz eax,ebx                      ;不是。使用凑整的结果
   471                                  
   472 0000009B 89C1                            mov ecx,eax                         ;程序的大小
   473 0000009D 9A[22010000]2800                call sys_routine_seg_sel:allocate_memory    ;分配内存，返回ecx=已分配起始内存地址
   474 000000A4 26894E06                        mov [es:esi+0x06],ecx               ;登记用户程序起始线性地址到TCB中
   475                                  
   476 000000A8 89CB                            mov ebx,ecx                         ;ebx -> 申请到的内存首地址
   477 000000AA 31D2                            xor edx,edx
   478 000000AC B900020000                      mov ecx,512
   479 000000B1 F7F1                            div ecx
   480 000000B3 89C1                            mov ecx,eax                         ;总扇区数 
   481                                      
   482 000000B5 B808000000                      mov eax,mem_0_4_gb_seg_sel          ;切换DS到0-4GB的段
   483 000000BA 8ED8                            mov ds,eax
   484                                  
   485 000000BC 8B4530                          mov eax,[ebp+12*4]                  ;起始扇区号 
   486                                      .b1:
   487 000000BF 9A[B4000000]2800                call sys_routine_seg_sel:read_hard_disk_0         ;读取剩余部分
   488 000000C6 40                              inc eax
   489 000000C7 E2F6                            loop .b1                                          ;先将ecx值减一，如果ecx的值不为0，则执行循环，否则向下继续执行  
   490                                  
   491 000000C9 268B7E06                        mov edi,[es:esi+0x06]                             ;获得程序加载基地址    
   492                                  
   493                                          
   494                                          ;建立程序头部段描述符
   495 000000CD 89F8                            mov eax,edi                        ;程序头部起始线性地址
   496 000000CF 8B5F04                          mov ebx,[edi+0x04]                 ;段长度
   497 000000D2 4B                              dec ebx                            ;段界限
   498 000000D3 B900F24000                      mov ecx,0x0040f200                 ;字节粒度的数据段描述符，特权级3 
   499 000000D8 9A[AE010000]2800                call sys_routine_seg_sel:make_seg_descriptor
   500                                  
   501                                          ;安装头部段描述符到LDT中
   502 000000DF 89F3                            mov ebx,esi                         ;TCB基地址                              
   503 000000E1 E81AFFFFFF                      call fill_descriptor_in_ldt         ;安装头部段描述符到LDT中
   504                                  
   505 000000E6 6683C903                        or cx,0000_0000_0000_0011B         ;设置选择子的特权级为3
   506 000000EA 2666894E44                      mov [es:esi+0x44],cx               ;登记程序头部段选择子到TCB 
   507 000000EF 66894F04                        mov [edi+0x04],cx                  ;和用户程序头部内 
   508                                  
   509                                          ;建立程序代码段描述符
   510 000000F3 89F8                            mov eax,edi
   511 000000F5 034714                          add eax,[edi+0x14]                 ;代码起始线性地址
   512 000000F8 8B5F18                          mov ebx,[edi+0x18]                 ;段长度
   513 000000FB 4B                              dec ebx                            ;段界限
   514 000000FC B900F84000                      mov ecx,0x0040f800                 ;字节粒度的代码段描述符，特权级3
   515 00000101 9A[AE010000]2800                call sys_routine_seg_sel:make_seg_descriptor
   516 00000108 89F3                            mov ebx,esi                        ;TCB的基地址
   517 0000010A E8F1FEFFFF                      call fill_descriptor_in_ldt
   518 0000010F 6683C903                        or cx,0000_0000_0000_0011B         ;设置选择子的特权级为3
   519 00000113 66894F14                        mov [edi+0x14],cx                  ;登记代码段选择子到头部
   520                                  
   521                                          ;建立程序数据段描述符
   522 00000117 89F8                            mov eax,edi
   523 00000119 03471C                          add eax,[edi+0x1c]                 ;数据段起始线性地址
   524 0000011C 8B5F20                          mov ebx,[edi+0x20]                 ;段长度
   525 0000011F 4B                              dec ebx                            ;段界限 
   526 00000120 B900F24000                      mov ecx,0x0040f200                 ;字节粒度的数据段描述符，特权级3
   527 00000125 9A[AE010000]2800                call sys_routine_seg_sel:make_seg_descriptor
   528 0000012C 89F3                            mov ebx,esi                        ;TCB的基地址
   529 0000012E E8CDFEFFFF                      call fill_descriptor_in_ldt
   530 00000133 6683C903                        or cx,0000_0000_0000_0011B         ;设置选择子的特权级为3
   531 00000137 66894F1C                        mov [edi+0x1c],cx                  ;登记数据段选择子到头部
   532                                  
   533                                          ;建立程序堆栈段描述符
   534 0000013B 8B4F0C                          mov ecx,[edi+0x0c]                 ;4KB的倍率 
   535 0000013E BBFFFF0F00                      mov ebx,0x000fffff
   536 00000143 29CB                            sub ebx,ecx                        ;得到段界限
   537 00000145 B800100000                      mov eax,4096                        
   538 0000014A F7E1                            mul ecx                         
   539 0000014C 89C1                            mov ecx,eax                        ;准备为堆栈分配内存 
   540 0000014E 9A[22010000]2800                call sys_routine_seg_sel:allocate_memory
   541 00000155 01C8                            add eax,ecx                        ;得到堆栈的高端物理地址 
   542 00000157 B900F6C000                      mov ecx,0x00c0f600                 ;字节粒度的堆栈段描述符，特权级3
   543 0000015C 9A[AE010000]2800                call sys_routine_seg_sel:make_seg_descriptor
   544 00000163 89F3                            mov ebx,esi                        ;TCB的基地址
   545 00000165 E896FEFFFF                      call fill_descriptor_in_ldt
   546 0000016A 6683C903                        or cx,0000_0000_0000_0011B         ;设置选择子的特权级为3
   547 0000016E 66894F08                        mov [edi+0x08],cx                  ;登记堆栈段选择子到头部
   548                                  
   549                                          ;重定位SALT 
   550 00000172 B808000000                      mov eax,mem_0_4_gb_seg_sel         ;这里和前一章不同，头部段描述符已安装，但还没有生效，故只能通过4GB段访问用户程序头部  
   551 00000177 8EC0                            mov es,eax
   552                                  
   553 00000179 B830000000                      mov eax,core_data_seg_sel
   554 0000017E 8ED8                            mov ds,eax
   555                                      
   556 00000180 FC                              cld
   557                                  
   558 00000181 268B4F24                        mov ecx,[es:edi+0x24]              ;U-SALT条目数(通过访问4GB段取得) 
   559 00000185 83C728                          add edi,0x28                       ;U-SALT在4GB段内的偏移 
   560                                  
   561                                      .b2: 
   562 00000188 51                              push ecx
   563 00000189 57                              push edi
   564                                  
   565 0000018A B904000000                      mov ecx,salt_items                  ;内核符号表数量
   566 0000018F BE[0A000000]                    mov esi,salt                        ;源索引寄存器，内核符号表起始地址
   567                                      .b3:
   568 00000194 57                              push edi
   569 00000195 56                              push esi
   570 00000196 51                              push ecx
   571                                  
   572 00000197 B940000000                      mov ecx,64                         ;检索表中，每条目的比较次数 
   573 0000019C F3A7                            repe cmpsd                         ;每次比较4字节，repe是连续比较直到ecx为0，如果字符相等则重复比较 
   574 0000019E 7519                            jnz .b4
   575 000001A0 8B06                            mov eax,[esi]                      ;若匹配，则esi恰好指向其后的地址
   576 000001A2 26898700FFFFFF                  mov [es:edi-256],eax               ;将字符串改写成偏移地址 
   577 000001A9 668B4604                        mov ax,[esi+4]
   578 000001AD 6683C803                        or ax,0000000000000011B            ;以用户程序自己的特权级使用调用门故RPL=3 
   579                                  
   580 000001B1 2666898704FFFFFF                mov [es:edi-252],ax                ;回填调用门选择子 
   581                                      .b4:
   582                                        
   583 000001B9 59                              pop ecx
   584 000001BA 5E                              pop esi
   585 000001BB 81C606010000                    add esi,salt_item_len
   586 000001C1 5F                              pop edi                            ;从头比较 
   587 000001C2 E2D0                            loop .b3
   588                                      
   589 000001C4 5F                              pop edi
   590 000001C5 81C700010000                    add edi,256
   591 000001CB 59                              pop ecx
   592 000001CC E2BA                            loop .b2
   593                                  
   594 000001CE 8B752C                          mov esi,[ebp+11*4]                 ;从堆栈中取得TCB的基地址
   595                                  
   596                                          ;创建0特权级栈
   597 000001D1 B900100000                      mov ecx,4096                       ;栈大小为4kb
   598 000001D6 89C8                            mov eax,ecx                        ;为生成堆栈高端地址做准备
   599 000001D8 26894E1A                        mov [es:esi+0x1a],ecx              
   600 000001DC 26C16E1A0C                      shr dword [es:esi+0x1a],12         ;登记0特权级堆栈尺寸到TCB，逻辑右移12位，相当于除以4096
   601 000001E1 9A[22010000]2800                call sys_routine_seg_sel:allocate_memory    ;分配内存，返回ecx=已分配起始内存地址
   602 000001E8 01C8                            add eax,ecx                        ;堆栈必须使用高端地址为基地址   
   603 000001EA 2689461E                        mov [es:esi+0x1e],eax              ;登记0特权级堆栈基地址到TCB 
   604 000001EE BBFEFF0F00                      mov ebx,0xffffe                    ;段长度（界限）
   605 000001F3 B90096C000                      mov ecx,0x00c09600                 ;4KB粒度，读写，特权级0
   606 000001F8 9A[AE010000]2800                call sys_routine_seg_sel:make_seg_descriptor;构建段描述符
   607 000001FF 89F3                            mov ebx,esi                        ;TCB的基地址
   608 00000201 E8FAFDFFFF                      call fill_descriptor_in_ldt        ;安装段描述符到LDT中
   609                                          ;or cx,0000_0000_0000_0000         ;设置选择子的特权级为0
   610 00000206 2666894E22                      mov [es:esi+0x22],cx               ;登记0特权级堆栈选择子到TCB
   611 0000020B 26C7462400000000                mov dword [es:esi+0x24],0          ;登记0特权级堆栈初始ESP到TCB
   612                                  
   613                                          ;创建1特权级堆栈
   614 00000213 B900100000                      mov ecx,4096
   615 00000218 89C8                            mov eax,ecx                        ;为生成堆栈高端地址做准备
   616 0000021A 26894E28                        mov [es:esi+0x28],ecx
   617 0000021E 26C16E280C                      shr dword [es:esi+0x28],12               ;登记1特权级堆栈尺寸到TCB
   618 00000223 9A[22010000]2800                call sys_routine_seg_sel:allocate_memory
   619 0000022A 01C8                            add eax,ecx                        ;堆栈必须使用高端地址为基地址
   620 0000022C 2689462C                        mov [es:esi+0x2c],eax              ;登记1特权级堆栈基地址到TCB
   621 00000230 BBFEFF0F00                      mov ebx,0xffffe                    ;段长度（界限）
   622 00000235 B900B6C000                      mov ecx,0x00c0b600                 ;4KB粒度，读写，特权级1
   623 0000023A 9A[AE010000]2800                call sys_routine_seg_sel:make_seg_descriptor
   624 00000241 89F3                            mov ebx,esi                        ;TCB的基地址
   625 00000243 E8B8FDFFFF                      call fill_descriptor_in_ldt
   626 00000248 6683C901                        or cx,0000_0000_0000_0001          ;设置选择子的特权级为1
   627 0000024C 2666894E30                      mov [es:esi+0x30],cx               ;登记1特权级堆栈选择子到TCB
   628 00000251 26C7463200000000                mov dword [es:esi+0x32],0          ;登记1特权级堆栈初始ESP到TCB
   629                                  
   630                                          ;创建2特权级堆栈
   631 00000259 B900100000                      mov ecx,4096
   632 0000025E 89C8                            mov eax,ecx                        ;为生成堆栈高端地址做准备
   633 00000260 26894E36                        mov [es:esi+0x36],ecx
   634 00000264 26C16E360C                      shr dword [es:esi+0x36],12               ;登记2特权级堆栈尺寸到TCB
   635 00000269 9A[22010000]2800                call sys_routine_seg_sel:allocate_memory
   636 00000270 01C8                            add eax,ecx                        ;堆栈必须使用高端地址为基地址
   637 00000272 26894E3A                        mov [es:esi+0x3a],ecx              ;登记2特权级堆栈基地址到TCB
   638 00000276 BBFEFF0F00                      mov ebx,0xffffe                    ;段长度（界限）
   639 0000027B B900D6C000                      mov ecx,0x00c0d600                 ;4KB粒度，读写，特权级2
   640 00000280 9A[AE010000]2800                call sys_routine_seg_sel:make_seg_descriptor
   641 00000287 89F3                            mov ebx,esi                        ;TCB的基地址
   642 00000289 E872FDFFFF                      call fill_descriptor_in_ldt
   643 0000028E 6683C90A                        or cx,0000_0000_0000_0010          ;设置选择子的特权级为2
   644 00000292 2666894E3E                      mov [es:esi+0x3e],cx               ;登记2特权级堆栈选择子到TCB
   645 00000297 26C7464000000000                mov dword [es:esi+0x40],0          ;登记2特权级堆栈初始ESP到TCB
   646                                  
   647                                          ;在GDT中登记LDT描述符
   648 0000029F 268B460C                        mov eax,[es:esi+0x0c]              ;LDT的起始线性地址
   649 000002A3 260FB75E0A                      movzx ebx,word [es:esi+0x0a]       ;LDT段界限
   650 000002A8 B900824000                      mov ecx,0x00408200                 ;LDT描述符，特权级0
   651 000002AD 9A[AE010000]2800                call sys_routine_seg_sel:make_seg_descriptor
   652 000002B4 9A[52010000]2800                call sys_routine_seg_sel:set_up_gdt_descriptor
   653 000002BB 2666894E10                      mov [es:esi+0x10],cx               ;登记LDT选择子到TCB中
   654                                  
   655                                          ;创建用户程序的TSS
   656 000002C0 B968000000                      mov ecx,104                        ;tss的基本尺寸，还可以更大
   657 000002C5 2666894E12                      mov [es:esi+0x12],cx              
   658 000002CA 2666FF4E12                      dec word [es:esi+0x12]             ;登记TSS界限值到TCB，界限值需要减一 
   659 000002CF 9A[22010000]2800                call sys_routine_seg_sel:allocate_memory    ;分配内存，返回ecx=已分配起始内存地址
   660 000002D6 26894E14                        mov [es:esi+0x14],ecx              ;登记TSS基地址到TCB
   661                                  
   662                                          ;登记基本的TSS表格内容
   663 000002DA 2666C7010000                    mov word [es:ecx+0],0              ;反向链=0
   664                                      
   665 000002E0 268B5624                        mov edx,[es:esi+0x24]              ;登记0特权级堆栈初始ESP
   666 000002E4 26895104                        mov [es:ecx+4],edx                 ;到TSS中
   667                                      
   668 000002E8 26668B5622                      mov dx,[es:esi+0x22]               ;登记0特权级堆栈段选择子
   669 000002ED 2666895108                      mov [es:ecx+8],dx                  ;到TSS中
   670                                      
   671 000002F2 268B5632                        mov edx,[es:esi+0x32]              ;登记1特权级堆栈初始ESP
   672 000002F6 2689510C                        mov [es:ecx+12],edx                ;到TSS中
   673                                  
   674 000002FA 26668B5630                      mov dx,[es:esi+0x30]               ;登记1特权级堆栈段选择子
   675 000002FF 2666895110                      mov [es:ecx+16],dx                 ;到TSS中
   676                                  
   677 00000304 268B5640                        mov edx,[es:esi+0x40]              ;登记2特权级堆栈初始ESP
   678 00000308 26895114                        mov [es:ecx+20],edx                ;到TSS中
   679                                  
   680 0000030C 26668B563E                      mov dx,[es:esi+0x3e]               ;登记2特权级堆栈段选择子
   681 00000311 2666895118                      mov [es:ecx+24],dx                 ;到TSS中
   682                                  
   683 00000316 26668B5610                      mov dx,[es:esi+0x10]               ;登记任务的LDT选择子
   684 0000031B 2666895160                      mov [es:ecx+96],dx                 ;到TSS中
   685                                      
   686 00000320 26668B5612                      mov dx,[es:esi+0x12]               ;登记任务的I/O位图偏移
   687 00000325 2666895166                      mov [es:ecx+102],dx                ;到TSS中 
   688                                      
   689 0000032A 2666C741640000                  mov word [es:ecx+100],0            ;T=0
   690                                  
   691                                          ;在GDT中登记TSS描述符
   692 00000331 268B4614                        mov eax,[es:esi+0x14]              ;TSS的起始线性地址
   693 00000335 260FB75E12                      movzx ebx,word [es:esi+0x12]       ;段长度（界限）
   694 0000033A B900894000                      mov ecx,0x00408900                 ;TSS描述符，特权级0
   695 0000033F 9A[AE010000]2800                call sys_routine_seg_sel:make_seg_descriptor
   696 00000346 9A[52010000]2800                call sys_routine_seg_sel:set_up_gdt_descriptor
   697 0000034D 2666894E18                      mov [es:esi+0x18],cx               ;登记TSS选择子到TCB
   698                                  
   699 00000352 07                              pop es                             ;恢复到调用此过程前的es段 
   700 00000353 1F                              pop ds                             ;恢复到调用此过程前的ds段
   701                                      
   702 00000354 61                              popad
   703                                      
   704 00000355 C20800                          ret 8                              ;丢弃调用本过程前压入的参数，也就是压入的两个参数，8个字节
   705                                  
   706                                  ;-----------在TCB链上追加任务控制块-----------------------------------------------------------------------
   707                                      append_to_tcb_link:                 ;输入：ecx=起始线性地址
   708 00000358 50                              push eax
   709 00000359 52                              push edx
   710 0000035A 1E                              push ds
   711 0000035B 06                              push es
   712                                  
   713 0000035C B830000000                      mov eax,core_data_seg_sel
   714 00000361 8ED8                            mov ds,eax                      ;令DS指向内核数据段 
   715                                  
   716 00000363 B808000000                      mov eax,mem_0_4_gb_seg_sel
   717 00000368 8EC0                            mov es,eax                      ;令ES指向0..4GB段
   718                                  
   719 0000036A 26C70100000000                  mov dword [es: ecx+0x00],0      ;当前TCB指针域清零，以指示这是最后一个TCB
   720 00000371 A1[7D0D0000]                    mov eax,[tcb_chain]
   721 00000376 09C0                            or eax,eax  
   722 00000378 740E                            jz .notcb                       ;如果表头指针为0，表明任务链表尚未有数据
   723                                  
   724                                      .searc:                             ;查找链表尾部
   725 0000037A 89C2                            mov edx,eax 
   726 0000037C 268B02                          mov eax,[es:edx+0x00]           
   727 0000037F 09C0                            or eax,eax
   728 00000381 75F7                            jnz .searc                      ;当前结点的指针域是否为空，不为空则继续查找
   729 00000383 26890A                          mov [es:edx+0x00],ecx           ;找到最后一个结点了，将新结点的起始线性地址赋值到最后一个结点的指针域
   730 00000386 EB06                            jmp .retpc
   731                                  
   732                                      .notcb:
   733 00000388 890D[7D0D0000]                  mov [tcb_chain],ecx             ;如果表头为空，则赋值当前链表起始线性地址
   734                                  
   735                                      .retpc:
   736 0000038E 07                              pop es
   737 0000038F 1F                              pop ds
   738 00000390 5A                              pop edx
   739 00000391 58                              pop eax
   740                                          
   741 00000392 C3                              ret
   742                                  
   743                                  ;-----------程序入口-----------------------------------------------------------------------
   744                                      start:
   745 00000393 B930000000                      mov ecx,core_data_seg_sel
   746 00000398 8ED9                            mov ds,ecx                              ;使ds指向内核数据段
   747                                          
   748 0000039A BB[22040000]                    mov ebx,message_1
   749 0000039F 9A[00000000]2800                call sys_routine_seg_sel:put_string     ;显示消息
   750                                  
   751                                          ;显示处理器品牌信息 
   752 000003A6 B802000080                      mov eax,0x80000002
   753 000003AB 0FA2                            cpuid
   754 000003AD A3[440D0000]                    mov [cpu_brand + 0x00],eax
   755 000003B2 891D[480D0000]                  mov [cpu_brand + 0x04],ebx
   756 000003B8 890D[4C0D0000]                  mov [cpu_brand + 0x08],ecx
   757 000003BE 8915[500D0000]                  mov [cpu_brand + 0x0c],edx
   758                                  
   759 000003C4 B803000080                      mov eax,0x80000003
   760 000003C9 0FA2                            cpuid
   761 000003CB A3[540D0000]                    mov [cpu_brand + 0x10],eax
   762 000003D0 891D[580D0000]                  mov [cpu_brand + 0x14],ebx
   763 000003D6 890D[5C0D0000]                  mov [cpu_brand + 0x18],ecx
   764 000003DC 8915[600D0000]                  mov [cpu_brand + 0x1c],edx
   765                                  
   766 000003E2 B804000080                      mov eax,0x80000004
   767 000003E7 0FA2                            cpuid
   768 000003E9 A3[640D0000]                    mov [cpu_brand + 0x20],eax
   769 000003EE 891D[680D0000]                  mov [cpu_brand + 0x24],ebx
   770 000003F4 890D[6C0D0000]                  mov [cpu_brand + 0x28],ecx
   771 000003FA 8915[700D0000]                  mov [cpu_brand + 0x2c],edx
   772                                  
   773 00000400 BB[3F0D0000]                    mov ebx,cpu_brnd0                  
   774 00000405 9A[00000000]2800                call sys_routine_seg_sel:put_string
   775 0000040C BB[440D0000]                    mov ebx,cpu_brand
   776 00000411 9A[00000000]2800                call sys_routine_seg_sel:put_string
   777 00000418 BB[780D0000]                    mov ebx,cpu_brnd1
   778 0000041D 9A[00000000]2800                call sys_routine_seg_sel:put_string
   779                                  
   780                                          ;以下开始安装调用门
   781 00000424 BF[0A000000]                    mov edi,salt                            ;符号表起始位置
   782 00000429 B904000000                      mov ecx,salt_items                      ;符号表数量
   783                                      .b3:
   784 0000042E 51                              push ecx                                ;压栈符号表的数量
   785 0000042F 8B8700010000                    mov eax,[edi+256]                       ;该符号入口点的32位偏移地址
   786 00000435 668B9F04010000                  mov bx,[edi+260]                        ;该符号入口点的段选择子
   787 0000043C 66B900EC                        mov cx,1_11_0_1100_000_00000B           ;门属性，P=1,DPL=3。即只有特权级大于等于3的才能调用该门。0个参数，未使用栈传参
   788                                  
   789 00000440 9A[C9010000]2800                call sys_routine_seg_sel:make_gate_descriptor   ;构建调用门描述符
   790 00000447 9A[52010000]2800                call sys_routine_seg_sel:set_up_gdt_descriptor  ;安装调用门描述符，返回ex=段描述符选择子
   791                                  
   792 0000044E 66898F04010000                  mov [edi+260],cx                        ;将返回的门段选择子回填
   793 00000455 81C706010000                    add edi,salt_item_len                   ;指向下一个符号
   794 0000045B 59                              pop ecx
   795 0000045C E2D0                            loop .b3
   796                                  
   797                                          ;对门进行测试
   798 0000045E BB[B2040000]                    mov ebx,message_2
   799 00000463 FF1D[0A010000]                  call far [salt_1+256]                   ;通过门显示信息,间接取得偏移量（会被忽略）与段选择子
   800                                  
   801 00000469 BB[D5040000]                    mov ebx,message_3
   802 0000046E 9A[00000000]2800                call sys_routine_seg_sel:put_string     ;在内核中可以直接调用例程，不使用门调用
   803                                  
   804                                          ;创建任务控制块。这不是处理器要求的，是我们自己定义的链表结构，用来记录任务的状态和信息
   805 00000475 B946000000                      mov ecx,0x46                            ;单个链表项的长度为70字节
   806 0000047A 9A[22010000]2800                call sys_routine_seg_sel:allocate_memory;分配内存，返回ecx=已分配起始内存地址
   807 00000481 E8D2FEFFFF                      call append_to_tcb_link                 ;将当前任务控制块加入到任务控制链表尾部
   808                                  
   809                                          ;加载并重定位用户程序,使用栈传递参数
   810 00000486 6A32                            push dword 50                           ;用户程序所在磁盘扇区
   811 00000488 51                              push ecx                                ;任务控制块的起始地址
   812 00000489 E8B6FBFFFF                      call load_relocate_program              ;加载并重定位用户程序
   813                                  
   814 0000048E BB[F1040000]                    mov ebx,do_status
   815 00000493 9A[00000000]2800                call sys_routine_seg_sel:put_string     ;显示程序加载成功
   816                                  
   817 0000049A B808000000                      mov eax,mem_0_4_gb_seg_sel
   818 0000049F 8ED8                            mov ds,eax
   819                                  
   820 000004A1 0F005918                        ltr [ecx+0x18]                      ;加载任务状态段,存储到TR寄存器
   821 000004A5 0F005110                        lldt [ecx+0x10]                     ;加载LDT，存储到LDTR寄存器
   822                                  
   823 000004A9 8B4144                          mov eax,[ecx+0x44]
   824 000004AC 8ED8                            mov ds,eax                         ;切换到用户程序头部段 
   825                                  
   826                                          ;因为没有办法从高等级特权转移到低等级，只能是假装从调用门返回来模拟
   827                                          ;以下假装从调用门返回。模仿处理器压入返回参数，压入到内核栈
   828 000004AE FF3508000000                    push dword [0x08]                   ;用户程序的栈选择子
   829 000004B4 6A00                            push dword 0                        ;用户程序的esp指针
   830                                  
   831 000004B6 FF3514000000                    push dword [0x14]                  ;用户程序的代码段选择子 
   832 000004BC FF3510000000                    push dword [0x10]                  ;用户程序的的eip
   833                                  
   834 000004C2 CB                              retf                               ;远返回会依次弹出eip、代码段选择子、esp、用户程序的栈选择子，此时eip、esp均指向了用户程序代码，刚好可以指向用户程序的代码
   835                                  ;-----------终止用户程序-----------------------------------------------------------------------
   836                                      return_point:
   837 000004C3 B830000000                      mov eax,core_data_seg_sel          ;因为c14.asm是以JMP的方式使用调 
   838 000004C8 8ED8                            mov ds,eax                         ;用门@TerminateProgram，回到这里时，特权级为3，会导致异常。 
   839                                  
   840 000004CA BB[F9040000]                    mov ebx,message_6
   841 000004CF 9A[00000000]2800                call sys_routine_seg_sel:put_string
   842                                  
   843 000004D6 F4                              hlt
   844                                      core_code_end:
   845                                  ;-----------尾部段-----------------------------------------------------------------------
   846                                  section core_trail
   847                                         core_end:   ;程序结尾标号，因为段没有定义vstart,所以该标号的偏移地址是从程序头开始的
