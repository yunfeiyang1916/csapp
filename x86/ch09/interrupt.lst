     1                                  ;中断演示
     2                                  
     3                                  section header vstart=0             ;用户程序头部段
     4 00000000 [00000000]                  program_length dd program_end   ;[0x00]程序总长度，双字，32位
     5                                      ;用户程序入口点
     6 00000004 [A900]                      code_entry dw start             ;[0x04]偏移地址
     7 00000006 [00000000]                             dd section.code.start;[0x06]段地址
     8                                      
     9 0000000A 0300                        realloc_tbl_len dw (header_end-realloc_begin)/4 ;段重定位表项个数[0x0a]
    10                                      
    11                                      realloc_begin:
    12                                      ;段重定位表           
    13 0000000C [00000000]                      code_segment    dd section.code.start   ;[0x0c]
    14 00000010 [00000000]                      data_segment    dd section.data.start   ;[0x14]
    15 00000014 [00000000]                      stack_segment   dd section.stack.start  ;[0x1c]
    16                                  
    17                                      header_end:                      ;段结束标号 
    18                                  
    19                                  section code align=16 vstart=0      ;代码段，16字节对齐
    20                                  ;----------------------新0x70中断号处理程序---------------------------------------------------------
    21                                      new_int_0x70:
    22 00000000 50                              push ax                         ;保护现场
    23 00000001 53                              push bx
    24 00000002 51                              push cx
    25 00000003 52                              push dx
    26 00000004 06                              push es
    27                                      .w0:
    28 00000005 B00A                            mov al,0x0a                     ;RTC(实时时钟电路)寄存器A索引
    29 00000007 0C80                            or al,0x80                      ;将al最高位置1,用于阻断NMI（非屏蔽中断）。通常是不必要的
    30 00000009 E670                            out 0x70,al                     ;0x70是CMOS RAM索引端口
    31 0000000B E471                            in al,0x71                      ;读寄存器A
    32 0000000D A880                            test al,0x80                    ;测试第7位UIP，根据该值来判断是否需要等待更新周期结束。test等价于and操作，只是不改变al的值
    33 0000000F 75F4                            jnz .w0                         ;以上代码对于更新周期结束中断来说 
    34                                                                          ;是不必要的 
    35 00000011 30C0                            xor al,al                          ;读CMOS 0内存单元
    36 00000013 0C80                            or al,0x80                         ;每次都阻断NMI?
    37 00000015 E670                            out 0x70,al
    38 00000017 E471                            in al,0x71                         ;读RTC当前时间(秒)
    39 00000019 50                              push ax
    40                                  
    41 0000001A B002                            mov al,2
    42 0000001C 0C80                            or al,0x80
    43 0000001E E670                            out 0x70,al
    44 00000020 E471                            in al,0x71                         ;读RTC当前时间(分)
    45 00000022 50                              push ax
    46                                  
    47 00000023 B004                            mov al,4
    48 00000025 0C80                            or al,0x80
    49 00000027 E670                            out 0x70,al
    50 00000029 E471                            in al,0x71                         ;读RTC当前时间(时)
    51 0000002B 50                              push ax
    52                                  
    53 0000002C B007                            mov al,7                
    54 0000002E 0C80                            or al,0x80
    55 00000030 E670                            out 0x70,al
    56 00000032 E471                            in al,0x71
    57 00000034 50                              push ax                            ;读RTC当前时间(日)
    58                                  
    59 00000035 B00C                            mov al,0x0c                        ;寄存器C的索引。且开放NMI 
    60 00000037 E670                            out 0x70,al
    61 00000039 E471                            in al,0x71                         ;读一下RTC的寄存器C，否则只发生一次中断
    62                                                                             ;此处不考虑闹钟和周期性中断的情况 
    63 0000003B B800B8                          mov ax,0xb800
    64 0000003E 8EC0                            mov es,ax                           ;设置显存地址到附加段寄存器
    65                                  
    66 00000040 58                              pop ax                              ;先弹出日期数
    67 00000041 E85500                          call bcd_to_ascii
    68 00000044 BBC807                          mov bx,12*160 + 36*2               ;从屏幕上的12行36列开始显示
    69                                  
    70 00000047 268827                          mov [es:bx],ah
    71 0000004A 26884702                        mov [es:bx+2],al                    ;显示2位日期数
    72                                                         
    73 0000004E 26C647043A                      mov byte [es:bx+4],':'              ;显示分隔符
    74 00000053 26F65705                        not byte [es:bx+5]                  ;反转显示属性
    75                                  
    76 00000057 58                              pop ax
    77 00000058 E83E00                          call bcd_to_ascii
    78 0000005B 26886706                        mov [es:bx+6],ah
    79 0000005F 26884708                        mov [es:bx+8],al                   ;显示两位小时数字
    80                                  
    81 00000063 26C6470A3A                      mov byte [es:bx+10],':'            ;显示分隔符':'
    82 00000068 26F6570B                        not byte [es:bx+11]                ;反转显示属性
    83                                  
    84 0000006C 58                              pop ax
    85 0000006D E82900                          call bcd_to_ascii
    86 00000070 2688670C                        mov [es:bx+12],ah
    87 00000074 2688470E                        mov [es:bx+14],al                  ;显示两位分钟字
    88                                          
    89 00000078 26C647103A                      mov byte [es:bx+16],':'            ;显示分隔符':'
    90 0000007D 26F65711                        not byte [es:bx+17]                ;反转显示属性
    91                                  
    92 00000081 58                              pop ax
    93 00000082 E81400                          call bcd_to_ascii
    94 00000085 26886712                        mov [es:bx+18],ah
    95 00000089 26884714                        mov [es:bx+20],al                  ;显示两位秒数字
    96                                  
    97 0000008D B020                            mov al,0x20                        ;中断结束命令EOI 
    98 0000008F E6A0                            out 0xa0,al                        ;向从片发送 
    99 00000091 E620                            out 0x20,al                        ;向主片发送 
   100                                  
   101 00000093 07                              pop es
   102 00000094 5A                              pop dx
   103 00000095 59                              pop cx
   104 00000096 5B                              pop bx
   105 00000097 58                              pop ax
   106                                  
   107 00000098 CF                              iret                               ;依次从栈中弹出IP、CS、FLAGS内容
   108                                  
   109                                  ;-------------------------------------------------------------------------------
   110                                  bcd_to_ascii:                            ;BCD码转ASCII
   111                                                                           ;输入：AL=bcd码
   112                                                                           ;输出：AX=ascii
   113 00000099 88C4                          mov ah,al                          ;分拆成两个数字 
   114 0000009B 240F                          and al,0x0f                        ;仅保留低4位 
   115 0000009D 0430                          add al,0x30                        ;转换成ASCII 
   116                                  
   117 0000009F C0EC04                        shr ah,4                           ;逻辑右移4位 
   118 000000A2 80E40F                        and ah,0x0f                        
   119 000000A5 80C430                        add ah,0x30
   120                                  
   121 000000A8 C3                            ret
   122                                  
   123                                  ;----------------------程序入口--------------------------------------------------------- 
   124                                      start:
   125                                           ;初识执行时，ds、es均指向头部段
   126 000000A9 A1[1400]                        mov ax,[stack_segment]      ;设置用户程序自己的栈段
   127 000000AC 8ED0                            mov ss,ax
   128 000000AE BC[0001]                        mov sp,ss_pointer           ;初始化栈指针，执行栈最大地址，栈是从高地址向低地址增长的
   129                                  
   130 000000B1 A1[1000]                        mov ax,[data_segment]       ;设置用户程序自己的数据段
   131 000000B4 8ED8                            mov ds,ax
   132                                  
   133 000000B6 BB[0000]                        mov bx,init_msg             ;显示初始化信息
   134 000000B9 E85300                          call put_string
   135                                  
   136 000000BC BB[0E00]                        mov bx,inst_msg             ;显示安装信息
   137 000000BF E84D00                          call put_string
   138                                  
   139 000000C2 B070                            mov al,0x70                 ;0x70中断号
   140 000000C4 B304                            mov bl,4                    
   141 000000C6 F6E3                            mul bl                      ;计算0x70号中断在中断向量表中的偏移
   142 000000C8 89C3                            mov bx,ax
   143                                  
   144 000000CA FA                              cli                         ;清除IF中断标志位，此时不在接受其他中断
   145                                  
   146 000000CB 06                              push es                     ;保存es
   147 000000CC B80000                          mov ax,0x0000
   148 000000CF 8EC0                            mov es,ax
   149 000000D1 26C707[0000]                    mov word [es:bx],new_int_0x70   ;中断处理程序偏移地址
   150 000000D6 268C4F02                        mov word [es:bx+2],cs           ;段地址
   151                                  
   152 000000DA 07                              pop es                          ;恢复es
   153                                  
   154                                          ;以下设置时钟更新结束中断，每秒更新一次
   155 000000DB B00B                            mov al,0x0b                     ;RTC(实时时钟电路)寄存器B索引
   156 000000DD 0C80                            or al,0x80                      ;将al最高位置1,用于阻断NMI（非屏蔽中断）
   157 000000DF E670                            out 0x70,al                     ;0x70是CMOS RAM索引端口
   158 000000E1 B012                            mov al,0x12                     ;二进制形式为00010010，设置寄存器B，禁止周期性中断，开放更新结束后中断，BCD码，24小时制 
   159 000000E3 E671                            out 0x71,al                     ;0x71是数据端口
   160                                  
   161 000000E5 B00C                            mov al,0x0c
   162 000000E7 E670                            out 0x70,al
   163 000000E9 E471                            in al,0x71                      ;读RTC寄存器C，复位未决的中断状态
   164                                  
   165 000000EB E4A1                            in al,0xa1                         ;读8259从片的IMR寄存器 
   166 000000ED 24FE                            and al,0xfe                        ;清除bit 0(此位连接RTC)
   167 000000EF E6A1                            out 0xa1,al                        ;写回此寄存器 
   168                                  
   169 000000F1 FB                              sti                                ;设置IF中断标志位，重新开放中断
   170                                  
   171 000000F2 BB[3000]                        mov bx,done_msg                    ;显示安装完成信息
   172 000000F5 E81700                          call put_string
   173                                  
   174 000000F8 BB[3800]                        mov bx,tips_msg                    ;显示提示信息
   175 000000FB E81100                          call put_string
   176                                  
   177 000000FE B900B8                          mov cx,0xb800
   178 00000101 8ED9                            mov ds,cx                           ;设置数据段寄存器为显示地址
   179 00000103 C606C20740                      mov byte [12*160 + 33*2],'@'        ;在屏幕的第12行，35列显示，屏幕中心
   180                                  
   181                                      .idle:
   182 00000108 F4                              hlt                                 ;使CPU进入低功耗状态，直到用中断唤醒
   183 00000109 F616C307                        not byte [12*160 + 33*2+1]          ;反转显示属性 
   184 0000010D EBF9                            jmp .idle
   185                                  ;-----------------------显示文本--------------------------------------------------------
   186                                      put_string:             ;显示以0结尾的字符串，输入ds:bx字符串地址
   187 0000010F 8A0F                            mov cl,[bx]
   188 00000111 08C9                            or cl,cl            ;cl是否为0，如果为0 or指令会使ZF标志位改变
   189 00000113 7406                            jz .exit
   190 00000115 E80400                          call put_char
   191 00000118 43                              inc bx              ;访问下一个字符
   192 00000119 EBF4                            jmp put_string
   193                                      
   194                                      .exit:
   195 0000011B C3                              ret             ;返回
   196                                  
   197                                      put_char:               ;显示1个字符,输入cl=ascii
   198 0000011C 50                              push ax             ;保存用到的寄存器
   199 0000011D 53                              push bx
   200 0000011E 51                              push cx
   201 0000011F 52                              push dx
   202 00000120 1E                              push ds
   203 00000121 06                              push es
   204                                  
   205                                          ;以下取光标位置
   206 00000122 BAD403                          mov dx,0x3d4        ;显卡索引寄存器端口号
   207 00000125 B00E                            mov al,0x0e         ;光标的高8位寄存器索引值
   208 00000127 EE                              out dx,al           ;写入索引值
   209 00000128 BAD503                          mov dx,0x3d5        ;显卡数据端口
   210 0000012B EC                              in al,dx            ;读取光标高8位寄存器的值
   211 0000012C 88C4                            mov ah,al           ;高8位放到ah中
   212                                  
   213 0000012E BAD403                          mov dx,0x3d4        
   214 00000131 B00F                            mov al,0x0f         ;光标的低8位寄存器索引值
   215 00000133 EE                              out dx,al
   216 00000134 BAD503                          mov dx,0x3d5
   217 00000137 EC                              in al,dx            ;读取光标低8位寄存器值
   218 00000138 89C3                            mov bx,ax           ;将光标位置放到bx寄存器上
   219                                  
   220 0000013A 80F90D                          cmp cl,0x0d         ;是否是回车符
   221 0000013D 750C                            jnz .put_0a         ;如果非回车符则去判断是否是换行符
   222 0000013F 89D8                            mov ax,bx           ;是回车符，需要将光标移动到行首
   223 00000141 B350                            mov bl,80           ;显示器每行显示80个字符，将80设置为除数
   224 00000143 F6F3                            div bl              ;ax/bl,商在al,余数在ah,商就是当前行的行数
   225 00000145 F6E3                            mul bl              ;al*bl=ax,乘以80就是当前行首的光标数值,放在ax寄存器上
   226 00000147 89C3                            mov bx,ax           ;光标位置值放到bx寄存器
   227 00000149 EB45                            jmp .set_cursor     ;设置光标位置
   228                                  
   229                                      .put_0a:                ;判断是否是换行符
   230 0000014B 80F90A                          cmp cl,0x0a
   231 0000014E 7505                            jnz .put_other      ;非换行符则需要显示正常字符
   232 00000150 83C350                          add bx,80           ;是换行符，光标位置增加80即可
   233 00000153 EB0F                            jmp .roll_screen
   234                                  
   235                                  
   236                                      .put_other:             ;显示正常字符
   237 00000155 B800B8                          mov ax,0xb800        ;显卡内存地址
   238 00000158 8EC0                            mov es,ax           ;设置附加段基址，就是显存起始地址
   239 0000015A D1E3                            shl bx,1            ;光标位置左移1位，就是乘以2，因为在显示器中显示字符会有2个字节，一个是字符属性，一个是字符本身
   240 0000015C 26880F                          mov [es:bx],cl      ;显示字符，字符属性默认是黑底白字，所以不需要写字符属性了
   241                                          
   242                                          ;以下将光标位置推进一个字符，bx刚才左移1位，右移还原回来在+1
   243 0000015F D1EB                            shr bx,1
   244 00000161 83C301                          add bx,1
   245                                      .roll_screen:           ;判断是否需要滚屏
   246 00000164 81FBD007                        cmp bx,2000         ;一屏最多显示2000字符，判断光标位置是否超出一屏
   247 00000168 7C26                            jl .set_cursor      ;不超过一屏则去设置光标位置
   248                                  
   249 0000016A B800B8                          mov ax,0xb800       ;显存地址，滚屏就是将屏幕第2-25行内容上移，然后最后一行使用黑底白字的空白符填充
   250 0000016D 8ED8                            mov ds,ax
   251 0000016F 8EC0                            mov es,ax           ;设置数据段与附加段都为显存起始地址
   252                                          ;段之间批量传送数据
   253 00000171 FC                              cld                 ;将方向标志位DF清零,以指示传送是正方向的
   254 00000172 BEA000                          mov si,0xa0         ;源区域从显存第二行第一列，十进制160（80个字符属性+80个字符）
   255 00000175 BF0000                          mov di,0x00         ;目标区域从显存第一行第一列
   256 00000178 B98007                          mov cx,1920         ;要传送的字数
   257 0000017B F3A5                            rep movsw           ;如果cx的值不为0，则重复传送，每次传送完cx的值都递减
   258 0000017D BB000F                          mov bx,3840         ;清除屏幕最后一行
   259 00000180 B95000                          mov cx,80
   260                                  
   261                                      .cls:
   262 00000183 26C7072007                      mov word[es:bx],0x0720 ;空白字符填充
   263 00000188 83C302                          add bx,2
   264 0000018B E2F6                            loop .cls
   265                                  
   266 0000018D BB8007                          mov bx,1920 ;将光标位置设置到倒数第二行
   267                                  
   268                                      .set_cursor:            ;设置光标在屏幕上的位置
   269 00000190 BAD403                          mov dx,0x3d4        ;显示索引寄存器端口号
   270 00000193 B00E                            mov al,0x0e         ;光标高8位寄存器索引值
   271 00000195 EE                              out dx,al           ;写入索引值
   272 00000196 BAD503                          mov dx,0x3d5        ;显示数据端口
   273 00000199 88F8                            mov al,bh
   274 0000019B EE                              out dx,al           ;写入光标高8位寄存器的值
   275                                  
   276 0000019C BAD403                          mov dx,0x3d4        ;显示索引寄存器端口号
   277 0000019F B00F                            mov al,0x0f         ;光标低8位寄存器索引值
   278 000001A1 EE                              out dx,al           ;写入索引值
   279 000001A2 BAD503                          mov dx,0x3d5        ;显示数据端口
   280 000001A5 88D8                            mov al,bl
   281 000001A7 EE                              out dx,al           ;写入光标低8位寄存器的值
   282                                  
   283 000001A8 07                              pop es              ;出栈，恢复相关寄存器的原始值
   284 000001A9 1F                              pop ds
   285 000001AA 5A                              pop dx
   286 000001AB 59                              pop cx
   287 000001AC 5B                              pop bx
   288 000001AD 58                              pop ax
   289                                  
   290 000001AE C3                              ret
   291                                  section data align=16 vstart=0      ;数据段，16字节对齐
   292 00000000 5374617274696E672E-         init_msg       db 'Starting...',0x0d,0x0a,0             ;启动提示信息          
   292 00000009 2E2E0D0A00         
   293 0000000E 496E7374616C6C696E-         inst_msg       db 'Installing a new interrupt 70H...',0 ;安装中断号提示信息
   293 00000017 672061206E65772069-
   293 00000020 6E7465727275707420-
   293 00000029 3730482E2E2E00     
   294 00000030 446F6E652E0D0A00            done_msg       db 'Done.',0x0d,0x0a,0                   ;安装完成提示信息
   295 00000038 436C6F636B20697320-         tips_msg       db 'Clock is now working.',0 
   295 00000041 6E6F7720776F726B69-
   295 0000004A 6E672E00           
   296                                  section stack align=16 vstart=0     ;栈段，16字节对齐
   297 00000000 <res 100h>                  resb 256                        ;保留256字节栈空间，但不初始化它们的值
   297          ******************       warning: uninitialized space declared in stack section: zeroing [-w+zeroing]
   298                                      ss_pointer:                      ;栈段结束标号，偏移量为256
   299                                  section trail align=16
   300                                      program_end:                    ;程序结尾标号，因为段没有定义vstart,所以该标号的偏移地址是从程序头开始的
