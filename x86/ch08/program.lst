     1                                  ;用户程序
     2                                  
     3                                  section header vstart=0                 ;用户程序头部段
     4 00000000 [00000000]                  program_length dd program_end    ;[0x00]程序总长度，双字，32位
     5                                      ;用户程序入口点
     6 00000004 [0000]                      code_entry  dw start                ;[0x04]偏移地址
     7 00000006 [00000000]                              dd section.code_1.start ;[0x06]段地址
     8                                  
     9 0000000A 0500                        realloc_tbl_len dw (header_end-code_1_segment)/4    ;[0x0a]段重定位表项个数,因为每个表项占用4个字节，所以需要除以4
    10                                      ;段重定位表
    11 0000000C [00000000]                  code_1_segment dd section.code_1.start  ;[0x0c],代码段1汇编地址（不是偏移地址，其中低20位为汇编地址），4字节
    12 00000010 [00000000]                  code_2_segment dd section.code_2.start  ;[0x10],代码段2汇编地址，4字节
    13 00000014 [00000000]                  data_1_segment dd section.data_1.start  ;[0x14],数据段1汇编地址，4字节
    14 00000018 [00000000]                  data_2_segment dd section.data_2.start  ;[0x18],数据段2汇编地址，4字节
    15 0000001C [00000000]                  stack_segment dd section.stack.start    ;[0x1c],栈段汇编地址，4字节
    16                                  
    17                                      header_end:                         ;段结束标号
    18                                  
    19                                  section code_1 align=16 vstart=0     ;代码段1,16字节对齐
    20                                   ;程序入口
    21                                      start:
    22                                          ;初识执行时，ds、es均指向头部段
    23 00000000 A1[1C00]                        mov ax,[stack_segment]      ;设置用户程序自己的栈段
    24 00000003 8ED0                            mov ss,ax
    25 00000005 BC[0001]                        mov sp,stack_end            ;初始化栈指针，执行栈最大地址，栈是从高地址向低地址增长的
    26                                  
    27 00000008 A1[1400]                        mov ax,[data_1_segment]     ;设置用户程序自己的数据段
    28 0000000B 8ED8                            mov ds,ax
    29                                  
    30 0000000D BB[0000]                        mov bx,msg0                 ;显示第一段字符串
    31 00000010 E80A00                          call put_string
    32                                  
    33 00000013 26FF36[1000]                    push word [es:code_2_segment]   ;将代码段2的段地址压入栈中
    34 00000018 B8[0000]                        mov ax,begin                ;8086不支持直接压栈立即数，80386之后可以直接使用push begin
    35 0000001B 50                              push ax                     ;将代码段2的偏移地址压入栈中
    36 0000001C CB                              retf                        ;远返回指令会先从栈中弹出ip值，然后再弹出cs代码段寄存器值，此时相当于跳转到代码段2执行
    37                                  ;-------------------------------------------------------------------------------
    38                                      put_string:             ;显示以0结尾的字符串，输入ds:bx字符串地址
    39 0000001D 8A0F                            mov cl,[bx]
    40 0000001F 08C9                            or cl,cl            ;cl是否为0，如果为0 or指令会使ZF标志位改变
    41 00000021 7406                            jz .exit
    42 00000023 E80400                          call put_char
    43 00000026 43                              inc bx              ;访问下一个字符
    44 00000027 EBF4                            jmp put_string
    45                                      
    46                                      .exit:
    47 00000029 C3                              ret             ;返回
    48                                  
    49                                      put_char:               ;显示1个字符,输入cl=ascii
    50 0000002A 50                              push ax             ;保存用到的寄存器
    51 0000002B 53                              push bx
    52 0000002C 51                              push cx
    53 0000002D 52                              push dx
    54 0000002E 1E                              push ds
    55 0000002F 06                              push es
    56                                  
    57                                          ;以下取光标位置
    58 00000030 BAD403                          mov dx,0x3d4        ;显卡索引寄存器端口号
    59 00000033 B00E                            mov al,0x0e         ;光标的高8位寄存器索引值
    60 00000035 EE                              out dx,al           ;写入索引值
    61 00000036 BAD503                          mov dx,0x3d5        ;显卡数据端口
    62 00000039 EC                              in al,dx            ;读取光标高8位寄存器的值
    63 0000003A 88C4                            mov ah,al           ;高8位放到ah中
    64                                  
    65 0000003C BAD403                          mov dx,0x3d4        
    66 0000003F B00F                            mov al,0x0f         ;光标的低8位寄存器索引值
    67 00000041 EE                              out dx,al
    68 00000042 BAD503                          mov dx,0x3d5
    69 00000045 EC                              in al,dx            ;读取光标低8位寄存器值
    70 00000046 89C3                            mov bx,ax           ;将光标位置放到bx寄存器上
    71                                  
    72 00000048 80F90D                          cmp cl,0x0d         ;是否是回车符
    73 0000004B 750C                            jnz .put_0a         ;如果非回车符则去判断是否是换行符
    74 0000004D 89D8                            mov ax,bx           ;是回车符，需要将光标移动到行首
    75 0000004F B350                            mov bl,80           ;显示器每行显示80个字符，将80设置为除数
    76 00000051 F6F3                            div bl              ;ax/bl,商在al,余数在ah,商就是当前行的行数
    77 00000053 F6E3                            mul bl              ;al*bl=ax,乘以80就是当前行首的光标数值,放在ax寄存器上
    78 00000055 89C3                            mov bx,ax           ;光标位置值放到bx寄存器
    79 00000057 EB45                            jmp .set_cursor     ;设置光标位置
    80                                  
    81                                      .put_0a:                ;判断是否是换行符
    82 00000059 80F90A                          cmp cl,0x0a
    83 0000005C 7505                            jnz .put_other      ;非换行符则需要显示正常字符
    84 0000005E 83C350                          add bx,80           ;是换行符，光标位置增加80即可
    85 00000061 EB0F                            jmp .roll_screen
    86                                  
    87                                  
    88                                      .put_other:             ;显示正常字符
    89 00000063 B800B8                          mov ax,0xb800        ;显卡内存地址
    90 00000066 8EC0                            mov es,ax           ;设置附加段基址，就是显存起始地址
    91 00000068 D1E3                            shl bx,1            ;光标位置左移1位，就是乘以2，因为在显示器中显示字符会有2个字节，一个是字符属性，一个是字符本身
    92 0000006A 26880F                          mov [es:bx],cl      ;显示字符，字符属性默认是黑底白字，所以不需要写字符属性了
    93                                          
    94                                          ;以下将光标位置推进一个字符，bx刚才左移1位，右移还原回来在+1
    95 0000006D D1EB                            shr bx,1
    96 0000006F 83C301                          add bx,1
    97                                      .roll_screen:           ;判断是否需要滚屏
    98 00000072 81FBD007                        cmp bx,2000         ;一屏最多显示2000字符，判断光标位置是否超出一屏
    99 00000076 7C26                            jl .set_cursor      ;不超过一屏则去设置光标位置
   100                                  
   101 00000078 B800B8                          mov ax,0xb800       ;显存地址，滚屏就是将屏幕第2-25行内容上移，然后最后一行使用黑底白字的空白符填充
   102 0000007B 8ED8                            mov ds,ax
   103 0000007D 8EC0                            mov es,ax           ;设置数据段与附加段都为显存起始地址
   104                                          ;段之间批量传送数据
   105 0000007F FC                              cld                 ;将方向标志位DF清零,以指示传送是正方向的
   106 00000080 BEA000                          mov si,0xa0         ;源区域从显存第二行第一列，十进制160（80个字符属性+80个字符）
   107 00000083 BF0000                          mov di,0x00         ;目标区域从显存第一行第一列
   108 00000086 B98007                          mov cx,1920         ;要传送的字数
   109 00000089 F3A5                            rep movsw           ;如果cx的值不为0，则重复传送，每次传送完cx的值都递减
   110 0000008B BB000F                          mov bx,3840         ;清除屏幕最后一行
   111 0000008E B95000                          mov cx,80
   112                                  
   113                                      .cls:
   114 00000091 26C7072007                      mov word[es:bx],0x0720 ;空白字符填充
   115 00000096 83C302                          add bx,2
   116 00000099 E2F6                            loop .cls
   117                                  
   118 0000009B BB8007                          mov bx,1920 ;将光标位置设置到倒数第二行
   119                                  
   120                                      .set_cursor:            ;设置光标在屏幕上的位置
   121 0000009E BAD403                          mov dx,0x3d4        ;显示索引寄存器端口号
   122 000000A1 B00E                            mov al,0x0e         ;光标高8位寄存器索引值
   123 000000A3 EE                              out dx,al           ;写入索引值
   124 000000A4 BAD503                          mov dx,0x3d5        ;显示数据端口
   125 000000A7 88F8                            mov al,bh
   126 000000A9 EE                              out dx,al           ;写入光标高8位寄存器的值
   127                                  
   128 000000AA BAD403                          mov dx,0x3d4        ;显示索引寄存器端口号
   129 000000AD B00F                            mov al,0x0f         ;光标低8位寄存器索引值
   130 000000AF EE                              out dx,al           ;写入索引值
   131 000000B0 BAD503                          mov dx,0x3d5        ;显示数据端口
   132 000000B3 88D8                            mov al,bl
   133 000000B5 EE                              out dx,al           ;写入光标低8位寄存器的值
   134                                  
   135 000000B6 07                              pop es              ;出栈，恢复相关寄存器的原始值
   136 000000B7 1F                              pop ds
   137 000000B8 5A                              pop dx
   138 000000B9 59                              pop cx
   139 000000BA 5B                              pop bx
   140 000000BB 58                              pop ax
   141                                  
   142 000000BC C3                              ret
   143                                  
   144                                  ;------------------------------------------------------------------------------- 
   145                                     
   146                                  
   147                                      ;继续执行
   148                                      continue:
   149 000000BD 26A1[1800]                      mov ax,[es:data_2_segment]  ;将数据段2地址设置到ds中
   150 000000C1 8ED8                            mov ds,ax
   151                                          
   152 000000C3 BB[0000]                        mov bx,msg1
   153 000000C6 E854FF                          call put_string             ;显示第二段信息
   154                                  
   155 000000C9 EBFE                            jmp $
   156                                  
   157                                  section code_2 align=16 vstart=0    ;代码段2,16字节对齐,啥也没干，又调回到了代码段1中继续执行
   158                                      begin:
   159 00000000 26FF36[0C00]                    push word [es:code_1_segment]   ;将代码段1的段地址压入栈中
   160 00000005 B8[BD00]                        mov ax,continue             ;8086不支持直接压栈立即数，80386之后可以直接使用push begin
   161 00000008 50                              push ax                     ;将代码段2的偏移地址压入栈中
   162 00000009 CB                              retf                        ;远返回指令会先从栈中弹出ip值，然后再弹出cs代码段寄存器值，此时相当于跳转到代码段1执行
   163                                  
   164                                  section data_1 align=16 vstart=0    ;数据段1,16字节对齐
   165                                      ;定义一段要显示的文本
   166 00000000 202054686973206973-         msg0 db '  This is NASM - the famous Netwide Assembler. '
   166 00000009 204E41534D202D2074-
   166 00000012 68652066616D6F7573-
   166 0000001B 204E65747769646520-
   166 00000024 417373656D626C6572-
   166 0000002D 2E20               
   167 0000002F 4261636B2061742053-              db 'Back at SourceForge and in intensive development! '
   167 00000038 6F75726365466F7267-
   167 00000041 6520616E6420696E20-
   167 0000004A 696E74656E73697665-
   167 00000053 20646576656C6F706D-
   167 0000005C 656E742120         
   168 00000061 476574207468652063-              db 'Get the current versions from http://www.nasm.us/.'
   168 0000006A 757272656E74207665-
   168 00000073 7273696F6E73206672-
   168 0000007C 6F6D20687474703A2F-
   168 00000085 2F7777772E6E61736D-
   168 0000008E 2E75732F2E         
   169 00000093 0D0A0D0A                         db 0x0d,0x0a,0x0d,0x0a
   170 00000097 20204578616D706C65-              db '  Example code for calculate 1+2+...+1000:',0x0d,0x0a,0x0d,0x0a
   170 000000A0 20636F646520666F72-
   170 000000A9 2063616C63756C6174-
   170 000000B2 6520312B322B2E2E2E-
   170 000000BB 2B313030303A0D0A0D-
   170 000000C4 0A                 
   171 000000C5 2020202020786F7220-              db '     xor dx,dx',0x0d,0x0a
   171 000000CE 64782C64780D0A     
   172 000000D5 2020202020786F7220-              db '     xor ax,ax',0x0d,0x0a
   172 000000DE 61782C61780D0A     
   173 000000E5 2020202020786F7220-              db '     xor cx,cx',0x0d,0x0a
   173 000000EE 63782C63780D0A     
   174 000000F5 202040403A0D0A                   db '  @@:',0x0d,0x0a
   175 000000FC 2020202020696E6320-              db '     inc cx',0x0d,0x0a
   175 00000105 63780D0A           
   176 00000109 202020202061646420-              db '     add ax,cx',0x0d,0x0a
   176 00000112 61782C63780D0A     
   177 00000119 202020202061646320-              db '     adc dx,0',0x0d,0x0a
   177 00000122 64782C300D0A       
   178 00000128 2020202020696E6320-              db '     inc cx',0x0d,0x0a
   178 00000131 63780D0A           
   179 00000135 2020202020636D7020-              db '     cmp cx,1000',0x0d,0x0a
   179 0000013E 63782C313030300D0A 
   180 00000147 20202020206A6C6520-              db '     jle @@',0x0d,0x0a
   180 00000150 40400D0A           
   181 00000154 20202020202E2E2E20-              db '     ... ...(Some other codes)',0x0d,0x0a,0x0d,0x0a
   181 0000015D 2E2E2E28536F6D6520-
   181 00000166 6F7468657220636F64-
   181 0000016F 6573290D0A0D0A     
   182 00000176 00                               db 0
   183                                  
   184                                  section data_2 align=16 vstart=0    ;数据段2,16字节对齐
   185                                      ;数据段2中要显示的文本
   186 00000000 20205468652061626F-          msg1 db '  The above contents is written by yunfeiyang. '
   186 00000009 766520636F6E74656E-
   186 00000012 747320697320777269-
   186 0000001B 7474656E2062792079-
   186 00000024 756E66656979616E67-
   186 0000002D 2E20               
   187 0000002F 323032312D30382D31-              db '2021-08-16'
   187 00000038 36                 
   188 00000039 00                               db 0
   189                                  
   190                                  section stack align=16 vstart=0     ;栈段，16字节对齐
   191 00000000 <res 100h>                  resb 256                        ;保留256字节栈空间，但不初始化它们的值
   191          ******************       warning: uninitialized space declared in stack section: zeroing [-w+zeroing]
   192                                      stack_end:                      ;栈段结束标号，偏移量为256
   193                                  
   194                                  section trail align=16
   195                                      program_end:                    ;程序结尾标号，因为段没有定义vstart,所以该标号的偏移地址是从程序头开始的
   196                                  
