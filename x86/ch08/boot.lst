     1                                  ;硬盘主引导扇区代码
     2                                  ;加载器
     3                                  
     4                                  app_lba_start equ 100   ;声明常数（用户程序起始逻辑扇区号,要加载的用户程序所在的磁盘位置）
     5                                                          ;常数的声明不会占用汇编地址
     6                                  ;-------------------------------------------------------------------------------
     7                                  section mbr align=16 vstart=0x7c00 ;主段落，偏移起始地址为0x7c00
     8                                      ;设置栈段和栈指针都为0，栈指针将在0xffff-0x0000之间变化，栈段的长度就是64k
     9 00000000 B80000                      mov ax,0
    10 00000003 8ED0                        mov ss,ax
    11 00000005 89C4                        mov sp,ax
    12                                  
    13 00000007 2EA1[C700]                  mov ax,[cs:phy_base]        ;计算用于加载用户程序的逻辑段地址，这里使用cs段是因为ds和es段有其他用处
    14 0000000B 2E8B16[C900]                mov dx,[cs:phy_base+2]      ;地址是20位的，16位寄存器放不下，所以使用两个寄存器来表示，高16位在dx，低16位在ax
    15 00000010 BB1000                      mov bx,16                   ;将32位物理地址变成16位段地址，该物理地址是16位对齐的，直接右移4位即可
    16 00000013 F7F3                        div bx                      ;ax中的商就是段地址
    17 00000015 8ED8                        mov ds,ax                   ;ds与es均设置该段地址
    18 00000017 8EC0                        mov es,ax
    19                                  
    20                                      ;以下读取程序的起始部分
    21 00000019 31FF                        xor di,di                   
    22 0000001B BE6400                      mov si,app_lba_start        ;用户程序在磁盘上的逻辑扇区号，值为100，si完全可以放的下，所以将di清零
    23 0000001E 31DB                        xor bx,bx                   ;加载到ds:0x0000处
    24 00000020 E85100                      call read_hard_disk_0
    25                                  
    26                                      ;已经读取到程序的头部了，现在判断程序的总大小
    27 00000023 8B160200                    mov dx,[2]                  ;程序大小的高16位
    28 00000027 A10000                      mov ax,[0]                  ;程序大小的低16位
    29 0000002A BB0002                      mov bx,512                  ;每扇区512字节
    30 0000002D F7F3                        div bx                      ;计算该程序占多数个扇区
    31 0000002F 83FA00                      cmp dx,0                    ;余数是否为0
    32 00000032 7501                        jnz @1                      ;未除尽，表示还有一个扇区需要读，不需要去减去一个扇区了，直接跳转到@1
    33 00000034 48                          dec ax                      ;已经读取过头扇区了，所以需要减去一个
    34                                  
    35                                      @1:
    36 00000035 83F800                          cmp ax,0                ;商为0表示程序的大小刚好小于等于512字节
    37 00000038 7413                            jz direct
    38                                          ;读取剩余扇区
    39 0000003A 1E                              push ds                 ;保存ds段寄存器，后面会改变ds段
    40 0000003B 89C1                            mov cx,ax               ;循环次数（剩余扇区数）
    41                                  
    42                                      @2:
    43 0000003D 8CD8                            mov ax,ds               ;每次读取一个扇区都初始化ds段寄存器，因为每个扇区512字节，也就是0x200,段偏移地址需要左移4位，也就是0x20
    44 0000003F 83C020                          add ax,0x20             ;ds加上0x20，表示已经读取了512字节
    45 00000042 8ED8                            mov ds,ax
    46                                  
    47 00000044 31DB                            xor bx,bx               ;每次读取时，偏移地址始终为0x0000
    48 00000046 46                              inc si                  ;下一个逻辑扇区
    49 00000047 E82A00                          call read_hard_disk_0   ;从磁盘读取
    50 0000004A E2F1                            loop @2                 ;先将cx值减一，如果cx的值不为0，则执行循环，否则向下继续执行
    51                                  
    52 0000004C 1F                              pop ds                  ;恢复ds段寄存器原始值,此时ds的值为用户程序的起始地址
    53                                      ;计算入口点代码段基址
    54                                      direct:
    55 0000004D 8B160800                        mov dx,[0x08]           ;入口点段地址高16位
    56 00000051 A10600                          mov ax,[0x06]           ;入口点段地址低16位
    57 00000054 E85700                          call calc_segment_base  ;计算16位段地址
    58                                  
    59 00000057 A30600                          mov [0x06],ax           ;回填真正的代码入口点代码段地址
    60                                  
    61                                          ;开始处理段重定位表
    62 0000005A 8B0E0A00                        mov cx,[0x0a]           ;段重定位表项个数
    63 0000005E BB0C00                          mov bx,0x0c             ;重定位表首地址
    64                                      ;重定位表项中的段基址    
    65                                      realloc:
    66 00000061 8B5702                          mov dx,[bx+0x02]        ;32位地址的高16位
    67 00000064 8B07                            mov ax,[bx]             ;低16位
    68 00000066 E84500                          call calc_segment_base  ;计算16位段地址
    69                                          
    70 00000069 8907                            mov [bx],ax             ;回填段的基址
    71 0000006B 83C304                          add bx,4                ;下一个重定位表项（每项占4个字节）
    72 0000006E E2F1                            loop realloc            ;先将cx值减一，如果cx的值不为0，则执行循环，否则向下继续执行
    73                                  
    74 00000070 FF2E0400                    jmp far [0x04]              ;转移到用户程序
    75                                  
    76                                  ;-------------------------------------------------------------------------------
    77                                  read_hard_disk_0:               ;从硬盘读取一个逻辑扇区，使用的逻辑扇区编址方法为LBA28，也就是用28位来表示扇区号，每个扇区512字节
    78                                                                  ;di:si=起始逻辑扇区号，28位只能用2个16位寄存器来表示，其中di中的高4位清零，剩余12位表示高12位，si表示低16位
    79                                                                  ;ds:bx=目标缓冲区地址，将读到的硬盘数据放到ds段指定的内存中
    80                                  
    81 00000074 50                          push ax                     ;将该过程会用到的寄存器入栈保存，函数返回时需要出栈还原
    82 00000075 53                          push bx
    83 00000076 51                          push cx
    84 00000077 52                          push dx
    85                                  
    86 00000078 BAF201                      mov dx,0x1f2                ;0x1f2端口表示要读取或写入的扇区数量，8位长度
    87 0000007B B001                        mov al,1                    ;每次要读取1个扇区
    88 0000007D EE                          out dx,al
    89                                  
    90                                      ;28位的扇区号太长，需要放到4个8位端口中，0x1f3存0-7位，0x1f4存8-15位，0x1f5存16-23位，
    91                                      ;0x1f6低4位存24-27位，第4位用于指示硬盘号，0是主盘、1是从盘,高三为全为1，表示LBA模式
    92 0000007E 42                          inc dx                      ;0x1f3
    93 0000007F 89F0                        mov ax,si
    94 00000081 EE                          out dx,al                   ;LBA地址7-0
    95                                  
    96 00000082 42                          inc dx                      ;0x1f4
    97 00000083 88E0                        mov al,ah
    98 00000085 EE                          out dx,al                   ;LBA地址15-8
    99                                  
   100 00000086 42                          inc dx                      ;0x1f5
   101 00000087 89F8                        mov ax,di
   102 00000089 EE                          out dx,al                   ;LBA地址23-16
   103                                  
   104 0000008A 42                          inc dx                      ;0x1f6
   105 0000008B B0E0                        mov al,0xe0                 ;LBA28模式，使用主盘  二进制值1110 0000
   106 0000008D 08E0                        or al,ah                    ;因为al是1110 0000，ah高4位是0，0000 xxxx,使用or运算后al就是xxxx,表示LBA地址27-24
   107 0000008F EE                          out dx,al
   108                                  
   109 00000090 42                          inc dx                      ;0x1f7，既是命令端口也是状态端口，0x20表示读，0x30表示写
   110 00000091 B020                        mov al,0x20                 ;表示读硬盘
   111 00000093 EE                          out dx,al                  
   112                                  
   113                                      .waits:
   114 00000094 EC                              in al,dx                    ;读取硬盘状态，第7位是1表示硬盘在忙碌，第3位是1表示已经读取完可以传输数据了
   115 00000095 2488                            and al,0x88                 ;二进制值：1000 1000，保留第7位与第3位的值，其他位全清0
   116 00000097 3C08                            cmp al,0x08                 ;二进制值：0000 1000，是否已经准备好了
   117 00000099 75F9                            jnz .waits                  ;尚未准备好，继续循环等待
   118                                  
   119 0000009B B90001                      mov cx,256                  ;总共要读取的字数
   120 0000009E BAF001                      mov dx,0x1f0                ;硬盘数据端口，长度为16位的
   121                                  
   122                                      .readw:
   123 000000A1 ED                              in ax,dx                    ;从硬盘读取一个字
   124 000000A2 8907                            mov [bx],ax                 ;放到ds段内存中
   125 000000A4 83C302                          add bx,2                    ;bx偏移地址+2
   126 000000A7 E2F8                            loop .readw                 ;先将cx值减一，如果cx的值不为0，则执行循环，否则向下继续执行
   127                                  
   128 000000A9 5A                          pop dx                      ;出栈，还原相关寄存器的原始值
   129 000000AA 59                          pop cx
   130 000000AB 5B                          pop bx
   131 000000AC 58                          pop ax
   132                                  
   133 000000AD C3                          ret                         ;返回
   134                                  
   135                                  
   136                                  
   137                                  
   138                                  ;-------------------------------------------------------------------------------
   139                                  calc_segment_base:              ;计算16位段地址，输入dx:ax=32位物理地址，输出ax=16位段基址
   140 000000AE 52                          push dx                     ;保存dx寄存器中的值
   141                                  
   142 000000AF 2E0306[C700]                add ax,[cs:phy_base]        ;如果有进位则CF位的值为1
   143 000000B4 2E1316[C900]                adc dx,[cs:phy_base+0x02]   ;adc是进位加法，两数相加后再加上标志寄存器CF位的值（0或1）
   144                                                                  ;这样分两步就完成了32位的加法
   145                                                                  ;dx:ax存放的是32位物理地址，而只有20位有效，高4位在dx中，低16位在ax
   146 000000B9 C1E804                      shr ax,4                    ;ax右移4位(因为是求段地址)，空出高4位
   147 000000BC C1CA04                      ror dx,4                    ;dx循环右移4位，循环右移会将右移出的位放到左边。这样dx中高4位的值就是原先低4位的值
   148 000000BF 81E200F0                    and dx,0xf000               ;将dx低12位清零
   149 000000C3 09D0                        or ax,dx                    ;将dx高4位与ax合并
   150                                  
   151 000000C5 5A                          pop dx                      ;还原dx中的值
   152 000000C6 C3                          ret
   153                                  
   154                                  ;-------------------------------------------------------------------------------
   155 000000C7 00000100                phy_base dd 0x10000     ;用户程序被加载的物理起始地址,用32位长度来表示20的地址
   156                                  
   157 000000CB 00<rep 133h>            times 510-($-$$)  db  0 ;剩余的字节数用0填充，'$$'表示当前段的起始地址，'$-$$'正好是当前程序的字节大小
   158 000001FE 55AA                                      db  0x55,0xaa ;引导扇区结束标识
