     1                                  ;保护模式微型内核程序 
     2                                  
     3                                  ;以下常量定义部分。内核的大部分内容都应当固定 
     4                                  core_code_seg_sel     equ  0x38    ;内核代码段选择子
     5                                  core_data_seg_sel     equ  0x30    ;内核数据段选择子 
     6                                  sys_routine_seg_sel   equ  0x28    ;系统公共例程代码段的选择子 
     7                                  video_ram_seg_sel     equ  0x20    ;视频显示缓冲区的段选择子
     8                                  core_stack_seg_sel    equ  0x18    ;内核堆栈段选择子
     9                                  mem_0_4_gb_seg_sel    equ  0x08    ;整个0-4GB内存的段的选择子
    10                                  
    11                                  ;-----------内核头部-----------------------------------------------------------------------
    12                                  ;以下是系统核心的头部，用于加载核心程序 
    13 00000000 [00000000]              core_length dd core_end                         ;[0x00]内核总长度，双字，32位
    14 00000004 [00000000]              sys_routine_seg dd section.sys_routine.start    ;[0x04]系统通用库偏移地址
    15 00000008 [00000000]              core_data_seg dd section.core_data.start        ;[0x08]内核数据段偏移地址
    16 0000000C [00000000]              core_code_seg dd section.core_code.start        ;[0x0c]内核代码段偏移地址
    17 00000010 [8F030000]              core_entry dd start                             ;[0x10]内核代码段入口地址偏移量
    18 00000014 3800                               dw core_code_seg_sel                 ;[0x14]内核代码段选择子,16位的
    19                                  
    20                                  
    21                                  [bits 32]
    22                                  ;-----------系统通用库、提供字符串显示等功能-----------------------------------------------------------------------
    23                                  section sys_routine vstart=0
    24                                  ;-----------显示字符串--------------------------------------------------------------------
    25                                      put_string:                             ;显示0终止的字符串并移动光标 
    26                                                                              ;输入：DS:EBX=串地址
    27 00000000 51                              push ecx
    28                                      .getc:
    29 00000001 8A0B                            mov cl,[ebx]
    30 00000003 08C9                            or cl,cl
    31 00000005 7408                            jz .exit
    32 00000007 E805000000                      call put_char
    33 0000000C 43                              inc ebx
    34 0000000D EBF2                            jmp .getc
    35                                  
    36                                      .exit:
    37 0000000F 59                              pop ecx
    38 00000010 CB                              retf                               ;段间返回
    39                                  
    40                                      put_char:                               ;在当前光标处显示一个字符,并推进
    41                                                                      ;光标。仅用于段内调用 
    42                                                                      ;输入：CL=字符ASCII码 
    43 00000011 60                              pushad                        ;依次压入：EAX,ECX,EDX,EBX,ESP(初始值)，EBP,ESI,EDI     
    44                                  
    45                                          ;以下取当前光标位置
    46 00000012 66BAD403                        mov dx,0x3d4
    47 00000016 B00E                            mov al,0x0e
    48 00000018 EE                              out dx,al
    49 00000019 6642                            inc dx                             ;0x3d5
    50 0000001B EC                              in al,dx                           ;高字
    51 0000001C 88C4                            mov ah,al
    52                                  
    53 0000001E 664A                            dec dx                             ;0x3d4
    54 00000020 B00F                            mov al,0x0f
    55 00000022 EE                              out dx,al
    56 00000023 6642                            inc dx                             ;0x3d5
    57 00000025 EC                              in al,dx                           ;低字
    58 00000026 6689C3                          mov bx,ax                          ;BX=代表光标位置的16位数
    59                                  
    60 00000029 80F90D                          cmp cl,0x0d                        ;回车符？
    61 0000002C 750E                            jnz .put_0a
    62 0000002E 6689D8                          mov ax,bx
    63 00000031 B350                            mov bl,80
    64 00000033 F6F3                            div bl
    65 00000035 F6E3                            mul bl
    66 00000037 6689C3                          mov bx,ax
    67 0000003A EB60                            jmp .set_cursor
    68                                  
    69                                      .put_0a:
    70 0000003C 80F90A                          cmp cl,0x0a                        ;换行符？
    71 0000003F 7506                            jnz .put_other
    72 00000041 6683C350                        add bx,80
    73 00000045 EB15                            jmp .roll_screen
    74                                  
    75                                      .put_other:                               ;正常显示字符
    76 00000047 06                              push es
    77 00000048 B820000000                      mov eax,video_ram_seg_sel          ;0xb8000段的选择子
    78 0000004D 8EC0                            mov es,eax
    79 0000004F 66D1E3                          shl bx,1
    80 00000052 2667880F                        mov [es:bx],cl
    81 00000056 07                              pop es
    82                                  
    83                                          ;以下将光标位置推进一个字符
    84 00000057 66D1EB                          shr bx,1
    85 0000005A 6643                            inc bx
    86                                  
    87                                      .roll_screen:
    88 0000005C 6681FBD007                      cmp bx,2000                        ;光标超出屏幕？滚屏
    89 00000061 7C39                            jl .set_cursor
    90                                  
    91 00000063 1E                              push ds
    92 00000064 06                              push es
    93 00000065 B820000000                      mov eax,video_ram_seg_sel
    94 0000006A 8ED8                            mov ds,eax
    95 0000006C 8EC0                            mov es,eax
    96 0000006E FC                              cld
    97 0000006F BEA0000000                      mov esi,0xa0                       ;小心！32位模式下movsb/w/d 
    98 00000074 BF00000000                      mov edi,0x00                       ;使用的是esi/edi/ecx 
    99 00000079 B980070000                      mov ecx,1920
   100 0000007E F3A5                            rep movsd
   101 00000080 66BB000F                        mov bx,3840                        ;清除屏幕最底一行
   102 00000084 B950000000                  mov ecx,80                         ;32位程序应该使用ECX
   103                                      .cls:
   104 00000089 266667C7072007                  mov word[es:bx],0x0720
   105 00000090 6683C302                        add bx,2
   106 00000094 E2F3                            loop .cls
   107                                  
   108 00000096 07                              pop es
   109 00000097 1F                              pop ds
   110                                  
   111 00000098 66BB8007                        mov bx,1920
   112                                  
   113                                      .set_cursor:
   114 0000009C 66BAD403                        mov dx,0x3d4
   115 000000A0 B00E                            mov al,0x0e
   116 000000A2 EE                              out dx,al
   117 000000A3 6642                            inc dx                             ;0x3d5
   118 000000A5 88F8                            mov al,bh
   119 000000A7 EE                              out dx,al
   120 000000A8 664A                            dec dx                             ;0x3d4
   121 000000AA B00F                            mov al,0x0f
   122 000000AC EE                              out dx,al
   123 000000AD 6642                            inc dx                             ;0x3d5
   124 000000AF 88D8                            mov al,bl
   125 000000B1 EE                              out dx,al
   126                                  
   127 000000B2 61                              popad
   128 000000B3 C3                              ret 
   129                                  
   130                                  ;-----------从硬盘读取一个逻辑扇区----------------------------------------------------------------
   131                                      read_hard_disk_0:               ;使用的逻辑扇区编址方法为LBA28，也就是用28位来表示扇区号，每个扇区512字节
   132                                                                      ;eax=逻辑扇区号
   133                                                                      ;ds:ebx=目标缓冲区地址，将读到的硬盘数据放到ds段指定的内存中
   134                                  
   135 000000B4 50                              push eax                    ;将该过程会用到的寄存器入栈保存，函数返回时需要出栈还原
   136 000000B5 51                              push ecx
   137 000000B6 52                              push edx
   138                                  
   139 000000B7 50                              push eax                    ;在入栈一次eax的值
   140                                  
   141 000000B8 66BAF201                        mov dx,0x1f2                ;0x1f2端口表示要读取或写入的扇区数量，8位长度
   142 000000BC B001                            mov al,1                    ;每次要读取1个扇区
   143 000000BE EE                              out dx,al
   144                                  
   145                                          ;28位的扇区号太长，需要放到4个8位端口中，0x1f3存0-7位，0x1f4存8-15位，0x1f5存16-23位，
   146                                          ;0x1f6低4位存24-27位，第4位用于指示硬盘号，0是主盘、1是从盘,高三为全为1，表示LBA模式
   147 000000BF 6642                            inc dx                      ;0x1f3
   148 000000C1 58                              pop eax                     ;eax存放的是32位逻辑扇区号
   149 000000C2 EE                              out dx,al                   ;LBA地址7-0
   150                                  
   151 000000C3 6642                            inc dx                      ;0x1f4
   152 000000C5 B108                            mov cl,8
   153 000000C7 D3E8                            shr eax,cl
   154 000000C9 EE                              out dx,al                    ;LBA地址15~8
   155                                  
   156 000000CA 6642                            inc dx                       ;0x1f5
   157 000000CC D3E8                            shr eax,cl
   158 000000CE EE                              out dx,al                    ;LBA地址23~16
   159                                  
   160 000000CF 6642                            inc dx                      ;0x1f6
   161 000000D1 D3E8                            shr eax,cl
   162 000000D3 0CE0                            or al,0xe0                  ;因为al是1110 0000，ah高4位是0，0000 xxxx,使用or运算后al就是xxxx,表示LBA地址27-24
   163 000000D5 EE                              out dx,al
   164                                  
   165 000000D6 6642                            inc dx                      ;0x1f7，既是命令端口也是状态端口，0x20表示读，0x30表示写
   166 000000D8 B020                            mov al,0x20                 ;表示读硬盘
   167 000000DA EE                              out dx,al                  
   168                                  
   169                                          .waits:
   170 000000DB EC                                      in al,dx                    ;读取硬盘状态，第7位是1表示硬盘在忙碌，第3位是1表示已经读取完可以传输数据了
   171 000000DC 2488                                    and al,0x88                 ;二进制值：1000 1000，保留第7位与第3位的值，其他位全清0
   172 000000DE 3C08                                    cmp al,0x08                 ;二进制值：0000 1000，是否已经准备好了
   173 000000E0 75F9                                    jnz .waits                  ;尚未准备好，继续循环等待
   174                                  
   175 000000E2 B900010000                      mov ecx,256                  ;总共要读取的字数
   176 000000E7 66BAF001                        mov dx,0x1f0                 ;硬盘数据端口，长度为16位的
   177                                  
   178                                          .readw:
   179 000000EB 66ED                                    in ax,dx                    ;从硬盘读取一个字
   180 000000ED 668903                                  mov [ebx],ax                ;放到ds段内存中
   181 000000F0 83C302                                  add ebx,2                   ;bx偏移地址+2
   182 000000F3 E2F6                                    loop .readw                 ;先将ecx值减一，如果ecx的值不为0，则执行循环，否则向下继续执行
   183                                  
   184 000000F5 5A                              pop edx                      ;出栈，还原相关寄存器的原始值
   185 000000F6 59                              pop ecx
   186 000000F7 58                              pop eax
   187                                  
   188 000000F8 CB                              retf                         ;段间返回
   189                                  
   190                                  ;-----------输出调试信息-----------------------------------------------------------------------
   191                                      put_hex_dword:                      ;汇编语言程序是极难一次成功，而且调试非常困难。这个例程可以提供帮助 
   192                                                                          ;输入：EDX=要转换并显示的数字。在当前光标处以十六进制形式显示 ;一个双字并推进光标 
   193 000000F9 60                              pushad
   194 000000FA 1E                              push ds
   195                                  
   196 000000FB 66B83000                        mov ax,core_data_seg_sel           ;切换到核心数据段 
   197 000000FF 8ED8                            mov ds,ax
   198                                  
   199 00000101 BB[3C050000]                    mov ebx,bin_hex                    ;指向核心数据段内的转换表
   200 00000106 B908000000                      mov ecx,8
   201                                      .xlt:    
   202 0000010B C1C204                          rol edx,4
   203 0000010E 89D0                            mov eax,edx
   204 00000110 83E00F                          and eax,0x0000000f
   205 00000113 D7                              xlat
   206                                  
   207 00000114 51                              push ecx
   208 00000115 88C1                            mov cl,al                           
   209 00000117 E8F5FEFFFF                      call put_char
   210 0000011C 59                              pop ecx
   211                                  
   212 0000011D E2EC                            loop .xlt
   213                                  
   214 0000011F 1F                              pop ds
   215 00000120 61                              popad
   216 00000121 CB                              retf
   217                                  
   218                                  
   219                                  
   220                                  ;-----------在GDT内安装一个新的描述符--------------------------------------------------------------------
   221                                      set_up_gdt_descriptor:             ;输入edx:eax=描述符，输出cx=描述符选择子
   222 00000122 50                              push eax
   223 00000123 53                              push ebx
   224 00000124 52                              push edx
   225                                  
   226 00000125 1E                              push ds
   227 00000126 06                              push es
   228                                  
   229 00000127 BB30000000                      mov ebx,core_data_seg_sel          ;切换到核心数据段
   230 0000012C 8EDB                            mov ds,ebx
   231                                  
   232 0000012E 0F0105[00000000]                sgdt [pgdt]                        ;读取寄存器GDTR，存放到内存
   233                                  
   234 00000135 BB08000000                      mov ebx,mem_0_4_gb_seg_sel
   235 0000013A 8EC3                            mov es,ebx
   236                                  
   237 0000013C 0FB71D[00000000]                movzx ebx,word [pgdt]              ;GDT界限 
   238 00000143 6643                            inc bx                             ;GDT总字节数，也是下一个描述符偏移 
   239 00000145 031D[02000000]                  add ebx,[pgdt+2]                   ;下一个描述符的线性地址 
   240                                  
   241 0000014B 268903                          mov [es:ebx],eax
   242 0000014E 26895304                        mov [es:ebx+4],edx
   243                                  
   244 00000152 668305[00000000]08              add word [pgdt],8                  ;增加一个描述符的大小   
   245                                  
   246 0000015A 0F0115[00000000]                lgdt [pgdt]                        ;对GDT的更改生效 
   247                                          
   248 00000161 66A1[00000000]                  mov ax,[pgdt]                      ;得到GDT界限值
   249 00000167 6631D2                          xor dx,dx
   250 0000016A 66BB0800                        mov bx,8
   251 0000016E 66F7F3                          div bx                             ;除以8，去掉余数
   252 00000171 6689C1                          mov cx,ax                          
   253 00000174 66C1E103                        shl cx,3                           ;将索引号移到正确位置 
   254                                  
   255 00000178 07                              pop es
   256 00000179 1F                              pop ds
   257                                  
   258 0000017A 5A                              pop edx
   259 0000017B 5B                              pop ebx
   260 0000017C 58                              pop eax
   261                                  
   262 0000017D CB                              retf        
   263                                  
   264                                  ;-----------构造描述符--------------------------------------------------------------------
   265                                      make_seg_descriptor:            ;输入：eax=线性基址，ebx=段界限,ecx=属性（各属性位都在原始位置，其它没用到的位置0） 
   266                                                                      ;输出edx:eax=完整的描述符
   267 0000017E 89C2                            mov edx,eax
   268 00000180 C1E010                          shl eax,16                  ;描述符低32位中的高16位是基地址部分，所以左移16位使其基地址部分就位
   269 00000183 6609D8                          or ax,bx                    ;低16位是段界限，取的段界限
   270                                  
   271 00000186 81E20000FFFF                    and edx,0xffff0000          ;清除低16位
   272 0000018C C1C208                          rol edx,8                   ;edx循环左移8位，循环左移会将左移出的位放到右边。这样edx中低8位的值就是原先高8位的值
   273 0000018F 0FCA                            bswap edx                   ;字节交换指令。装配基址的31~24和23~16  (80486+)
   274                                  
   275 00000191 6631DB                          xor bx,bx
   276 00000194 09DA                            or edx,ebx                  ;装配段界限的高4位
   277                                          
   278 00000196 09CA                            or edx,ecx                  ;装配段属性
   279                                  
   280 00000198 CB                              retf
   281                                  
   282                                  ;-----------构造门的描述符（调用门等）--------------------------------------------------------------------
   283                                      make_gate_descriptor:           ;输入：eax=门代码在段内的偏移地址，bx=门代码的段选择子，cx=门属性
   284                                                                      ;输出：edx:eax=完整的描述符
   285 00000199 53                              push ebx
   286 0000019A 51                              push ecx
   287                                  
   288 0000019B 89C2                            mov edx,eax
   289 0000019D 81E20000FFFF                    and edx,0xffff0000          ;得到偏移地址高16位 
   290 000001A3 6609CA                          or  dx,cx                   ;组装属性部分到edx
   291                                  
   292 000001A6 25FFFF0000                      and eax,0x0000ffff          ;得到偏移地址低16位
   293 000001AB C1E310                          shl ebx,16                  ;左移16位使段选择子位于它的高16位        
   294 000001AE 09D8                            or eax,ebx                  ;组装段选择子部分
   295                                      
   296 000001B0 59                              pop ecx
   297 000001B1 5B                              pop ebx
   298                                      
   299 000001B2 CB                              retf   
   300                                  
   301                                  ;-----------分配一个4kb的页-----------------------------------------------------------------------
   302                                      allocate_a_4k_page:
   303                                                                      ;输入：无。输出：eax=页的物理地址
   304 000001B3 53                              push ebx
   305 000001B4 51                              push ecx
   306 000001B5 52                              push edx
   307 000001B6 1E                              push ds
   308                                  
   309 000001B7 B830000000                      mov eax,core_data_seg_sel
   310 000001BC 8ED8                            mov ds,eax                  ;使ds指向内核数据区
   311                                           
   312 000001BE 31C0                            xor eax,eax       
   313                                      .b1:
   314 000001C0 0FAB05[06000000]                bts [page_bit_map],eax      ;将指定位置(eax)的比特传送到CF标志为并将该位置的值设置为1
   315 000001C7 7315                            jnc .b2                     ;找到了为0的位，则去分配内存
   316 000001C9 40                              inc eax
   317 000001CA 3D00020000                      cmp eax,page_map_len*8      ;用于判断是否已经比较了所有位，如果仍未找到可以分配的页，则提示错误信息并停机
   318 000001CF 7CEF                            jl .b1
   319                                  
   320 000001D1 BB[EF040000]                    mov ebx,message_3
   321 000001D6 9A[00000000]2800                call sys_routine_seg_sel:put_string
   322 000001DD F4                              hlt                                ;没有可以分配的页，停机 
   323                                      .b2:
   324 000001DE C1E00C                          shl eax,12                         ;左移12位，相当于乘以4096(0x1000)
   325                                                                             ;页映射位串中位的值乘以0x1000就是页的物理地址
   326                                  
   327 000001E1 1F                              pop ds
   328 000001E2 5A                              pop edx
   329 000001E3 59                              pop ecx
   330 000001E4 5B                              pop ebx
   331                                          
   332 000001E5 C3                              ret
   333                                  
   334                                  ;-----------分配一个页并安装-----------------------------------------------------------------------
   335                                      alloc_inst_a_page:                      ;分配一个页，并安装在当前活动的层级分页结构中
   336                                                                              ;输入：ebx=页的线性地址
   337 000001E6 50                              push eax
   338 000001E7 53                              push ebx
   339 000001E8 56                              push esi
   340 000001E9 1E                              push ds
   341                                  
   342 000001EA B808000000                      mov eax,mem_0_4_gb_seg_sel
   343 000001EF 8ED8                            mov ds,eax                          ;使ds指向4G内存段
   344                                  
   345                                          ;检查该线性地址所对应的页表是否存在
   346 000001F1 89DE                            mov esi,ebx
   347 000001F3 81E60000C0FF                    and esi,0xffc00000                  ;只保留高10位
   348 000001F9 C1EE14                          shr esi,20                          ;得到页目录索引，并乘以4。等价于(shr esi,22)*4
   349 000001FC 81CE00F0FFFF                    or esi,0xfffff000                   ;页目录自身的线性地址+表内偏移，就是要访问的目录项的线性地址（存储的是页表物理地址）
   350                                  
   351 00000202 F70601000000                    test dword [esi],0x00000001         ;P位是否为“1”。检查该线性地址是否已经有对应的页表。test等价于and
   352 00000208 750A                            jnz .b1                             ;已分配，跳转
   353                                          ;创建该线性地址所对应的页表
   354 0000020A E8A4FFFFFF                      call allocate_a_4k_page             ;分配一个页当页表
   355 0000020F 83C807                          or eax,0x00000007                   ;设置页的属性，可读写的，特权3的也可访问
   356 00000212 8906                            mov [esi],eax
   357                                      .b1:
   358                                          ;开始访问该线性地址所对应的页表
   359 00000214 89DE                            mov esi,ebx
   360 00000216 C1EE0A                          shr esi,10                          ;右移10位，将高10位移动到中间10位
   361 00000219 81E600F03F00                    and esi,0x003ff000                  ;或者0xfffff000，因高10位是零。只保留中间10位 
   362 0000021F 81CE0000C0FF                    or esi,0xffc00000                   ;得到该页表的线性地址
   363                                  
   364                                          ;得到该线性地址在页表内的对应条目（页表项）
   365 00000225 81E300F03F00                    and ebx,0x003ff000                  ;只保留中间10位
   366 0000022B C1EB0A                          shr ebx,10                          ;相当于右移12位，再乘以4
   367 0000022E 09DE                            or esi,ebx                          ;页表项的线性地址 
   368 00000230 E87EFFFFFF                      call allocate_a_4k_page             ;分配一个页，这才是要安装的页
   369 00000235 83C807                          or eax,0x00000007
   370 00000238 8906                            mov [esi],eax 
   371                                          
   372 0000023A 1F                              pop ds
   373 0000023B 5E                              pop esi
   374 0000023C 5B                              pop ebx
   375 0000023D 58                              pop eax
   376                                          
   377 0000023E CB                              retf  
   378                                  
   379                                  ;-----------创建新的内存页目录-----------------------------------------------------------------------
   380                                      create_copy_cur_pdir:                   ;创建新页目录，并复制当前页目录内容
   381                                                                              ;输入无，输出：eax=新页目录的物理地址
   382 0000023F 1E                              push ds
   383 00000240 06                              push es
   384 00000241 56                              push esi
   385 00000242 57                              push edi
   386 00000243 53                              push ebx
   387 00000244 51                              push ecx
   388                                          
   389 00000245 BB08000000                      mov ebx,mem_0_4_gb_seg_sel
   390 0000024A 8EDB                            mov ds,ebx
   391 0000024C 8EC3                            mov es,ebx
   392                                  
   393 0000024E BB08000000                      mov ebx,mem_0_4_gb_seg_sel
   394 00000253 8EDB                            mov ds,ebx
   395 00000255 8EC3                            mov es,ebx
   396                                          
   397 00000257 E857FFFFFF                      call allocate_a_4k_page            
   398 0000025C 89C3                            mov ebx,eax
   399 0000025E 83CB07                          or ebx,0x00000007
   400 00000261 891DF8FFFFFF                    mov [0xfffffff8],ebx               ;将新目录页的物理地址登记到内核目录页的倒数第二个项内
   401                                          
   402 00000267 BE00F0FFFF                      mov esi,0xfffff000                 ;ESI->当前页目录的线性地址
   403 0000026C BF00E0FFFF                      mov edi,0xffffe000                 ;EDI->新页目录的线性地址
   404 00000271 B900040000                      mov ecx,1024                       ;ECX=要复制的目录项数
   405 00000276 FC                              cld
   406 00000277 F3A5                            repe movsd 
   407                                          
   408 00000279 59                              pop ecx
   409 0000027A 5B                              pop ebx
   410 0000027B 5F                              pop edi
   411 0000027C 5E                              pop esi
   412 0000027D 07                              pop es
   413 0000027E 1F                              pop ds
   414                                          
   415 0000027F CB                              retf
   416                                  
   417                                  ;-----------终止当前任务--------------------------------------------------------------------
   418                                      terminate_current_task:
   419                                                                             ;注意，执行此例程时，当前任务仍在运行中。此例程其实也是当前任务的一部分
   420 00000280 B830000000                      mov eax,core_data_seg_sel
   421 00000285 8ED8                            mov ds,eax
   422                                  
   423 00000287 9C                              pushfd
   424 00000288 5A                              pop edx
   425                                  
   426 00000289 66F7C20040                      test dx,0100_0000_0000_0000B       ;测试NT位
   427 0000028E 7506                            jnz .b1                            ;当前任务是嵌套的，到.b1执行iretd 
   428 00000290 FF2D[920D0000]                  jmp far [program_man_tss]          ;程序管理器任务 
   429                                      .b1: 
   430 00000296 CF                              iretd                              ;从中断返回，依次从栈中弹出IP、CS、FLAGS内容 
   431                                          
   432                                      sys_routine_end:
   433                                  
   434                                  ;-----------内核数据段-----------------------------------------------------------------------
   435                                  section core_data vstart=0                   
   436 00000000 0000                        pgdt            dw  0             ;用于设置和修改GDT 
   437 00000002 00000000                                    dd  0
   438                                      ;页映射位串，假定只有2M内存可用，可分为512页，每一位表示每一页是否分配
   439                                      ;低端1m内存已经被内核、bios和外设占用了，所以设置为0xff
   440 00000006 FFFFFFFFFF5555FF            page_bit_map    db  0xff,0xff,0xff,0xff,0xff,0x55,0x55,0xff
   441 0000000E FFFFFFFFFFFFFFFF                            db  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
   442 00000016 FFFFFFFFFFFFFFFF                            db  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
   443 0000001E FFFFFFFFFFFFFFFF                            db  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
   444 00000026 5555555555555555                            db  0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55
   445 0000002E 0000000000000000                            db  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   446 00000036 0000000000000000                            db  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   447 0000003E 0000000000000000                            db  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   448                                      page_map_len    equ $-page_bit_map
   449                                  
   450                                      ;符号地址检索表
   451                                      salt:
   452 00000046 405072696E74537472-             salt_1          db  '@PrintString'      ;打印字符串函数别名
   452 0000004F 696E67             
   453 00000052 00<rep F4h>                                 times 256-($-salt_1) db 0   ;不足256长度的补0
   454 00000146 [00000000]                                      dd  put_string          ;函数偏移量
   455 0000014A 2800                                            dw  sys_routine_seg_sel ;公共库代码段选择子，内核执行时会使用调用门段选择子替换
   456                                  
   457 0000014C 40526561644469736B-             salt_2          db  '@ReadDiskData'
   457 00000155 44617461           
   458 00000159 00<rep F3h>                                 times 256-($-salt_2) db 0
   459 0000024C [B4000000]                                      dd  read_hard_disk_0
   460 00000250 2800                                            dw  sys_routine_seg_sel
   461                                  
   462 00000252 405072696E7444776F-             salt_3          db  '@PrintDwordAsHexString'
   462 0000025B 726441734865785374-
   462 00000264 72696E67           
   463 00000268 00<rep EAh>                                 times 256-($-salt_3) db 0
   464 00000352 [F9000000]                                      dd  put_hex_dword
   465 00000356 2800                                            dw  sys_routine_seg_sel
   466                                  
   467 00000358 405465726D696E6174-             salt_4          db  '@TerminateProgram'
   467 00000361 6550726F6772616D   
   468 00000369 00<rep EFh>                                 times 256-($-salt_4) db 0
   469 00000458 [80020000]                                      dd  terminate_current_task
   470 0000045C 2800                                            dw  sys_routine_seg_sel
   471                                  
   472                                          salt_item_len   equ $-salt_4                ;单个符号表大小，262字节
   473                                          salt_items      equ ($-salt)/salt_item_len  ;符号表数量
   474                                  
   475 0000045E 2020576F726B696E67-             message_0       db  '  Working in system core,protect mode.'
   475 00000467 20696E207379737465-
   475 00000470 6D20636F72652C7072-
   475 00000479 6F74656374206D6F64-
   475 00000482 652E               
   476 00000484 0D0A00                                          db  0x0d,0x0a,0
   477                                  
   478 00000487 2020506167696E6720-             message_1       db  '  Paging is enabled.System core is mapped to'
   478 00000490 697320656E61626C65-
   478 00000499 642E53797374656D20-
   478 000004A2 636F7265206973206D-
   478 000004AB 617070656420746F   
   479 000004B3 206164647265737320-                             db  ' address 0x80000000.',0x0d,0x0a,0
   479 000004BC 307838303030303030-
   479 000004C5 302E0D0A00         
   480                                          
   481 000004CA 0D0A                            message_2       db  0x0d,0x0a
   482 000004CC 202053797374656D20-                             db  '  System wide CALL-GATE mounted.',0x0d,0x0a,0
   482 000004D5 776964652043414C4C-
   482 000004DE 2D47415445206D6F75-
   482 000004E7 6E7465642E0D0A00   
   483                                          
   484 000004EF 2A2A2A2A2A2A2A2A4E-             message_3       db  '********No more pages********',0
   484 000004F8 6F206D6F7265207061-
   484 00000501 6765732A2A2A2A2A2A-
   484 0000050A 2A2A00             
   485                                          
   486 0000050D 0D0A20205461736B20-             message_4       db  0x0d,0x0a,'  Task switching...@_@',0x0d,0x0a,0
   486 00000516 737769746368696E67-
   486 0000051F 2E2E2E405F400D0A00 
   487                                          
   488 00000528 0D0A202050726F6365-             message_5       db  0x0d,0x0a,'  Processor HALT.',0
   488 00000531 73736F722048414C54-
   488 0000053A 2E00               
   489                                  
   490 0000053C 303132333435363738-         bin_hex         db '0123456789ABCDEF'
   490 00000545 39414243444546     
   491                                                                      ;put_hex_dword子过程用的查找表 
   492                                  
   493 0000054C 00<rep 800h>                core_buf   times 2048 db 0         ;内核用的缓冲区 
   494                                  
   495 00000D4C 0D0A202000                  cpu_brnd0       db 0x0d,0x0a,'  ',0
   496 00000D51 00<rep 34h>                 cpu_brand  times 52 db 0
   497 00000D85 0D0A0D0A00                  cpu_brnd1       db 0x0d,0x0a,0x0d,0x0a,0
   498                                  
   499                                      ;任务控制块链表头
   500 00000D8A 00000000                    tcb_chain       dd  0
   501                                  
   502                                      ;内核信息
   503 00000D8E 00001080                    core_next_laddr dd  0x80100000    ;内核空间中下一个可分配的线性地址        
   504 00000D92 00000000                    program_man_tss dd  0             ;程序管理器的TSS描述符选择子 
   505 00000D96 0000                                        dw  0
   506                                      core_data_end:
   507                                  
   508                                  ;-----------内核代码段-----------------------------------------------------------------------
   509                                  section core_code vstart=0
   510                                  ;-----------在LDT内安装一个新的描述符-----------------------------------------------------------------------
   511                                      fill_descriptor_in_ldt:             ;输入：edx:eax=完整描述符，ebx=TCB基地址
   512                                                                          ;输出：cx=描述符选择子
   513 00000000 50                              push eax
   514 00000001 52                              push edx
   515 00000002 57                              push edi
   516 00000003 1E                              push ds
   517                                  
   518 00000004 B908000000                      mov ecx,mem_0_4_gb_seg_sel
   519 00000009 8ED9                            mov ds,ecx                      ;使ds指向4G数据段
   520                                  
   521 0000000B 8B7B0C                          mov edi,[ebx+0x0c]              ;获得LDT基地址
   522                                  
   523 0000000E 31C9                            xor ecx,ecx
   524 00000010 668B4B0A                        mov cx,[ebx+0x0a]               ;获得LDT界限
   525 00000014 6641                            inc cx                          ;LDT的总字节数，即新描述符偏移地址
   526                                  
   527 00000016 89040F                          mov [edi+ecx+0x00],eax
   528 00000019 89540F04                        mov [edi+ecx+0x04],edx          ;安装描述符
   529                                  
   530 0000001D 6683C108                        add cx,8                           
   531 00000021 6649                            dec cx                          ;得到新的LDT界限值 
   532                                  
   533 00000023 66894B0A                        mov [ebx+0x0a],cx               ;更新LDT界限值到TCB
   534                                  
   535 00000027 6689C8                          mov ax,cx
   536 0000002A 6631D2                          xor dx,dx
   537 0000002D 66B90800                        mov cx,8
   538 00000031 66F7F1                          div cx                          ;除以8，商就是新描述符的索引
   539                                  
   540 00000034 6689C1                          mov cx,ax
   541 00000037 66C1E103                        shl cx,3                         ;左移3位，并且
   542 0000003B 6683C904                        or cx,0000_0000_0000_0100B       ;使TI位=1，指向LDT，最后使RPL=00 
   543                                  
   544 0000003F 1F                              pop ds
   545 00000040 5F                              pop edi
   546 00000041 5A                              pop edx
   547 00000042 58                              pop eax
   548                                      
   549 00000043 C3                              ret
   550                                  
   551                                  ;-----------加载并重定位用户程序-----------------------------------------------------------------------
   552                                      load_relocate_program:              ;输入push:逻辑扇区号，push:任务控制块起始地址
   553                                                                          ;调用该函数时会先压入EIP
   554 00000044 60                              pushad                          ;依次压入：EAX,ECX,EDX,EBX,ESP(初始值)，EBP,ESI,EDI,共8个寄存器
   555 00000045 1E                              push ds
   556 00000046 06                              push es                         
   557                                  
   558 00000047 89E5                            mov ebp,esp                     ;使栈基址寄存器指向初始栈地址
   559 00000049 B908000000                      mov ecx,mem_0_4_gb_seg_sel
   560 0000004E 8EC1                            mov es,ecx                      ;es指向4G数据段
   561                                  
   562                                          ;清空当前页目录的前半部分（对应低2GB的局部地址空间）
   563 00000050 BB00F0FFFF                      mov ebx,0xfffff000              ;页目录表的线性地址
   564 00000055 31F6                            xor esi,esi
   565                                      .b1:
   566 00000057 26C704B300000000                mov dword [es:ebx+esi*4],0x00000000
   567 0000005F 46                              inc esi
   568 00000060 81FE00020000                    cmp esi,512                     ;前512页目录项全置为0
   569 00000066 7CEF                            jl .b1
   570                                  
   571                                          ;以下开始分配内存并加载用户程序
   572 00000068 B830000000                      mov eax,core_data_seg_sel
   573 0000006D 8ED8                            mov ds,eax                      ;切换DS到内核数据段
   574                                  
   575                                  
   576 0000006F 8B4530                          mov eax,[ebp+12*4]              ;读取起始扇区号
   577 00000072 BB[4C050000]                    mov ebx,core_buf                ;用于读取磁盘数据的内核缓冲区
   578 00000077 9A[B4000000]2800                call sys_routine_seg_sel:read_hard_disk_0
   579                                  
   580                                          ;以下判断整个程序有多大
   581 0000007E A1[4C050000]                    mov eax,[core_buf]                 ;程序尺寸
   582 00000083 89C3                            mov ebx,eax
   583 00000085 81E300F0FFFF                    and ebx,0xfffff000                 ;使之4KB对齐 
   584 0000008B 81C300100000                    add ebx,0x1000                        
   585 00000091 A9FF0F0000                      test eax,0x00000fff                ;程序的大小正好是4KB的倍数吗? 
   586 00000096 0F45C3                          cmovnz eax,ebx                     ;不是。使用凑整的结果
   587                                  
   588 00000099 89C1                            mov ecx,eax
   589 0000009B C1E90C                          shr ecx,12                         ;程序占用的总4KB页数，右移12位相当于除以4096
   590                                          
   591 0000009E B808000000                      mov eax,mem_0_4_gb_seg_sel         ;切换DS到0-4GB的段
   592 000000A3 8ED8                            mov ds,eax
   593                                  
   594 000000A5 8B4530                          mov eax,[ebp+12*4]                 ;起始扇区号
   595 000000A8 8B752C                          mov esi,[ebp+11*4]                 ;从堆栈中取得TCB的基地址
   596                                      .b2:
   597 000000AB 268B5E06                        mov ebx,[es:esi+0x06]              ;取得可用的线性地址
   598 000000AF 2681460600100000                add dword [es:esi+0x06],0x1000
   599 000000B7 9A[E6010000]2800                call sys_routine_seg_sel:alloc_inst_a_page
   600                                  
   601 000000BE 51                              push ecx
   602 000000BF B908000000                      mov ecx,8                          ;控制内循环，因为磁盘每次读取512字节，要想读取4k，则需要读取8次
   603                                      .b3:
   604 000000C4 9A[B4000000]2800                call sys_routine_seg_sel:read_hard_disk_0
   605 000000CB 40                              inc eax                            ;递增扇区号
   606 000000CC E2F6                            loop .b3
   607                                  
   608 000000CE 59                              pop ecx
   609 000000CF E2DA                            loop .b2                           ;继续执行外循环，先分配内存
   610                                  
   611                                          ;在内核地址空间内创建用户任务的TSS
   612 000000D1 B830000000                      mov eax,core_data_seg_sel          ;切换DS到内核数据段
   613 000000D6 8ED8                            mov ds,eax
   614                                  
   615 000000D8 8B1D[8E0D0000]                  mov ebx,[core_next_laddr]          ;用户任务的TSS必须在全局空间上分配 
   616 000000DE 9A[E6010000]2800                call sys_routine_seg_sel:alloc_inst_a_page
   617 000000E5 8105[8E0D0000]0010-             add dword [core_next_laddr],4096
   617 000000ED 0000               
   618                                          
   619 000000EF 26895E14                        mov [es:esi+0x14],ebx              ;在TCB中填写TSS的线性地址 
   620 000000F3 2666C746126700                  mov word [es:esi+0x12],103         ;在TCB中填写TSS的界限值 
   621                                          
   622                                          ;在用户任务的局部地址空间内创建LDT 
   623 000000FA 268B5E06                        mov ebx,[es:esi+0x06]              ;从TCB中取得可用的线性地址
   624 000000FE 2681460600100000                add dword [es:esi+0x06],0x1000
   625 00000106 9A[E6010000]2800                call sys_routine_seg_sel:alloc_inst_a_page
   626 0000010D 26895E0C                        mov [es:esi+0x0c],ebx              ;填写LDT线性地址到TCB中 
   627                                  
   628                                          ;建立程序代码段描述符
   629 00000111 B800000000                      mov eax,0x00000000
   630 00000116 BBFFFF0F00                      mov ebx,0x000fffff                 
   631 0000011B B900F8C000                      mov ecx,0x00c0f800                 ;4KB粒度的代码段描述符，特权级3
   632 00000120 9A[7E010000]2800                call sys_routine_seg_sel:make_seg_descriptor
   633 00000127 89F3                            mov ebx,esi                        ;TCB的基地址
   634 00000129 E8D2FEFFFF                      call fill_descriptor_in_ldt
   635 0000012E 6683C903                        or cx,0000_0000_0000_0011B         ;设置选择子的特权级为3
   636                                          
   637 00000132 268B5E14                        mov ebx,[es:esi+0x14]              ;从TCB中获取TSS的线性地址
   638 00000136 2666894B4C                      mov [es:ebx+76],cx                 ;填写TSS的CS域 
   639                                  
   640                                          ;建立程序数据段描述符
   641 0000013B B800000000                      mov eax,0x00000000
   642 00000140 BBFFFF0F00                      mov ebx,0x000fffff                 
   643 00000145 B900F2C000                      mov ecx,0x00c0f200                 ;4KB粒度的数据段描述符，特权级3
   644 0000014A 9A[7E010000]2800                call sys_routine_seg_sel:make_seg_descriptor
   645 00000151 89F3                            mov ebx,esi                        ;TCB的基地址
   646 00000153 E8A8FEFFFF                      call fill_descriptor_in_ldt
   647 00000158 6683C903                        or cx,0000_0000_0000_0011B         ;设置选择子的特权级为3
   648                                          
   649 0000015C 268B5E14                        mov ebx,[es:esi+0x14]              ;从TCB中获取TSS的线性地址
   650 00000160 2666894B54                      mov [es:ebx+84],cx                 ;填写TSS的DS域 
   651 00000165 2666894B48                      mov [es:ebx+72],cx                 ;填写TSS的ES域
   652 0000016A 2666894B58                      mov [es:ebx+88],cx                 ;填写TSS的FS域
   653 0000016F 2666894B5C                      mov [es:ebx+92],cx                 ;填写TSS的GS域
   654                                  
   655                                          ;将数据段作为用户任务的3特权级固有堆栈 
   656 00000174 268B5E06                        mov ebx,[es:esi+0x06]              ;从TCB中取得可用的线性地址
   657 00000178 2681460600100000                add dword [es:esi+0x06],0x1000
   658 00000180 9A[E6010000]2800                call sys_routine_seg_sel:alloc_inst_a_page  ;分配4k的栈内存
   659                                  
   660 00000187 268B5E14                        mov ebx,[es:esi+0x14]              ;从TCB中获取TSS的线性地址
   661 0000018B 2666894B50                      mov [es:ebx+80],cx                 ;填写TSS的SS域
   662 00000190 268B5606                        mov edx,[es:esi+0x06]              ;堆栈的高端线性地址 
   663 00000194 26895338                        mov [es:ebx+56],edx                ;填写TSS的ESP域 
   664                                  
   665                                          ;在用户任务的局部地址空间内创建0特权级堆栈
   666 00000198 268B5E06                        mov ebx,[es:esi+0x06]              ;从TCB中取得可用的线性地址
   667 0000019C 2681460600100000                add dword [es:esi+0x06],0x1000
   668 000001A4 9A[E6010000]2800                call sys_routine_seg_sel:alloc_inst_a_page
   669                                  
   670 000001AB B800000000                      mov eax,0x00000000
   671 000001B0 BBFFFF0F00                      mov ebx,0x000fffff
   672 000001B5 B90092C000                      mov ecx,0x00c09200                 ;4KB粒度的堆栈段描述符，特权级0
   673 000001BA 9A[7E010000]2800                call sys_routine_seg_sel:make_seg_descriptor
   674 000001C1 89F3                            mov ebx,esi                        ;TCB的基地址
   675 000001C3 E838FEFFFF                      call fill_descriptor_in_ldt
   676 000001C8 6683C900                        or cx,0000_0000_0000_0000B         ;设置选择子的特权级为0
   677                                  
   678 000001CC 268B5E14                        mov ebx,[es:esi+0x14]              ;从TCB中获取TSS的线性地址
   679 000001D0 2666894B08                      mov [es:ebx+8],cx                  ;填写TSS的SS0域
   680 000001D5 268B5606                        mov edx,[es:esi+0x06]              ;堆栈的高端线性地址
   681 000001D9 26895304                        mov [es:ebx+4],edx                 ;填写TSS的ESP0域 
   682                                  
   683                                          ;在用户任务的局部地址空间内创建1特权级堆栈
   684 000001DD 268B5E06                        mov ebx,[es:esi+0x06]              ;从TCB中取得可用的线性地址
   685 000001E1 2681460600100000                add dword [es:esi+0x06],0x1000
   686 000001E9 9A[E6010000]2800                call sys_routine_seg_sel:alloc_inst_a_page
   687                                  
   688 000001F0 B800000000                      mov eax,0x00000000
   689 000001F5 BBFFFF0F00                      mov ebx,0x000fffff
   690 000001FA B900B2C000                      mov ecx,0x00c0b200                 ;4KB粒度的堆栈段描述符，特权级1
   691 000001FF 9A[7E010000]2800                call sys_routine_seg_sel:make_seg_descriptor
   692 00000206 89F3                            mov ebx,esi                        ;TCB的基地址
   693 00000208 E8F3FDFFFF                      call fill_descriptor_in_ldt
   694 0000020D 6683C901                        or cx,0000_0000_0000_0001B         ;设置选择子的特权级为1
   695                                  
   696 00000211 268B5E14                        mov ebx,[es:esi+0x14]              ;从TCB中获取TSS的线性地址
   697 00000215 2666894B10                      mov [es:ebx+16],cx                 ;填写TSS的SS1域
   698 0000021A 268B5606                        mov edx,[es:esi+0x06]              ;堆栈的高端线性地址
   699 0000021E 2689530C                        mov [es:ebx+12],edx                ;填写TSS的ESP1域 
   700                                  
   701                                          ;在用户任务的局部地址空间内创建2特权级堆栈
   702 00000222 268B5E06                        mov ebx,[es:esi+0x06]              ;从TCB中取得可用的线性地址
   703 00000226 2681460600100000                add dword [es:esi+0x06],0x1000
   704 0000022E 9A[E6010000]2800                call sys_routine_seg_sel:alloc_inst_a_page
   705                                  
   706 00000235 B800000000                      mov eax,0x00000000
   707 0000023A BBFFFF0F00                      mov ebx,0x000fffff
   708 0000023F B900D2C000                      mov ecx,0x00c0d200                 ;4KB粒度的堆栈段描述符，特权级2
   709 00000244 9A[7E010000]2800                call sys_routine_seg_sel:make_seg_descriptor
   710 0000024B 89F3                            mov ebx,esi                        ;TCB的基地址
   711 0000024D E8AEFDFFFF                      call fill_descriptor_in_ldt
   712 00000252 6683C902                        or cx,0000_0000_0000_0010B         ;设置选择子的特权级为2
   713                                  
   714 00000256 268B5E14                        mov ebx,[es:esi+0x14]              ;从TCB中获取TSS的线性地址
   715 0000025A 2666894B18                      mov [es:ebx+24],cx                 ;填写TSS的SS2域
   716 0000025F 268B5606                        mov edx,[es:esi+0x06]              ;堆栈的高端线性地址
   717 00000263 26895314                        mov [es:ebx+20],edx                ;填写TSS的ESP2域 
   718                                  
   719                                          ;重定位SALT 
   720 00000267 B808000000                      mov eax,mem_0_4_gb_seg_sel         ;访问任务的4GB虚拟地址空间时用 
   721 0000026C 8EC0                            mov es,eax                         
   722                                                                                  
   723 0000026E B830000000                      mov eax,core_data_seg_sel
   724 00000273 8ED8                            mov ds,eax
   725                                      
   726 00000275 FC                              cld
   727                                  
   728 00000276 268B0D0C000000                  mov ecx,[es:0x0c]                  ;U-SALT条目数 
   729 0000027D 268B3D08000000                  mov edi,[es:0x08]                  ;U-SALT在4GB空间内的偏移 
   730                                      .b4:
   731 00000284 51                              push ecx
   732 00000285 57                              push edi
   733                                      
   734 00000286 B904000000                      mov ecx,salt_items
   735 0000028B BE[46000000]                    mov esi,salt
   736                                      .b5:
   737 00000290 57                              push edi
   738 00000291 56                              push esi
   739 00000292 51                              push ecx
   740                                  
   741 00000293 B940000000                      mov ecx,64                         ;检索表中，每条目的比较次数 
   742 00000298 F3A7                            repe cmpsd                         ;每次比较4字节 
   743 0000029A 7519                            jnz .b6
   744 0000029C 8B06                            mov eax,[esi]                      ;若匹配，则esi恰好指向其后的地址
   745 0000029E 26898700FFFFFF                  mov [es:edi-256],eax               ;将字符串改写成偏移地址 
   746 000002A5 668B4604                        mov ax,[esi+4]
   747 000002A9 6683C803                        or ax,0000000000000011B            ;以用户程序自己的特权级使用调用门
   748                                                                          ;故RPL=3 
   749 000002AD 2666898704FFFFFF                mov [es:edi-252],ax                ;回填调用门选择子 
   750                                      .b6:
   751                                      
   752 000002B5 59                              pop ecx
   753 000002B6 5E                              pop esi
   754 000002B7 81C606010000                    add esi,salt_item_len
   755 000002BD 5F                              pop edi                            ;从头比较 
   756 000002BE E2D0                            loop .b5
   757                                      
   758 000002C0 5F                              pop edi
   759 000002C1 81C700010000                    add edi,256
   760 000002C7 59                              pop ecx
   761 000002C8 E2BA                            loop .b4
   762                                  
   763                                          ;在GDT中登记LDT描述符
   764 000002CA 8B752C                          mov esi,[ebp+11*4]                 ;从堆栈中取得TCB的基地址
   765 000002CD 268B460C                        mov eax,[es:esi+0x0c]              ;LDT的起始线性地址
   766 000002D1 260FB75E0A                      movzx ebx,word [es:esi+0x0a]       ;LDT段界限
   767 000002D6 B900824000                      mov ecx,0x00408200                 ;LDT描述符，特权级0
   768 000002DB 9A[7E010000]2800                call sys_routine_seg_sel:make_seg_descriptor
   769 000002E2 9A[22010000]2800                call sys_routine_seg_sel:set_up_gdt_descriptor
   770 000002E9 2666894E10                      mov [es:esi+0x10],cx               ;登记LDT选择子到TCB中
   771                                  
   772 000002EE 268B5E14                        mov ebx,[es:esi+0x14]              ;从TCB中获取TSS的线性地址
   773 000002F2 2666894B60                      mov [es:ebx+96],cx                 ;填写TSS的LDT域 
   774                                  
   775 000002F7 2666C7030000                    mov word [es:ebx+0],0              ;反向链=0
   776                                      
   777 000002FD 26668B5612                      mov dx,[es:esi+0x12]               ;段长度（界限）
   778 00000302 2666895366                      mov [es:ebx+102],dx                ;填写TSS的I/O位图偏移域 
   779                                      
   780 00000307 2666C743640000                  mov word [es:ebx+100],0            ;T=0
   781                                      
   782 0000030E 26A104000000                    mov eax,[es:0x04]                  ;从任务的4GB地址空间获取入口点 
   783 00000314 26894320                        mov [es:ebx+32],eax                ;填写TSS的EIP域 
   784                                  
   785 00000318 9C                              pushfd
   786 00000319 5A                              pop edx
   787 0000031A 26895324                        mov [es:ebx+36],edx                ;填写TSS的EFLAGS域 
   788                                  
   789                                          ;在GDT中登记TSS描述符
   790 0000031E 268B4614                        mov eax,[es:esi+0x14]              ;从TCB中获取TSS的起始线性地址
   791 00000322 260FB75E12                      movzx ebx,word [es:esi+0x12]       ;段长度（界限）
   792 00000327 B900894000                      mov ecx,0x00408900                 ;TSS描述符，特权级0
   793 0000032C 9A[7E010000]2800                call sys_routine_seg_sel:make_seg_descriptor
   794 00000333 9A[22010000]2800                call sys_routine_seg_sel:set_up_gdt_descriptor
   795 0000033A 2666894E18                      mov [es:esi+0x18],cx               ;登记TSS选择子到TCB
   796                                  
   797                                          ;创建用户任务的页目录
   798                                          ;注意,页的分配和使用是由页位图决定的，可以不占用线性地址空间 
   799 0000033F 9A[3F020000]2800                call sys_routine_seg_sel:create_copy_cur_pdir
   800 00000346 268B5E14                        mov ebx,[es:esi+0x14]              ;从TCB中获取TSS的线性地址
   801 0000034A 2689431C                        mov dword [es:ebx+28],eax          ;填写TSS的CR3(PDBR)域
   802                                  
   803 0000034E 07                              pop es                             ;恢复到调用此过程前的es段 
   804 0000034F 1F                              pop ds                             ;恢复到调用此过程前的ds段
   805                                      
   806 00000350 61                              popad
   807                                      
   808 00000351 C20800                          ret 8                              ;丢弃调用本过程前压入的参数，也就是压入的两个参数，8个字节
   809                                  
   810                                  ;-----------在TCB链上追加任务控制块-----------------------------------------------------------------------
   811                                      append_to_tcb_link:                 ;输入：ecx=起始线性地址
   812 00000354 50                              push eax
   813 00000355 52                              push edx
   814 00000356 1E                              push ds
   815 00000357 06                              push es
   816                                  
   817 00000358 B830000000                      mov eax,core_data_seg_sel
   818 0000035D 8ED8                            mov ds,eax                      ;令DS指向内核数据段 
   819                                  
   820 0000035F B808000000                      mov eax,mem_0_4_gb_seg_sel
   821 00000364 8EC0                            mov es,eax                      ;令ES指向0..4GB段
   822                                  
   823 00000366 26C70100000000                  mov dword [es: ecx+0x00],0      ;当前TCB指针域清零，以指示这是最后一个TCB
   824 0000036D A1[8A0D0000]                    mov eax,[tcb_chain]
   825 00000372 09C0                            or eax,eax  
   826 00000374 740E                            jz .notcb                       ;如果表头指针为0，表明任务链表尚未有数据
   827                                  
   828                                      .searc:                             ;查找链表尾部
   829 00000376 89C2                            mov edx,eax 
   830 00000378 268B02                          mov eax,[es:edx+0x00]           
   831 0000037B 09C0                            or eax,eax
   832 0000037D 75F7                            jnz .searc                      ;当前结点的指针域是否为空，不为空则继续查找
   833 0000037F 26890A                          mov [es:edx+0x00],ecx           ;找到最后一个结点了，将新结点的起始线性地址赋值到最后一个结点的指针域
   834 00000382 EB06                            jmp .retpc
   835                                  
   836                                      .notcb:
   837 00000384 890D[8A0D0000]                  mov [tcb_chain],ecx             ;如果表头为空，则赋值当前链表起始线性地址
   838                                  
   839                                      .retpc:
   840 0000038A 07                              pop es
   841 0000038B 1F                              pop ds
   842 0000038C 5A                              pop edx
   843 0000038D 58                              pop eax
   844                                          
   845 0000038E C3                              ret
   846                                  
   847                                  ;-----------程序入口-----------------------------------------------------------------------
   848                                      start:
   849 0000038F B930000000                      mov ecx,core_data_seg_sel
   850 00000394 8ED9                            mov ds,ecx                              ;使ds指向内核数据段
   851                                          
   852 00000396 B908000000                      mov ecx,mem_0_4_gb_seg_sel              ;令ES指向4GB数据段 
   853 0000039B 8EC1                            mov es,ecx
   854                                  
   855 0000039D BB[5E040000]                    mov ebx,message_0
   856 000003A2 9A[00000000]2800                call sys_routine_seg_sel:put_string     ;显示消息
   857                                  
   858                                          ;显示处理器品牌信息 
   859 000003A9 B802000080                      mov eax,0x80000002
   860 000003AE 0FA2                            cpuid
   861 000003B0 A3[510D0000]                    mov [cpu_brand + 0x00],eax
   862 000003B5 891D[550D0000]                  mov [cpu_brand + 0x04],ebx
   863 000003BB 890D[590D0000]                  mov [cpu_brand + 0x08],ecx
   864 000003C1 8915[5D0D0000]                  mov [cpu_brand + 0x0c],edx
   865                                  
   866 000003C7 B803000080                      mov eax,0x80000003
   867 000003CC 0FA2                            cpuid
   868 000003CE A3[610D0000]                    mov [cpu_brand + 0x10],eax
   869 000003D3 891D[650D0000]                  mov [cpu_brand + 0x14],ebx
   870 000003D9 890D[690D0000]                  mov [cpu_brand + 0x18],ecx
   871 000003DF 8915[6D0D0000]                  mov [cpu_brand + 0x1c],edx
   872                                  
   873 000003E5 B804000080                      mov eax,0x80000004
   874 000003EA 0FA2                            cpuid
   875 000003EC A3[710D0000]                    mov [cpu_brand + 0x20],eax
   876 000003F1 891D[750D0000]                  mov [cpu_brand + 0x24],ebx
   877 000003F7 890D[790D0000]                  mov [cpu_brand + 0x28],ecx
   878 000003FD 8915[7D0D0000]                  mov [cpu_brand + 0x2c],edx
   879                                  
   880 00000403 BB[4C0D0000]                    mov ebx,cpu_brnd0                  
   881 00000408 9A[00000000]2800                call sys_routine_seg_sel:put_string
   882 0000040F BB[510D0000]                    mov ebx,cpu_brand
   883 00000414 9A[00000000]2800                call sys_routine_seg_sel:put_string
   884 0000041B BB[850D0000]                    mov ebx,cpu_brnd1
   885 00000420 9A[00000000]2800                call sys_routine_seg_sel:put_string
   886                                  
   887                                          ;准备打开分页机制
   888                                           
   889                                          ;创建系统内核的页目录表PDT
   890                                          ;页目录表清零，是为了将其P为置0 
   891 00000427 B900040000                      mov ecx,1024                       ;1024个页目录项
   892 0000042C BB00000200                      mov ebx,0x00020000                 ;页目录的物理地址
   893 00000431 31F6                            xor esi,esi
   894                                      .b1:
   895 00000433 26C7043300000000                mov dword [es:ebx+esi],0x00000000  ;页目录表项清零 
   896 0000043B 83C604                          add esi,4                          ;地址加4 
   897 0000043E E2F3                            loop .b1                           ;循环1024次
   898                                  
   899                                          ;在页目录内创建指向页目录自己的目录项，就是最后一项
   900 00000440 26C783FC0F00000300-             mov dword [es:ebx+4092],0x00020003 ;每项的高20位才是物理地址，低16位为控制为
   900 00000449 0200               
   901                                  
   902                                          ;在页目录内创建与线性地址0x00000000对应的目录项
   903 0000044B 26C70303100200                  mov dword [es:ebx+0],0x00021003    ;写入目录项（页表的物理地址和属性）,页表的物理地址为：0x00021000
   904                                  
   905                                          ;创建与上面那个目录项相对应的页表，初始化页表项 
   906 00000452 BB00100200                      mov ebx,0x00021000                 ;页表的物理地址 
   907 00000457 31C0                            xor eax,eax                        ;起始页的物理地址 
   908 00000459 31F6                            xor esi,esi
   909                                      .b2:
   910 0000045B 89C2                            mov edx,eax
   911 0000045D 83CA03                          or edx,0x00000003                  ;页的属性都为11，表示可读写以及不允许特权3访问的
   912 00000460 268914B3                        mov [es:ebx+esi*4],edx             ;登记页的物理地址
   913 00000464 0500100000                      add eax,0x1000                     ;下一个相邻页的物理地址 
   914 00000469 46                              inc esi                            ;下一页的索引 
   915 0000046A 81FE00010000                    cmp esi,256                        ;仅低端1MB内存对应的页才是有效的 
   916 00000470 7CE9                            jl .b2
   917                                      .b3:                                   ;其余的页表项置为无效
   918 00000472 26C704B300000000                mov dword [es:ebx+esi*4],0x00000000  
   919 0000047A 46                              inc esi
   920 0000047B 81FE00040000                    cmp esi,1024
   921 00000481 7CEF                            jl .b3 
   922                                  
   923                                          ;令CR3寄存器指向页目录，并正式开启分页功能
   924 00000483 B800000200                      mov eax,0x00020000
   925 00000488 0F22D8                          mov cr3,eax
   926                                  
   927                                          ;开启分页功能
   928 0000048B 0F20C0                          mov eax,cr0
   929 0000048E 0D00000080                      or eax,0x80000000                   ;cr0的最高位设置为1表示开启分页
   930 00000493 0F22C0                          mov cr0,eax
   931                                          
   932                                          ;为了让所有任务都能访问到内核空间，所以将线性地址0x80000000-0xFFFFFFFF设置为内核空间
   933                                          ;0x00000000-0x7FFFFFFF设置为用户空间。所以页目录表前半部分指向用户空间，后半部分指向内核空间
   934                                          ;在页目录内创建和线性地址0x80000000对应的目录项
   935 00000496 BB00F0FFFF                      mov ebx,0xfffff000                 ;页目录自己的线性地址
   936 0000049B BE00000080                      mov esi,0x80000000                 ;映射的起始地址
   937 000004A0 C1EE16                          shr esi,22                         ;线性地址的高10位是目录索引
   938 000004A3 C1E602                          shl esi,2                          ;在左移2位也就是乘以4，为目录表内偏移量，结果为0x800
   939 000004A6 26C7043303100200                mov dword [es:ebx+esi],0x00021003  ;写入目录项（页表的物理地址和属性）
   940                                                                             ;目标单元的线性地址为0xFFFFF200
   941                                          
   942                                          ;将GDT中的段描述符映射到线性地址0x80000000
   943 000004AE 0F0105[00000000]                sgdt [pgdt]                        ;将寄存器GDTR的值加载到内存pgdt出，此时给出的的pgdt是线性地址
   944                                  
   945 000004B5 8B1D[02000000]                  mov ebx,[pgdt+2]                   ;全局描述符表基地址
   946                                          ;依次修改内核栈段、视频缓冲区段等段的线性地址为高位地址
   947 000004BB 26814B1400000080                or dword [es:ebx+0x10+4],0x80000000
   948 000004C3 26814B1C00000080                or dword [es:ebx+0x18+4],0x80000000
   949 000004CB 26814B2400000080                or dword [es:ebx+0x20+4],0x80000000
   950 000004D3 26814B2C00000080                or dword [es:ebx+0x28+4],0x80000000
   951 000004DB 26814B3400000080                or dword [es:ebx+0x30+4],0x80000000
   952 000004E3 26814B3C00000080                or dword [es:ebx+0x38+4],0x80000000
   953                                  
   954 000004EB 8105[02000000]0000-             add dword [pgdt+2],0x80000000      ;GDTR也用的是线性地址 
   954 000004F3 0080               
   955                                  
   956 000004F5 0F0115[00000000]                lgdt [pgdt]                        ;将GDT新值写回PGDR寄存器
   957                                  
   958 000004FC EA[03050000]3800                jmp core_code_seg_sel:flush        ;使用jmp远端跳转是为了刷新段寄存器CS，启用高端线性地址  
   959                                  
   960                                      flush:
   961 00000503 B818000000                      mov eax,core_stack_seg_sel
   962 00000508 8ED0                            mov ss,eax                         ;刷新栈段寄存器
   963                                          
   964 0000050A B830000000                      mov eax,core_data_seg_sel
   965 0000050F 8ED8                            mov ds,eax
   966                                  
   967 00000511 BB[87040000]                    mov ebx,message_1
   968 00000516 9A[00000000]2800                call sys_routine_seg_sel:put_string
   969                                  
   970                                          ;以下开始安装调用门,特权级之间的控制转移必须使用门
   971 0000051D BF[46000000]                    mov edi,salt                            ;符号表起始位置
   972 00000522 B904000000                      mov ecx,salt_items                      ;符号表数量
   973                                  
   974                                      .b4:
   975 00000527 51                              push ecx                                ;压栈符号表的数量
   976 00000528 8B8700010000                    mov eax,[edi+256]                       ;该符号入口点的32位偏移地址
   977 0000052E 668B9F04010000                  mov bx,[edi+260]                        ;该符号入口点的段选择子
   978 00000535 66B900EC                        mov cx,1_11_0_1100_000_00000B           ;门属性，P=1,DPL=3。即只有特权级大于等于3的才能调用该门。0个参数，未使用栈传参
   979                                  
   980 00000539 9A[99010000]2800                call sys_routine_seg_sel:make_gate_descriptor   ;构建调用门描述符
   981 00000540 9A[22010000]2800                call sys_routine_seg_sel:set_up_gdt_descriptor  ;安装调用门描述符，返回ex=段描述符选择子
   982                                  
   983 00000547 66898F04010000                  mov [edi+260],cx                        ;将返回的门段选择子回填
   984 0000054E 81C706010000                    add edi,salt_item_len                   ;指向下一个符号
   985 00000554 59                              pop ecx
   986 00000555 E2D0                            loop .b4
   987                                  
   988                                          ;对门进行测试
   989 00000557 BB[CA040000]                    mov ebx,message_2
   990 0000055C FF1D[46010000]                  call far [salt_1+256]                   ;通过门显示信息,间接取得偏移量（会被忽略）与段选择子
   991                                  
   992                                          ;为程序管理器的TSS分配内存空间
   993 00000562 8B1D[8E0D0000]                  mov ebx,[core_next_laddr]               ;内核空间中下一个可分配的线性地址
   994 00000568 9A[E6010000]2800                call sys_routine_seg_sel:alloc_inst_a_page
   995 0000056F 8105[8E0D0000]0010-             add dword [core_next_laddr],4096        ;加上已分配的一个页的大小就是下一个要分配的内存地址
   995 00000577 0000               
   996                                  
   997                                          ;在程序管理器的TSS中设置必要的项目 
   998 00000579 2666C7030000                    mov word [es:ebx+0],0              ;反向链=0
   999                                  
  1000 0000057F 0F20D8                          mov eax,cr3
  1001 00000582 2689431C                        mov dword [es:ebx+28],eax          ;登记CR3(PDBR)
  1002                                  
  1003 00000586 2666C743600000                  mov word [es:ebx+96],0             ;没有LDT。处理器允许没有LDT的任务。
  1004 0000058D 2666C743640000                  mov word [es:ebx+100],0            ;T=0
  1005 00000594 2666C743666700                  mov word [es:ebx+102],103          ;没有I/O位图。0特权级事实上不需要。
  1006                                  
  1007                                          ;创建程序管理器的TSS描述符，并安装到GDT中 
  1008 0000059B 89D8                            mov eax,ebx                        ;TSS的起始线性地址
  1009 0000059D BB67000000                      mov ebx,103                        ;段长度（界限）
  1010 000005A2 B900894000                      mov ecx,0x00408900                 ;TSS描述符，特权级0
  1011 000005A7 9A[7E010000]2800                call sys_routine_seg_sel:make_seg_descriptor
  1012 000005AE 9A[22010000]2800                call sys_routine_seg_sel:set_up_gdt_descriptor
  1013 000005B5 66890D[960D0000]                mov [program_man_tss+4],cx         ;保存程序管理器的TSS描述符选择子 
  1014                                  
  1015                                          ;任务寄存器TR中的内容是任务存在的标志，该内容也决定了当前任务是谁。
  1016                                          ;下面的指令为当前正在执行的0特权级任务“程序管理器”后补手续（TSS）。
  1017 000005BC 0F00D9                          ltr cx
  1018                                  
  1019                                          ;现在可认为“程序管理器”任务正执行中
  1020                                  
  1021                                          ;创建用户任务的任务控制块 
  1022 000005BF 8B1D[8E0D0000]                  mov ebx,[core_next_laddr]
  1023 000005C5 9A[E6010000]2800                call sys_routine_seg_sel:alloc_inst_a_page  ;先分配一个内存页
  1024 000005CC 8105[8E0D0000]0010-             add dword [core_next_laddr],4096   
  1024 000005D4 0000               
  1025                                          
  1026 000005D6 26C7430600000000                mov dword [es:ebx+0x06],0          ;用户任务局部空间的分配从0开始。
  1027 000005DE 2666C7430AFFFF                  mov word [es:ebx+0x0a],0xffff      ;登记LDT初始的界限到TCB中
  1028 000005E5 89D9                            mov ecx,ebx
  1029 000005E7 E868FDFFFF                      call append_to_tcb_link            ;将此TCB添加到TCB链中 
  1030                                      
  1031 000005EC 6A32                            push dword 50                      ;用户程序位于逻辑50扇区
  1032 000005EE 51                              push ecx                           ;压入任务控制块起始线性地址 
  1033                                  
  1034 000005EF E850FAFFFF                      call load_relocate_program         
  1035                                      
  1036 000005F4 BB[0D050000]                    mov ebx,message_4
  1037 000005F9 9A[00000000]2800                call sys_routine_seg_sel:put_string
  1038                                          
  1039 00000600 26FF5914                        call far [es:ecx+0x14]             ;执行任务切换。
  1040                                          
  1041 00000604 BB[28050000]                    mov ebx,message_5
  1042 00000609 9A[00000000]2800                call sys_routine_seg_sel:put_string
  1043                                  
  1044 00000610 F4                              hlt
  1045                                  
  1046                                      core_code_end:
  1047                                  ;-----------尾部段-----------------------------------------------------------------------
  1048                                  section core_trail
  1049                                         core_end:   ;程序结尾标号，因为段没有定义vstart,所以该标号的偏移地址是从程序头开始的
