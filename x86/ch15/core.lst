     1                                  ;保护模式微型内核程序 
     2                                  
     3                                  ;以下常量定义部分。内核的大部分内容都应当固定 
     4                                  core_code_seg_sel     equ  0x38    ;内核代码段选择子
     5                                  core_data_seg_sel     equ  0x30    ;内核数据段选择子 
     6                                  sys_routine_seg_sel   equ  0x28    ;系统公共例程代码段的选择子 
     7                                  video_ram_seg_sel     equ  0x20    ;视频显示缓冲区的段选择子
     8                                  core_stack_seg_sel    equ  0x18    ;内核堆栈段选择子
     9                                  mem_0_4_gb_seg_sel    equ  0x08    ;整个0-4GB内存的段的选择子
    10                                  
    11                                  ;-----------内核头部-----------------------------------------------------------------------
    12                                  ;以下是系统核心的头部，用于加载核心程序 
    13 00000000 [00000000]              core_length dd core_end                         ;[0x00]内核总长度，双字，32位
    14 00000004 [00000000]              sys_routine_seg dd section.sys_routine.start    ;[0x04]系统通用库偏移地址
    15 00000008 [00000000]              core_data_seg dd section.core_data.start        ;[0x08]内核数据段偏移地址
    16 0000000C [00000000]              core_code_seg dd section.core_code.start        ;[0x0c]内核代码段偏移地址
    17 00000010 [E3030000]              core_entry dd start                             ;[0x10]内核代码段入口地址偏移量
    18 00000014 3800                               dw core_code_seg_sel                 ;[0x14]内核代码段选择子,16位的
    19                                  
    20                                  
    21                                  [bits 32]
    22                                  ;-----------系统通用库、提供字符串显示等功能-----------------------------------------------------------------------
    23                                  section sys_routine vstart=0
    24                                  ;-----------显示字符串--------------------------------------------------------------------
    25                                      put_string:                             ;显示0终止的字符串并移动光标 
    26                                                                              ;输入：DS:EBX=串地址
    27 00000000 51                              push ecx
    28                                      .getc:
    29 00000001 8A0B                            mov cl,[ebx]
    30 00000003 08C9                            or cl,cl
    31 00000005 7408                            jz .exit
    32 00000007 E805000000                      call put_char
    33 0000000C 43                              inc ebx
    34 0000000D EBF2                            jmp .getc
    35                                  
    36                                      .exit:
    37 0000000F 59                              pop ecx
    38 00000010 CB                              retf                               ;段间返回
    39                                  
    40                                      put_char:                               ;在当前光标处显示一个字符,并推进
    41                                                                      ;光标。仅用于段内调用 
    42                                                                      ;输入：CL=字符ASCII码 
    43 00000011 60                              pushad                        ;依次压入：EAX,ECX,EDX,EBX,ESP(初始值)，EBP,ESI,EDI     
    44                                  
    45                                          ;以下取当前光标位置
    46 00000012 66BAD403                        mov dx,0x3d4
    47 00000016 B00E                            mov al,0x0e
    48 00000018 EE                              out dx,al
    49 00000019 6642                            inc dx                             ;0x3d5
    50 0000001B EC                              in al,dx                           ;高字
    51 0000001C 88C4                            mov ah,al
    52                                  
    53 0000001E 664A                            dec dx                             ;0x3d4
    54 00000020 B00F                            mov al,0x0f
    55 00000022 EE                              out dx,al
    56 00000023 6642                            inc dx                             ;0x3d5
    57 00000025 EC                              in al,dx                           ;低字
    58 00000026 6689C3                          mov bx,ax                          ;BX=代表光标位置的16位数
    59                                  
    60 00000029 80F90D                          cmp cl,0x0d                        ;回车符？
    61 0000002C 750E                            jnz .put_0a
    62 0000002E 6689D8                          mov ax,bx
    63 00000031 B350                            mov bl,80
    64 00000033 F6F3                            div bl
    65 00000035 F6E3                            mul bl
    66 00000037 6689C3                          mov bx,ax
    67 0000003A EB60                            jmp .set_cursor
    68                                  
    69                                      .put_0a:
    70 0000003C 80F90A                          cmp cl,0x0a                        ;换行符？
    71 0000003F 7506                            jnz .put_other
    72 00000041 6683C350                        add bx,80
    73 00000045 EB15                            jmp .roll_screen
    74                                  
    75                                      .put_other:                               ;正常显示字符
    76 00000047 06                              push es
    77 00000048 B820000000                      mov eax,video_ram_seg_sel          ;0xb8000段的选择子
    78 0000004D 8EC0                            mov es,eax
    79 0000004F 66D1E3                          shl bx,1
    80 00000052 2667880F                        mov [es:bx],cl
    81 00000056 07                              pop es
    82                                  
    83                                          ;以下将光标位置推进一个字符
    84 00000057 66D1EB                          shr bx,1
    85 0000005A 6643                            inc bx
    86                                  
    87                                      .roll_screen:
    88 0000005C 6681FBD007                      cmp bx,2000                        ;光标超出屏幕？滚屏
    89 00000061 7C39                            jl .set_cursor
    90                                  
    91 00000063 1E                              push ds
    92 00000064 06                              push es
    93 00000065 B820000000                      mov eax,video_ram_seg_sel
    94 0000006A 8ED8                            mov ds,eax
    95 0000006C 8EC0                            mov es,eax
    96 0000006E FC                              cld
    97 0000006F BEA0000000                      mov esi,0xa0                       ;小心！32位模式下movsb/w/d 
    98 00000074 BF00000000                      mov edi,0x00                       ;使用的是esi/edi/ecx 
    99 00000079 B980070000                      mov ecx,1920
   100 0000007E F3A5                            rep movsd
   101 00000080 66BB000F                        mov bx,3840                        ;清除屏幕最底一行
   102 00000084 B950000000                  mov ecx,80                         ;32位程序应该使用ECX
   103                                      .cls:
   104 00000089 266667C7072007                  mov word[es:bx],0x0720
   105 00000090 6683C302                        add bx,2
   106 00000094 E2F3                            loop .cls
   107                                  
   108 00000096 07                              pop es
   109 00000097 1F                              pop ds
   110                                  
   111 00000098 66BB8007                        mov bx,1920
   112                                  
   113                                      .set_cursor:
   114 0000009C 66BAD403                        mov dx,0x3d4
   115 000000A0 B00E                            mov al,0x0e
   116 000000A2 EE                              out dx,al
   117 000000A3 6642                            inc dx                             ;0x3d5
   118 000000A5 88F8                            mov al,bh
   119 000000A7 EE                              out dx,al
   120 000000A8 664A                            dec dx                             ;0x3d4
   121 000000AA B00F                            mov al,0x0f
   122 000000AC EE                              out dx,al
   123 000000AD 6642                            inc dx                             ;0x3d5
   124 000000AF 88D8                            mov al,bl
   125 000000B1 EE                              out dx,al
   126                                  
   127 000000B2 61                              popad
   128 000000B3 C3                              ret 
   129                                  
   130                                  ;-----------从硬盘读取一个逻辑扇区----------------------------------------------------------------
   131                                      read_hard_disk_0:               ;使用的逻辑扇区编址方法为LBA28，也就是用28位来表示扇区号，每个扇区512字节
   132                                                                      ;eax=逻辑扇区号
   133                                                                      ;ds:ebx=目标缓冲区地址，将读到的硬盘数据放到ds段指定的内存中
   134                                  
   135 000000B4 50                              push eax                    ;将该过程会用到的寄存器入栈保存，函数返回时需要出栈还原
   136 000000B5 51                              push ecx
   137 000000B6 52                              push edx
   138                                  
   139 000000B7 50                              push eax                    ;在入栈一次eax的值
   140                                  
   141 000000B8 66BAF201                        mov dx,0x1f2                ;0x1f2端口表示要读取或写入的扇区数量，8位长度
   142 000000BC B001                            mov al,1                    ;每次要读取1个扇区
   143 000000BE EE                              out dx,al
   144                                  
   145                                          ;28位的扇区号太长，需要放到4个8位端口中，0x1f3存0-7位，0x1f4存8-15位，0x1f5存16-23位，
   146                                          ;0x1f6低4位存24-27位，第4位用于指示硬盘号，0是主盘、1是从盘,高三为全为1，表示LBA模式
   147 000000BF 6642                            inc dx                      ;0x1f3
   148 000000C1 58                              pop eax                     ;eax存放的是32位逻辑扇区号
   149 000000C2 EE                              out dx,al                   ;LBA地址7-0
   150                                  
   151 000000C3 6642                            inc dx                      ;0x1f4
   152 000000C5 B108                            mov cl,8
   153 000000C7 D3E8                            shr eax,cl
   154 000000C9 EE                              out dx,al                    ;LBA地址15~8
   155                                  
   156 000000CA 6642                            inc dx                       ;0x1f5
   157 000000CC D3E8                            shr eax,cl
   158 000000CE EE                              out dx,al                    ;LBA地址23~16
   159                                  
   160 000000CF 6642                            inc dx                      ;0x1f6
   161 000000D1 D3E8                            shr eax,cl
   162 000000D3 0CE0                            or al,0xe0                  ;因为al是1110 0000，ah高4位是0，0000 xxxx,使用or运算后al就是xxxx,表示LBA地址27-24
   163 000000D5 EE                              out dx,al
   164                                  
   165 000000D6 6642                            inc dx                      ;0x1f7，既是命令端口也是状态端口，0x20表示读，0x30表示写
   166 000000D8 B020                            mov al,0x20                 ;表示读硬盘
   167 000000DA EE                              out dx,al                  
   168                                  
   169                                          .waits:
   170 000000DB EC                                      in al,dx                    ;读取硬盘状态，第7位是1表示硬盘在忙碌，第3位是1表示已经读取完可以传输数据了
   171 000000DC 2488                                    and al,0x88                 ;二进制值：1000 1000，保留第7位与第3位的值，其他位全清0
   172 000000DE 3C08                                    cmp al,0x08                 ;二进制值：0000 1000，是否已经准备好了
   173 000000E0 75F9                                    jnz .waits                  ;尚未准备好，继续循环等待
   174                                  
   175 000000E2 B900010000                      mov ecx,256                  ;总共要读取的字数
   176 000000E7 66BAF001                        mov dx,0x1f0                 ;硬盘数据端口，长度为16位的
   177                                  
   178                                          .readw:
   179 000000EB 66ED                                    in ax,dx                    ;从硬盘读取一个字
   180 000000ED 668903                                  mov [ebx],ax                ;放到ds段内存中
   181 000000F0 83C302                                  add ebx,2                   ;bx偏移地址+2
   182 000000F3 E2F6                                    loop .readw                 ;先将ecx值减一，如果ecx的值不为0，则执行循环，否则向下继续执行
   183                                  
   184 000000F5 5A                              pop edx                      ;出栈，还原相关寄存器的原始值
   185 000000F6 59                              pop ecx
   186 000000F7 58                              pop eax
   187                                  
   188 000000F8 CB                              retf                         ;段间返回
   189                                  
   190                                  ;-----------输出调试信息-----------------------------------------------------------------------
   191                                      put_hex_dword:                      ;汇编语言程序是极难一次成功，而且调试非常困难。这个例程可以提供帮助 
   192                                                                          ;输入：EDX=要转换并显示的数字。在当前光标处以十六进制形式显示 ;一个双字并推进光标 
   193 000000F9 60                              pushad
   194 000000FA 1E                              push ds
   195                                  
   196 000000FB 66B83000                        mov ax,core_data_seg_sel           ;切换到核心数据段 
   197 000000FF 8ED8                            mov ds,ax
   198                                  
   199 00000101 BB[D5040000]                    mov ebx,bin_hex                    ;指向核心数据段内的转换表
   200 00000106 B908000000                      mov ecx,8
   201                                      .xlt:    
   202 0000010B C1C204                          rol edx,4
   203 0000010E 89D0                            mov eax,edx
   204 00000110 83E00F                          and eax,0x0000000f
   205 00000113 D7                              xlat
   206                                  
   207 00000114 51                              push ecx
   208 00000115 88C1                            mov cl,al                           
   209 00000117 E8F5FEFFFF                      call put_char
   210 0000011C 59                              pop ecx
   211                                  
   212 0000011D E2EC                            loop .xlt
   213                                  
   214 0000011F 1F                              pop ds
   215 00000120 61                              popad
   216 00000121 CB                              retf
   217                                  
   218                                  ;-----------分配内存-----------------------------------------------------------------------
   219                                      allocate_memory:
   220                                                                      ;输入ecx=希望分配的内存字节数，输出ecx=已分配的内存起始线性地址
   221 00000122 1E                              push ds
   222 00000123 50                              push eax
   223 00000124 53                              push ebx
   224                                  
   225 00000125 B830000000                      mov eax,core_data_seg_sel
   226 0000012A 8ED8                            mov ds,eax                  ;使ds指向4G内存选择子
   227                                  
   228 0000012C A1[06000000]                    mov eax,[ram_alloc]           
   229 00000131 01C8                            add eax,ecx                 ;下一次分配内存时的起始地址
   230                                  
   231                                          ;todo 这里应当有检测可用内存数量的指令
   232                                  
   233 00000133 8B0D[06000000]                  mov ecx,[ram_alloc]         ;返回分配的起始地址
   234                                  
   235 00000139 89C3                            mov ebx,eax
   236 0000013B 83E3FC                          and ebx,0xfffffffc
   237 0000013E 83E304                          and ebx,4                   ;强制4字节对齐
   238 00000141 A903000000                      test eax,0x00000003         ;测试下一次分配内存的起始地址是不是4字节对齐的
   239 00000146 0F45C3                          cmovnz eax,ebx              ;如果没有对齐，则强制对齐。cmovnz指令可以避免控制转移
   240 00000149 A3[06000000]                    mov [ram_alloc],eax         ;下次从该地址分配内存 
   241                                  
   242 0000014E 5B                              pop ebx
   243 0000014F 58                              pop eax
   244 00000150 1F                              pop ds
   245                                  
   246 00000151 CB                              retf
   247                                  
   248                                  ;-----------在GDT内安装一个新的描述符--------------------------------------------------------------------
   249                                      set_up_gdt_descriptor:             ;输入edx:eax=描述符，输出cx=描述符选择子
   250 00000152 50                              push eax
   251 00000153 53                              push ebx
   252 00000154 52                              push edx
   253                                  
   254 00000155 1E                              push ds
   255 00000156 06                              push es
   256                                  
   257 00000157 BB30000000                      mov ebx,core_data_seg_sel          ;切换到核心数据段
   258 0000015C 8EDB                            mov ds,ebx
   259                                  
   260 0000015E 0F0105[00000000]                sgdt [pgdt]                        ;读取寄存器GDTR，存放到内存
   261                                  
   262 00000165 BB08000000                      mov ebx,mem_0_4_gb_seg_sel
   263 0000016A 8EC3                            mov es,ebx
   264                                  
   265 0000016C 0FB71D[00000000]                movzx ebx,word [pgdt]              ;GDT界限 
   266 00000173 6643                            inc bx                             ;GDT总字节数，也是下一个描述符偏移 
   267 00000175 031D[02000000]                  add ebx,[pgdt+2]                   ;下一个描述符的线性地址 
   268                                  
   269 0000017B 268903                          mov [es:ebx],eax
   270 0000017E 26895304                        mov [es:ebx+4],edx
   271                                  
   272 00000182 668305[00000000]08              add word [pgdt],8                  ;增加一个描述符的大小   
   273                                  
   274 0000018A 0F0115[00000000]                lgdt [pgdt]                        ;对GDT的更改生效 
   275                                          
   276 00000191 66A1[00000000]                  mov ax,[pgdt]                      ;得到GDT界限值
   277 00000197 6631D2                          xor dx,dx
   278 0000019A 66BB0800                        mov bx,8
   279 0000019E 66F7F3                          div bx                             ;除以8，去掉余数
   280 000001A1 6689C1                          mov cx,ax                          
   281 000001A4 66C1E103                        shl cx,3                           ;将索引号移到正确位置 
   282                                  
   283 000001A8 07                              pop es
   284 000001A9 1F                              pop ds
   285                                  
   286 000001AA 5A                              pop edx
   287 000001AB 5B                              pop ebx
   288 000001AC 58                              pop eax
   289                                  
   290 000001AD CB                              retf        
   291                                  
   292                                  ;-----------构造描述符--------------------------------------------------------------------
   293                                      make_seg_descriptor:            ;输入：eax=线性基址，ebx=段界限,ecx=属性（各属性位都在原始位置，其它没用到的位置0） 
   294                                                                      ;输出edx:eax=完整的描述符
   295 000001AE 89C2                            mov edx,eax
   296 000001B0 C1E010                          shl eax,16                  ;描述符低32位中的高16位是基地址部分，所以左移16位使其基地址部分就位
   297 000001B3 6609D8                          or ax,bx                    ;低16位是段界限，取的段界限
   298                                  
   299 000001B6 81E20000FFFF                    and edx,0xffff0000          ;清除低16位
   300 000001BC C1C208                          rol edx,8                   ;edx循环左移8位，循环左移会将左移出的位放到右边。这样edx中低8位的值就是原先高8位的值
   301 000001BF 0FCA                            bswap edx                   ;字节交换指令。装配基址的31~24和23~16  (80486+)
   302                                  
   303 000001C1 6631DB                          xor bx,bx
   304 000001C4 09DA                            or edx,ebx                  ;装配段界限的高4位
   305                                          
   306 000001C6 09CA                            or edx,ecx                  ;装配段属性
   307                                  
   308 000001C8 CB                              retf
   309                                  
   310                                  ;-----------构造门的描述符（调用门等）--------------------------------------------------------------------
   311                                      make_gate_descriptor:           ;输入：eax=门代码在段内的偏移地址，bx=门代码的段选择子，cx=门属性
   312                                                                      ;输出：edx:eax=完整的描述符
   313 000001C9 53                              push ebx
   314 000001CA 51                              push ecx
   315                                  
   316 000001CB 89C2                            mov edx,eax
   317 000001CD 81E20000FFFF                    and edx,0xffff0000          ;得到偏移地址高16位 
   318 000001D3 6609CA                          or  dx,cx                   ;组装属性部分到edx
   319                                  
   320 000001D6 25FFFF0000                      and eax,0x0000ffff          ;得到偏移地址低16位
   321 000001DB C1E310                          shl ebx,16                  ;左移16位使段选择子位于它的高16位        
   322 000001DE 09D8                            or eax,ebx                  ;组装段选择子部分
   323                                      
   324 000001E0 59                              pop ecx
   325 000001E1 5B                              pop ebx
   326                                      
   327 000001E2 CB                              retf   
   328                                  
   329                                  ;-----------终止当前任务--------------------------------------------------------------------
   330                                      terminate_current_task:
   331                                                                             ;注意，执行此例程时，当前任务仍在运行中。此例程其实也是当前任务的一部分
   332 000001E3 9C                              pushfd                             ;EFLAGS寄存器内容入栈
   333 000001E4 8B1424                          mov edx,[esp]                      ;获得EFLAGS寄存器内容
   334 000001E7 83C404                          add esp,4                          ;恢复堆栈指针
   335                                  
   336 000001EA B830000000                      mov eax,core_data_seg_sel
   337 000001EF 8ED8                            mov ds,eax                         ;使ds指向内核数据段
   338                                  
   339 000001F1 66F7C20040                      test dx,0100_0000_0000_0000B       ;测试NT位
   340 000001F6 7512                            jnz .b1                            ;当前任务是嵌套的，到.b1执行iretd 
   341 000001F8 BB[EF0E0000]                    mov ebx,core_msg1                  ;当前任务不是嵌套的，直接切换到 
   342 000001FD 9A[00000000]2800                call sys_routine_seg_sel:put_string
   343 00000204 FF2D[2B0D0000]                  jmp far [prgman_tss]               ;程序管理器任务   
   344                                      .b1: 
   345 0000020A BB[620E0000]                    mov ebx,core_msg0
   346 0000020F 9A[00000000]2800                call sys_routine_seg_sel:put_string
   347 00000216 CF                              iretd                              ;从中断返回，依次从栈中弹出IP、CS、FLAGS内容 
   348                                          
   349                                      sys_routine_end:
   350                                  
   351                                  ;-----------内核数据段-----------------------------------------------------------------------
   352                                  section core_data vstart=0                   
   353 00000000 0000                        pgdt            dw  0             ;用于设置和修改GDT 
   354 00000002 00000000                                    dd  0
   355                                  
   356 00000006 00001000                    ram_alloc       dd  0x00100000    ;下次分配内存时的起始地址
   357                                  
   358                                      ;符号地址检索表
   359                                      salt:
   360 0000000A 405072696E74537472-             salt_1          db  '@PrintString'      ;打印字符串函数别名
   360 00000013 696E67             
   361 00000016 00<rep F4h>                                 times 256-($-salt_1) db 0   ;不足256长度的补0
   362 0000010A [00000000]                                      dd  put_string          ;函数偏移量
   363 0000010E 2800                                            dw  sys_routine_seg_sel ;公共库代码段选择子，内核执行时会使用调用门段选择子替换
   364                                  
   365 00000110 40526561644469736B-             salt_2          db  '@ReadDiskData'
   365 00000119 44617461           
   366 0000011D 00<rep F3h>                                 times 256-($-salt_2) db 0
   367 00000210 [B4000000]                                      dd  read_hard_disk_0
   368 00000214 2800                                            dw  sys_routine_seg_sel
   369                                  
   370 00000216 405072696E7444776F-             salt_3          db  '@PrintDwordAsHexString'
   370 0000021F 726441734865785374-
   370 00000228 72696E67           
   371 0000022C 00<rep EAh>                                 times 256-($-salt_3) db 0
   372 00000316 [F9000000]                                      dd  put_hex_dword
   373 0000031A 2800                                            dw  sys_routine_seg_sel
   374                                  
   375 0000031C 405465726D696E6174-             salt_4          db  '@TerminateProgram'
   375 00000325 6550726F6772616D   
   376 0000032D 00<rep EFh>                                 times 256-($-salt_4) db 0
   377 0000041C [E3010000]                                      dd  terminate_current_task
   378 00000420 2800                                            dw  sys_routine_seg_sel
   379                                  
   380                                          salt_item_len   equ $-salt_4                ;单个符号表大小，262字节
   381                                          salt_items      equ ($-salt)/salt_item_len  ;符号表数量
   382                                  
   383 00000422 2020496620796F7520-         message_1       db  '  If you seen this message,that means we '
   383 0000042B 7365656E2074686973-
   383 00000434 206D6573736167652C-
   383 0000043D 74686174206D65616E-
   383 00000446 7320776520         
   384 0000044B 617265206E6F772069-                         db  'are now in protect mode,and the system '
   384 00000454 6E2070726F74656374-
   384 0000045D 206D6F64652C616E64-
   384 00000466 207468652073797374-
   384 0000046F 656D20             
   385 00000472 636F7265206973206C-                         db  'core is loaded,and the video display '
   385 0000047B 6F616465642C616E64-
   385 00000484 207468652076696465-
   385 0000048D 6F20646973706C6179-
   385 00000496 20                 
   386 00000497 726F7574696E652077-                         db  'routine works perfectly.',0x0d,0x0a,0
   386 000004A0 6F726B732070657266-
   386 000004A9 6563746C792E0D0A00 
   387                                  
   388 000004B2 202053797374656D20-         message_2       db  '  System wide CALL-GATE mounted.',0x0d,0x0a,0
   388 000004BB 776964652043414C4C-
   388 000004C4 2D47415445206D6F75-
   388 000004CD 6E7465642E0D0A00   
   389                                  
   390 000004D5 303132333435363738-         bin_hex         db '0123456789ABCDEF'
   390 000004DE 39414243444546     
   391                                                                      ;put_hex_dword子过程用的查找表 
   392                                  
   393 000004E5 00<rep 800h>                core_buf   times 2048 db 0         ;内核用的缓冲区
   394                                  
   395 00000CE5 00000000                    esp_pointer     dd 0              ;内核用来临时保存自己的栈指针     
   396                                  
   397 00000CE9 0D0A202000                  cpu_brnd0       db 0x0d,0x0a,'  ',0
   398 00000CEE 00<rep 34h>                 cpu_brand  times 52 db 0
   399 00000D22 0D0A0D0A00                  cpu_brnd1       db 0x0d,0x0a,0x0d,0x0a,0
   400                                  
   401                                      ;任务控制块链表头
   402 00000D27 00000000                    tcb_chain       dd  0
   403                                  
   404                                      ;程序管理器的任务信息 
   405 00000D2B 00000000                    prgman_tss      dd  0             ;程序管理器的TSS基地址
   406 00000D2F 0000                                        dw  0             ;程序管理器的TSS描述符选择子 
   407                                  
   408 00000D31 0D0A                        prgman_msg1     db  0x0d,0x0a
   409 00000D33 5B50726F6772616D20-                         db  '[Program Manager]: Hello! I am Program Manager,'
   409 00000D3C 4D616E616765725D3A-
   409 00000D45 2048656C6C6F212049-
   409 00000D4E 20616D2050726F6772-
   409 00000D57 616D204D616E616765-
   409 00000D60 722C               
   410 00000D62 72756E206174204350-                         db  'run at CPL=0.Now,create user task and switch '
   410 00000D6B 4C3D302E4E6F772C63-
   410 00000D74 726561746520757365-
   410 00000D7D 72207461736B20616E-
   410 00000D86 642073776974636820 
   411 00000D8F 746F20697420627920-                         db  'to it by the CALL instruction...',0x0d,0x0a,0
   411 00000D98 7468652043414C4C20-
   411 00000DA1 696E73747275637469-
   411 00000DAA 6F6E2E2E2E0D0A00   
   412                                              
   413 00000DB2 0D0A                        prgman_msg2     db  0x0d,0x0a
   414 00000DB4 5B50726F6772616D20-                         db  '[Program Manager]: I am glad to regain control.'
   414 00000DBD 4D616E616765725D3A-
   414 00000DC6 204920616D20676C61-
   414 00000DCF 6420746F2072656761-
   414 00000DD8 696E20636F6E74726F-
   414 00000DE1 6C2E               
   415 00000DE3 4E6F772C6372656174-                         db  'Now,create another user task and switch to '
   415 00000DEC 6520616E6F74686572-
   415 00000DF5 207573657220746173-
   415 00000DFE 6B20616E6420737769-
   415 00000E07 74636820746F20     
   416 00000E0E 697420627920746865-                         db  'it by the JMP instruction...',0x0d,0x0a,0
   416 00000E17 204A4D5020696E7374-
   416 00000E20 72756374696F6E2E2E-
   416 00000E29 2E0D0A00           
   417                                              
   418 00000E2D 0D0A                        prgman_msg3     db  0x0d,0x0a
   419 00000E2F 5B50726F6772616D20-                         db  '[Program Manager]: I am gain control again,'
   419 00000E38 4D616E616765725D3A-
   419 00000E41 204920616D20676169-
   419 00000E4A 6E20636F6E74726F6C-
   419 00000E53 20616761696E2C     
   420 00000E5A 48414C542E2E2E00                            db  'HALT...',0
   421                                  
   422 00000E62 0D0A                        core_msg0       db  0x0d,0x0a
   423 00000E64 5B53797374656D2043-                         db  '[System Core]: Uh...This task initiated with '
   423 00000E6D 6F72655D3A2055682E-
   423 00000E76 2E2E54686973207461-
   423 00000E7F 736B20696E69746961-
   423 00000E88 746564207769746820 
   424 00000E91 43414C4C20696E7374-                         db  'CALL instruction or an exeception/ interrupt,'
   424 00000E9A 72756374696F6E206F-
   424 00000EA3 7220616E2065786563-
   424 00000EAC 657074696F6E2F2069-
   424 00000EB5 6E746572727570742C 
   425 00000EBE 73686F756C64207573-                         db  'should use IRETD instruction to switch back...'
   425 00000EC7 652049524554442069-
   425 00000ED0 6E737472756374696F-
   425 00000ED9 6E20746F2073776974-
   425 00000EE2 6368206261636B2E2E-
   425 00000EEB 2E                 
   426 00000EEC 0D0A00                                      db  0x0d,0x0a,0
   427                                  
   428 00000EEF 0D0A                        core_msg1       db  0x0d,0x0a
   429 00000EF1 5B53797374656D2043-                         db  '[System Core]: Uh...This task initiated with '
   429 00000EFA 6F72655D3A2055682E-
   429 00000F03 2E2E54686973207461-
   429 00000F0C 736B20696E69746961-
   429 00000F15 746564207769746820 
   430 00000F1E 4A4D5020696E737472-                         db  'JMP instruction,  should switch to Program '
   430 00000F27 756374696F6E2C2020-
   430 00000F30 73686F756C64207377-
   430 00000F39 6974636820746F2050-
   430 00000F42 726F6772616D20     
   431 00000F49 4D616E616765722064-                         db  'Manager directly by the JMP instruction...'
   431 00000F52 69726563746C792062-
   431 00000F5B 7920746865204A4D50-
   431 00000F64 20696E737472756374-
   431 00000F6D 696F6E2E2E2E       
   432 00000F73 0D0A00                                      db  0x0d,0x0a,0
   433                                      core_data_end:
   434                                  
   435                                  ;-----------内核代码段-----------------------------------------------------------------------
   436                                  section core_code vstart=0
   437                                  ;-----------在LDT内安装一个新的描述符-----------------------------------------------------------------------
   438                                      fill_descriptor_in_ldt:             ;输入：edx:eax=完整描述符，ebx=TCB基地址
   439                                                                          ;输出：cx=描述符选择子
   440 00000000 50                              push eax
   441 00000001 52                              push edx
   442 00000002 57                              push edi
   443 00000003 1E                              push ds
   444                                  
   445 00000004 B908000000                      mov ecx,mem_0_4_gb_seg_sel
   446 00000009 8ED9                            mov ds,ecx                      ;使ds指向4G数据段
   447                                  
   448 0000000B 8B7B0C                          mov edi,[ebx+0x0c]              ;获得LDT基地址
   449                                  
   450 0000000E 31C9                            xor ecx,ecx
   451 00000010 668B4B0A                        mov cx,[ebx+0x0a]               ;获得LDT界限
   452 00000014 6641                            inc cx                          ;LDT的总字节数，即新描述符偏移地址
   453                                  
   454 00000016 89040F                          mov [edi+ecx+0x00],eax
   455 00000019 89540F04                        mov [edi+ecx+0x04],edx          ;安装描述符
   456                                  
   457 0000001D 6683C108                        add cx,8                           
   458 00000021 6649                            dec cx                          ;得到新的LDT界限值 
   459                                  
   460 00000023 66894B0A                        mov [ebx+0x0a],cx               ;更新LDT界限值到TCB
   461                                  
   462 00000027 6689C8                          mov ax,cx
   463 0000002A 6631D2                          xor dx,dx
   464 0000002D 66B90800                        mov cx,8
   465 00000031 66F7F1                          div cx                          ;除以8，商就是新描述符的索引
   466                                  
   467 00000034 6689C1                          mov cx,ax
   468 00000037 66C1E103                        shl cx,3                         ;左移3位，并且
   469 0000003B 6683C904                        or cx,0000_0000_0000_0100B       ;使TI位=1，指向LDT，最后使RPL=00 
   470                                  
   471 0000003F 1F                              pop ds
   472 00000040 5F                              pop edi
   473 00000041 5A                              pop edx
   474 00000042 58                              pop eax
   475                                      
   476 00000043 C3                              ret
   477                                  
   478                                  ;-----------加载并重定位用户程序-----------------------------------------------------------------------
   479                                      load_relocate_program:              ;输入push:逻辑扇区号，push:任务控制块起始地址
   480                                                                          ;调用该函数时会先压入EIP
   481 00000044 60                              pushad                          ;依次压入：EAX,ECX,EDX,EBX,ESP(初始值)，EBP,ESI,EDI,共8个寄存器
   482 00000045 1E                              push ds
   483 00000046 06                              push es                         
   484                                  
   485 00000047 89E5                            mov ebp,esp                     ;使栈基址寄存器指向初始栈地址
   486 00000049 B908000000                      mov ecx,mem_0_4_gb_seg_sel
   487 0000004E 8EC1                            mov es,ecx                      ;es指向4G数据段
   488                                  
   489 00000050 8B752C                          mov esi,[ebp+11*4]              ;因为又压入了11个寄存器的值，所以取任务控制块起始地址需要从11偏移量开始
   490                                                                          ;用ebp寻址时，会使用段寄存器ss
   491                                  
   492                                          ;以下申请创建LDT局部描述符表内存
   493 00000053 B9A0000000                      mov ecx,160                     ;允许安装20个LDT,每个描述符占8字节
   494 00000058 9A[22010000]2800                call sys_routine_seg_sel:allocate_memory    ;分配内存，返回ecx=已分配起始内存地址
   495 0000005F 26894E0C                        mov [es:esi+0x0c],ecx           ;登记LDT基地址到TCB中
   496 00000063 2666C7460AFFFF                  mov word [es:esi+0x0a],0xffff   ;登记LDT初始的界限到TCB中 
   497                                  
   498                                          ;以下开始加载用户程序
   499 0000006A B830000000                      mov eax,core_data_seg_sel
   500 0000006F 8ED8                            mov ds,eax                      ;使ds指向内核数据段
   501                                  
   502 00000071 8B4530                          mov eax,[ebp+12*4]              ;读取起始扇区号
   503 00000074 BB[E5040000]                    mov ebx,core_buf                ;用于读取磁盘数据的内核缓冲区
   504 00000079 9A[B4000000]2800                call sys_routine_seg_sel:read_hard_disk_0
   505                                  
   506                                          ;以下判断整个程序有多大
   507 00000080 A1[E5040000]                    mov eax,[core_buf]                  ;程序尺寸
   508 00000085 89C3                            mov ebx,eax
   509 00000087 81E300FEFFFF                    and ebx,0xfffffe00                  ;使之512字节对齐（能被512整除的数低 
   510 0000008D 81C300020000                    add ebx,512                         ;9位都为0 
   511 00000093 A9FF010000                      test eax,0x000001ff                 ;程序的大小正好是512的倍数吗? 
   512 00000098 0F45C3                          cmovnz eax,ebx                      ;不是。使用凑整的结果
   513                                  
   514 0000009B 89C1                            mov ecx,eax                         ;程序的大小
   515 0000009D 9A[22010000]2800                call sys_routine_seg_sel:allocate_memory    ;分配内存，返回ecx=已分配起始内存地址
   516 000000A4 26894E06                        mov [es:esi+0x06],ecx               ;登记用户程序起始线性地址到TCB中
   517                                  
   518 000000A8 89CB                            mov ebx,ecx                         ;ebx -> 申请到的内存首地址
   519 000000AA 31D2                            xor edx,edx
   520 000000AC B900020000                      mov ecx,512
   521 000000B1 F7F1                            div ecx
   522 000000B3 89C1                            mov ecx,eax                         ;总扇区数 
   523                                      
   524 000000B5 B808000000                      mov eax,mem_0_4_gb_seg_sel          ;切换DS到0-4GB的段
   525 000000BA 8ED8                            mov ds,eax
   526                                  
   527 000000BC 8B4530                          mov eax,[ebp+12*4]                  ;起始扇区号 
   528                                      .b1:
   529 000000BF 9A[B4000000]2800                call sys_routine_seg_sel:read_hard_disk_0         ;读取剩余部分
   530 000000C6 40                              inc eax
   531 000000C7 E2F6                            loop .b1                                          ;先将ecx值减一，如果ecx的值不为0，则执行循环，否则向下继续执行  
   532                                  
   533 000000C9 268B7E06                        mov edi,[es:esi+0x06]                             ;获得程序加载基地址    
   534                                  
   535                                          
   536                                          ;建立程序头部段描述符
   537 000000CD 89F8                            mov eax,edi                        ;程序头部起始线性地址
   538 000000CF 8B5F04                          mov ebx,[edi+0x04]                 ;段长度
   539 000000D2 4B                              dec ebx                            ;段界限
   540 000000D3 B900F24000                      mov ecx,0x0040f200                 ;字节粒度的数据段描述符，特权级3 
   541 000000D8 9A[AE010000]2800                call sys_routine_seg_sel:make_seg_descriptor
   542                                  
   543                                          ;安装头部段描述符到LDT中
   544 000000DF 89F3                            mov ebx,esi                         ;TCB基地址                              
   545 000000E1 E81AFFFFFF                      call fill_descriptor_in_ldt         ;安装头部段描述符到LDT中
   546                                  
   547 000000E6 6683C903                        or cx,0000_0000_0000_0011B         ;设置选择子的特权级为3
   548 000000EA 2666894E44                      mov [es:esi+0x44],cx               ;登记程序头部段选择子到TCB 
   549 000000EF 66894F04                        mov [edi+0x04],cx                  ;和用户程序头部内 
   550                                  
   551                                          ;建立程序代码段描述符
   552 000000F3 89F8                            mov eax,edi
   553 000000F5 034714                          add eax,[edi+0x14]                 ;代码起始线性地址
   554 000000F8 8B5F18                          mov ebx,[edi+0x18]                 ;段长度
   555 000000FB 4B                              dec ebx                            ;段界限
   556 000000FC B900F84000                      mov ecx,0x0040f800                 ;字节粒度的代码段描述符，特权级3
   557 00000101 9A[AE010000]2800                call sys_routine_seg_sel:make_seg_descriptor
   558 00000108 89F3                            mov ebx,esi                        ;TCB的基地址
   559 0000010A E8F1FEFFFF                      call fill_descriptor_in_ldt
   560 0000010F 6683C903                        or cx,0000_0000_0000_0011B         ;设置选择子的特权级为3
   561 00000113 66894F14                        mov [edi+0x14],cx                  ;登记代码段选择子到头部
   562                                  
   563                                          ;建立程序数据段描述符
   564 00000117 89F8                            mov eax,edi
   565 00000119 03471C                          add eax,[edi+0x1c]                 ;数据段起始线性地址
   566 0000011C 8B5F20                          mov ebx,[edi+0x20]                 ;段长度
   567 0000011F 4B                              dec ebx                            ;段界限 
   568 00000120 B900F24000                      mov ecx,0x0040f200                 ;字节粒度的数据段描述符，特权级3
   569 00000125 9A[AE010000]2800                call sys_routine_seg_sel:make_seg_descriptor
   570 0000012C 89F3                            mov ebx,esi                        ;TCB的基地址
   571 0000012E E8CDFEFFFF                      call fill_descriptor_in_ldt
   572 00000133 6683C903                        or cx,0000_0000_0000_0011B         ;设置选择子的特权级为3
   573 00000137 66894F1C                        mov [edi+0x1c],cx                  ;登记数据段选择子到头部
   574                                  
   575                                          ;建立程序堆栈段描述符
   576 0000013B 8B4F0C                          mov ecx,[edi+0x0c]                 ;4KB的倍率 
   577 0000013E BBFFFF0F00                      mov ebx,0x000fffff
   578 00000143 29CB                            sub ebx,ecx                        ;得到段界限
   579 00000145 B800100000                      mov eax,4096                        
   580 0000014A F7E1                            mul ecx                         
   581 0000014C 89C1                            mov ecx,eax                        ;准备为堆栈分配内存 
   582 0000014E 9A[22010000]2800                call sys_routine_seg_sel:allocate_memory
   583 00000155 01C8                            add eax,ecx                        ;得到堆栈的高端物理地址 
   584 00000157 B900F6C000                      mov ecx,0x00c0f600                 ;字节粒度的堆栈段描述符，特权级3
   585 0000015C 9A[AE010000]2800                call sys_routine_seg_sel:make_seg_descriptor
   586 00000163 89F3                            mov ebx,esi                        ;TCB的基地址
   587 00000165 E896FEFFFF                      call fill_descriptor_in_ldt
   588 0000016A 6683C903                        or cx,0000_0000_0000_0011B         ;设置选择子的特权级为3
   589 0000016E 66894F08                        mov [edi+0x08],cx                  ;登记堆栈段选择子到头部
   590                                  
   591                                          ;重定位SALT 
   592 00000172 B808000000                      mov eax,mem_0_4_gb_seg_sel         ;这里和前一章不同，头部段描述符已安装，但还没有生效，故只能通过4GB段访问用户程序头部  
   593 00000177 8EC0                            mov es,eax
   594                                  
   595 00000179 B830000000                      mov eax,core_data_seg_sel
   596 0000017E 8ED8                            mov ds,eax
   597                                      
   598 00000180 FC                              cld
   599                                  
   600 00000181 268B4F24                        mov ecx,[es:edi+0x24]              ;U-SALT条目数(通过访问4GB段取得) 
   601 00000185 83C728                          add edi,0x28                       ;U-SALT在4GB段内的偏移 
   602                                  
   603                                      .b2: 
   604 00000188 51                              push ecx
   605 00000189 57                              push edi
   606                                  
   607 0000018A B904000000                      mov ecx,salt_items                  ;内核符号表数量
   608 0000018F BE[0A000000]                    mov esi,salt                        ;源索引寄存器，内核符号表起始地址
   609                                      .b3:
   610 00000194 57                              push edi
   611 00000195 56                              push esi
   612 00000196 51                              push ecx
   613                                  
   614 00000197 B940000000                      mov ecx,64                         ;检索表中，每条目的比较次数 
   615 0000019C F3A7                            repe cmpsd                         ;每次比较4字节，repe是连续比较直到ecx为0，如果字符相等则重复比较 
   616 0000019E 7519                            jnz .b4
   617 000001A0 8B06                            mov eax,[esi]                      ;若匹配，则esi恰好指向其后的地址
   618 000001A2 26898700FFFFFF                  mov [es:edi-256],eax               ;将字符串改写成偏移地址 
   619 000001A9 668B4604                        mov ax,[esi+4]
   620 000001AD 6683C803                        or ax,0000000000000011B            ;以用户程序自己的特权级使用调用门故RPL=3 
   621                                  
   622 000001B1 2666898704FFFFFF                mov [es:edi-252],ax                ;回填调用门选择子 
   623                                      .b4:
   624                                        
   625 000001B9 59                              pop ecx
   626 000001BA 5E                              pop esi
   627 000001BB 81C606010000                    add esi,salt_item_len
   628 000001C1 5F                              pop edi                            ;从头比较 
   629 000001C2 E2D0                            loop .b3
   630                                      
   631 000001C4 5F                              pop edi
   632 000001C5 81C700010000                    add edi,256
   633 000001CB 59                              pop ecx
   634 000001CC E2BA                            loop .b2
   635                                  
   636 000001CE 8B752C                          mov esi,[ebp+11*4]                 ;从堆栈中取得TCB的基地址
   637                                  
   638                                          ;创建0特权级栈
   639 000001D1 B900100000                      mov ecx,4096                       ;栈大小为4kb
   640 000001D6 89C8                            mov eax,ecx                        ;为生成堆栈高端地址做准备
   641 000001D8 26894E1A                        mov [es:esi+0x1a],ecx              
   642 000001DC 26C16E1A0C                      shr dword [es:esi+0x1a],12         ;登记0特权级堆栈尺寸到TCB，逻辑右移12位，相当于除以4096
   643 000001E1 9A[22010000]2800                call sys_routine_seg_sel:allocate_memory    ;分配内存，返回ecx=已分配起始内存地址
   644 000001E8 01C8                            add eax,ecx                        ;堆栈必须使用高端地址为基地址   
   645 000001EA 2689461E                        mov [es:esi+0x1e],eax              ;登记0特权级堆栈基地址到TCB 
   646 000001EE BBFEFF0F00                      mov ebx,0xffffe                    ;段长度（界限）
   647 000001F3 B90096C000                      mov ecx,0x00c09600                 ;4KB粒度，读写，特权级0
   648 000001F8 9A[AE010000]2800                call sys_routine_seg_sel:make_seg_descriptor;构建段描述符
   649 000001FF 89F3                            mov ebx,esi                        ;TCB的基地址
   650 00000201 E8FAFDFFFF                      call fill_descriptor_in_ldt        ;安装段描述符到LDT中
   651                                          ;or cx,0000_0000_0000_0000         ;设置选择子的特权级为0
   652 00000206 2666894E22                      mov [es:esi+0x22],cx               ;登记0特权级堆栈选择子到TCB
   653 0000020B 26C7462400000000                mov dword [es:esi+0x24],0          ;登记0特权级堆栈初始ESP到TCB
   654                                  
   655                                          ;创建1特权级堆栈
   656 00000213 B900100000                      mov ecx,4096
   657 00000218 89C8                            mov eax,ecx                        ;为生成堆栈高端地址做准备
   658 0000021A 26894E28                        mov [es:esi+0x28],ecx
   659 0000021E 26C16E280C                      shr dword [es:esi+0x28],12               ;登记1特权级堆栈尺寸到TCB
   660 00000223 9A[22010000]2800                call sys_routine_seg_sel:allocate_memory
   661 0000022A 01C8                            add eax,ecx                        ;堆栈必须使用高端地址为基地址
   662 0000022C 2689462C                        mov [es:esi+0x2c],eax              ;登记1特权级堆栈基地址到TCB
   663 00000230 BBFEFF0F00                      mov ebx,0xffffe                    ;段长度（界限）
   664 00000235 B900B6C000                      mov ecx,0x00c0b600                 ;4KB粒度，读写，特权级1
   665 0000023A 9A[AE010000]2800                call sys_routine_seg_sel:make_seg_descriptor
   666 00000241 89F3                            mov ebx,esi                        ;TCB的基地址
   667 00000243 E8B8FDFFFF                      call fill_descriptor_in_ldt
   668 00000248 6683C901                        or cx,0000_0000_0000_0001          ;设置选择子的特权级为1
   669 0000024C 2666894E30                      mov [es:esi+0x30],cx               ;登记1特权级堆栈选择子到TCB
   670 00000251 26C7463200000000                mov dword [es:esi+0x32],0          ;登记1特权级堆栈初始ESP到TCB
   671                                  
   672                                          ;创建2特权级堆栈
   673 00000259 B900100000                      mov ecx,4096
   674 0000025E 89C8                            mov eax,ecx                        ;为生成堆栈高端地址做准备
   675 00000260 26894E36                        mov [es:esi+0x36],ecx
   676 00000264 26C16E360C                      shr dword [es:esi+0x36],12               ;登记2特权级堆栈尺寸到TCB
   677 00000269 9A[22010000]2800                call sys_routine_seg_sel:allocate_memory
   678 00000270 01C8                            add eax,ecx                        ;堆栈必须使用高端地址为基地址
   679 00000272 26894E3A                        mov [es:esi+0x3a],ecx              ;登记2特权级堆栈基地址到TCB
   680 00000276 BBFEFF0F00                      mov ebx,0xffffe                    ;段长度（界限）
   681 0000027B B900D6C000                      mov ecx,0x00c0d600                 ;4KB粒度，读写，特权级2
   682 00000280 9A[AE010000]2800                call sys_routine_seg_sel:make_seg_descriptor
   683 00000287 89F3                            mov ebx,esi                        ;TCB的基地址
   684 00000289 E872FDFFFF                      call fill_descriptor_in_ldt
   685 0000028E 6683C90A                        or cx,0000_0000_0000_0010          ;设置选择子的特权级为2
   686 00000292 2666894E3E                      mov [es:esi+0x3e],cx               ;登记2特权级堆栈选择子到TCB
   687 00000297 26C7464000000000                mov dword [es:esi+0x40],0          ;登记2特权级堆栈初始ESP到TCB
   688                                  
   689                                          ;在GDT中登记LDT描述符
   690 0000029F 268B460C                        mov eax,[es:esi+0x0c]              ;LDT的起始线性地址
   691 000002A3 260FB75E0A                      movzx ebx,word [es:esi+0x0a]       ;LDT段界限
   692 000002A8 B900824000                      mov ecx,0x00408200                 ;LDT描述符，特权级0
   693 000002AD 9A[AE010000]2800                call sys_routine_seg_sel:make_seg_descriptor
   694 000002B4 9A[52010000]2800                call sys_routine_seg_sel:set_up_gdt_descriptor
   695 000002BB 2666894E10                      mov [es:esi+0x10],cx               ;登记LDT选择子到TCB中
   696                                  
   697                                          ;创建用户程序的TSS
   698 000002C0 B968000000                      mov ecx,104                        ;tss的基本尺寸，还可以更大
   699 000002C5 2666894E12                      mov [es:esi+0x12],cx              
   700 000002CA 2666FF4E12                      dec word [es:esi+0x12]             ;登记TSS界限值到TCB，界限值需要减一 
   701 000002CF 9A[22010000]2800                call sys_routine_seg_sel:allocate_memory    ;分配内存，返回ecx=已分配起始内存地址
   702 000002D6 26894E14                        mov [es:esi+0x14],ecx              ;登记TSS基地址到TCB
   703                                  
   704                                          ;登记基本的TSS表格内容
   705 000002DA 2666C7010000                    mov word [es:ecx+0],0              ;反向链=0
   706                                      
   707 000002E0 268B5624                        mov edx,[es:esi+0x24]              ;登记0特权级堆栈初始ESP
   708 000002E4 26895104                        mov [es:ecx+4],edx                 ;到TSS中
   709                                      
   710 000002E8 26668B5622                      mov dx,[es:esi+0x22]               ;登记0特权级堆栈段选择子
   711 000002ED 2666895108                      mov [es:ecx+8],dx                  ;到TSS中
   712                                      
   713 000002F2 268B5632                        mov edx,[es:esi+0x32]              ;登记1特权级堆栈初始ESP
   714 000002F6 2689510C                        mov [es:ecx+12],edx                ;到TSS中
   715                                  
   716 000002FA 26668B5630                      mov dx,[es:esi+0x30]               ;登记1特权级堆栈段选择子
   717 000002FF 2666895110                      mov [es:ecx+16],dx                 ;到TSS中
   718                                  
   719 00000304 268B5640                        mov edx,[es:esi+0x40]              ;登记2特权级堆栈初始ESP
   720 00000308 26895114                        mov [es:ecx+20],edx                ;到TSS中
   721                                  
   722 0000030C 26668B563E                      mov dx,[es:esi+0x3e]               ;登记2特权级堆栈段选择子
   723 00000311 2666895118                      mov [es:ecx+24],dx                 ;到TSS中
   724                                  
   725 00000316 26668B5610                      mov dx,[es:esi+0x10]               ;登记任务的LDT选择子
   726 0000031B 2666895160                      mov [es:ecx+96],dx                 ;到TSS中
   727                                      
   728 00000320 26668B5612                      mov dx,[es:esi+0x12]               ;登记任务的I/O位图偏移
   729 00000325 2666895166                      mov [es:ecx+102],dx                ;到TSS中 
   730                                      
   731 0000032A 2666C741640000                  mov word [es:ecx+100],0            ;T=0
   732                                  
   733 00000331 26C7411C00000000                mov dword [es:ecx+28],0            ;登记CR3(PDBR)
   734                                  
   735                                          ;访问用户程序头部，获取数据填充TSS 
   736 00000339 8B5D2C                          mov ebx,[ebp+11*4]                 ;从堆栈中取得TCB的基地址
   737 0000033C 268B7B06                        mov edi,[es:ebx+0x06]              ;用户程序加载的基地址 
   738                                  
   739 00000340 268B5710                        mov edx,[es:edi+0x10]              ;登记程序入口点（EIP） 
   740 00000344 26895120                        mov [es:ecx+32],edx                ;到TSS
   741                                  
   742 00000348 26668B5714                      mov dx,[es:edi+0x14]               ;登记程序代码段（CS）选择子
   743 0000034D 266689514C                      mov [es:ecx+76],dx                 ;到TSS中
   744                                  
   745 00000352 26668B5708                      mov dx,[es:edi+0x08]               ;登记程序堆栈段（SS）选择子
   746 00000357 2666895150                      mov [es:ecx+80],dx                 ;到TSS中
   747                                  
   748 0000035C 26668B5704                      mov dx,[es:edi+0x04]               ;登记程序数据段（DS）选择子
   749 00000361 2666895154                      mov word [es:ecx+84],dx            ;到TSS中。注意，它指向程序头部段
   750                                      
   751 00000366 2666C741480000                  mov word [es:ecx+72],0             ;TSS中的ES=0
   752                                  
   753 0000036D 2666C741580000                  mov word [es:ecx+88],0             ;TSS中的FS=0
   754                                  
   755 00000374 2666C7415C0000                  mov word [es:ecx+92],0             ;TSS中的GS=0
   756                                  
   757 0000037B 9C                              pushfd
   758 0000037C 5A                              pop edx
   759                                          
   760 0000037D 26895124                        mov dword [es:ecx+36],edx          ;EFLAGS
   761                                  
   762                                          ;在GDT中登记TSS描述符
   763 00000381 268B4614                        mov eax,[es:esi+0x14]              ;TSS的起始线性地址
   764 00000385 260FB75E12                      movzx ebx,word [es:esi+0x12]       ;段长度（界限）
   765 0000038A B900894000                      mov ecx,0x00408900                 ;TSS描述符，特权级0
   766 0000038F 9A[AE010000]2800                call sys_routine_seg_sel:make_seg_descriptor
   767 00000396 9A[52010000]2800                call sys_routine_seg_sel:set_up_gdt_descriptor
   768 0000039D 2666894E18                      mov [es:esi+0x18],cx               ;登记TSS选择子到TCB
   769                                  
   770 000003A2 07                              pop es                             ;恢复到调用此过程前的es段 
   771 000003A3 1F                              pop ds                             ;恢复到调用此过程前的ds段
   772                                      
   773 000003A4 61                              popad
   774                                      
   775 000003A5 C20800                          ret 8                              ;丢弃调用本过程前压入的参数，也就是压入的两个参数，8个字节
   776                                  
   777                                  ;-----------在TCB链上追加任务控制块-----------------------------------------------------------------------
   778                                      append_to_tcb_link:                 ;输入：ecx=起始线性地址
   779 000003A8 50                              push eax
   780 000003A9 52                              push edx
   781 000003AA 1E                              push ds
   782 000003AB 06                              push es
   783                                  
   784 000003AC B830000000                      mov eax,core_data_seg_sel
   785 000003B1 8ED8                            mov ds,eax                      ;令DS指向内核数据段 
   786                                  
   787 000003B3 B808000000                      mov eax,mem_0_4_gb_seg_sel
   788 000003B8 8EC0                            mov es,eax                      ;令ES指向0..4GB段
   789                                  
   790 000003BA 26C70100000000                  mov dword [es: ecx+0x00],0      ;当前TCB指针域清零，以指示这是最后一个TCB
   791 000003C1 A1[270D0000]                    mov eax,[tcb_chain]
   792 000003C6 09C0                            or eax,eax  
   793 000003C8 740E                            jz .notcb                       ;如果表头指针为0，表明任务链表尚未有数据
   794                                  
   795                                      .searc:                             ;查找链表尾部
   796 000003CA 89C2                            mov edx,eax 
   797 000003CC 268B02                          mov eax,[es:edx+0x00]           
   798 000003CF 09C0                            or eax,eax
   799 000003D1 75F7                            jnz .searc                      ;当前结点的指针域是否为空，不为空则继续查找
   800 000003D3 26890A                          mov [es:edx+0x00],ecx           ;找到最后一个结点了，将新结点的起始线性地址赋值到最后一个结点的指针域
   801 000003D6 EB06                            jmp .retpc
   802                                  
   803                                      .notcb:
   804 000003D8 890D[270D0000]                  mov [tcb_chain],ecx             ;如果表头为空，则赋值当前链表起始线性地址
   805                                  
   806                                      .retpc:
   807 000003DE 07                              pop es
   808 000003DF 1F                              pop ds
   809 000003E0 5A                              pop edx
   810 000003E1 58                              pop eax
   811                                          
   812 000003E2 C3                              ret
   813                                  
   814                                  ;-----------程序入口-----------------------------------------------------------------------
   815                                      start:
   816 000003E3 B930000000                      mov ecx,core_data_seg_sel
   817 000003E8 8ED9                            mov ds,ecx                              ;使ds指向内核数据段
   818                                          
   819 000003EA B908000000                      mov ecx,mem_0_4_gb_seg_sel         ;令ES指向4GB数据段 
   820 000003EF 8EC1                            mov es,ecx
   821                                  
   822 000003F1 BB[22040000]                    mov ebx,message_1
   823 000003F6 9A[00000000]2800                call sys_routine_seg_sel:put_string     ;显示消息
   824                                  
   825                                          ;显示处理器品牌信息 
   826 000003FD B802000080                      mov eax,0x80000002
   827 00000402 0FA2                            cpuid
   828 00000404 A3[EE0C0000]                    mov [cpu_brand + 0x00],eax
   829 00000409 891D[F20C0000]                  mov [cpu_brand + 0x04],ebx
   830 0000040F 890D[F60C0000]                  mov [cpu_brand + 0x08],ecx
   831 00000415 8915[FA0C0000]                  mov [cpu_brand + 0x0c],edx
   832                                  
   833 0000041B B803000080                      mov eax,0x80000003
   834 00000420 0FA2                            cpuid
   835 00000422 A3[FE0C0000]                    mov [cpu_brand + 0x10],eax
   836 00000427 891D[020D0000]                  mov [cpu_brand + 0x14],ebx
   837 0000042D 890D[060D0000]                  mov [cpu_brand + 0x18],ecx
   838 00000433 8915[0A0D0000]                  mov [cpu_brand + 0x1c],edx
   839                                  
   840 00000439 B804000080                      mov eax,0x80000004
   841 0000043E 0FA2                            cpuid
   842 00000440 A3[0E0D0000]                    mov [cpu_brand + 0x20],eax
   843 00000445 891D[120D0000]                  mov [cpu_brand + 0x24],ebx
   844 0000044B 890D[160D0000]                  mov [cpu_brand + 0x28],ecx
   845 00000451 8915[1A0D0000]                  mov [cpu_brand + 0x2c],edx
   846                                  
   847 00000457 BB[E90C0000]                    mov ebx,cpu_brnd0                  
   848 0000045C 9A[00000000]2800                call sys_routine_seg_sel:put_string
   849 00000463 BB[EE0C0000]                    mov ebx,cpu_brand
   850 00000468 9A[00000000]2800                call sys_routine_seg_sel:put_string
   851 0000046F BB[220D0000]                    mov ebx,cpu_brnd1
   852 00000474 9A[00000000]2800                call sys_routine_seg_sel:put_string
   853                                  
   854                                          ;以下开始安装调用门
   855 0000047B BF[0A000000]                    mov edi,salt                            ;符号表起始位置
   856 00000480 B904000000                      mov ecx,salt_items                      ;符号表数量
   857                                      .b3:
   858 00000485 51                              push ecx                                ;压栈符号表的数量
   859 00000486 8B8700010000                    mov eax,[edi+256]                       ;该符号入口点的32位偏移地址
   860 0000048C 668B9F04010000                  mov bx,[edi+260]                        ;该符号入口点的段选择子
   861 00000493 66B900EC                        mov cx,1_11_0_1100_000_00000B           ;门属性，P=1,DPL=3。即只有特权级大于等于3的才能调用该门。0个参数，未使用栈传参
   862                                  
   863 00000497 9A[C9010000]2800                call sys_routine_seg_sel:make_gate_descriptor   ;构建调用门描述符
   864 0000049E 9A[52010000]2800                call sys_routine_seg_sel:set_up_gdt_descriptor  ;安装调用门描述符，返回ex=段描述符选择子
   865                                  
   866 000004A5 66898F04010000                  mov [edi+260],cx                        ;将返回的门段选择子回填
   867 000004AC 81C706010000                    add edi,salt_item_len                   ;指向下一个符号
   868 000004B2 59                              pop ecx
   869 000004B3 E2D0                            loop .b3
   870                                  
   871                                          ;对门进行测试
   872 000004B5 BB[B2040000]                    mov ebx,message_2
   873 000004BA FF1D[0A010000]                  call far [salt_1+256]                   ;通过门显示信息,间接取得偏移量（会被忽略）与段选择子
   874                                  
   875                                          ;为程序管理器的TSS分配内存空间
   876 000004C0 B968000000                      mov ecx,104                             ;TSS的基本尺寸，还可以更大
   877 000004C5 9A[22010000]2800                call sys_routine_seg_sel:allocate_memory;分配内存，返回ecx=已分配起始内存地址
   878 000004CC 890D[2B0D0000]                  mov [prgman_tss+0x00],ecx               ;保存程序管理器的TSS基地址
   879                                  
   880                                          ;在程序管理器的TSS中设置必要的项目 
   881 000004D2 2666C741600000                  mov word [es:ecx+96],0             ;没有LDT。处理器允许没有LDT的任务。
   882 000004D9 2666C741666700                  mov word [es:ecx+102],103          ;没有I/O位图。0特权级事实上不需要。
   883 000004E0 2666C7010000                    mov word [es:ecx+0],0              ;反向链=0
   884 000004E6 26C7411C00000000                mov dword [es:ecx+28],0            ;登记CR3(PDBR)
   885 000004EE 2666C741640000                  mov word [es:ecx+100],0            ;T=0
   886                                                                             ;不需要0、1、2特权级堆栈。0特权级不会向低特权级转移控制。 
   887                                          ;创建TSS描述符，并安装到GDT中 
   888 000004F5 89C8                            mov eax,ecx                        ;TSS的起始线性地址
   889 000004F7 BB67000000                      mov ebx,103                        ;段长度（界限）
   890 000004FC B900894000                      mov ecx,0x00408900                 ;TSS描述符，特权级0
   891 00000501 9A[AE010000]2800                call sys_routine_seg_sel:make_seg_descriptor
   892 00000508 9A[52010000]2800                call sys_routine_seg_sel:set_up_gdt_descriptor
   893 0000050F 66890D[2F0D0000]                mov [prgman_tss+0x04],cx           ;保存程序管理器的TSS描述符选择子 
   894                                  
   895                                          ;任务寄存器TR中的内容是任务存在的标志，该内容也决定了当前任务是谁。
   896                                          ;下面的指令为当前正在执行的0特权级任务“程序管理器”后补手续（TSS）。
   897 00000516 0F00D9                          ltr cx
   898                                  
   899                                          ;现在可认为“程序管理器”任务正执行中
   900 00000519 BB[310D0000]                    mov ebx,prgman_msg1
   901 0000051E 9A[00000000]2800                call sys_routine_seg_sel:put_string    
   902                                  
   903                                          ;创建任务控制块。这不是处理器要求的，是我们自己定义的链表结构，用来记录任务的状态和信息
   904 00000525 B946000000                      mov ecx,0x46                            ;单个链表项的长度为70字节
   905 0000052A 9A[22010000]2800                call sys_routine_seg_sel:allocate_memory;分配内存，返回ecx=已分配起始内存地址
   906 00000531 E872FEFFFF                      call append_to_tcb_link                 ;将当前任务控制块加入到任务控制链表尾部
   907                                  
   908                                          ;加载并重定位用户程序,使用栈传递参数
   909 00000536 6A32                            push dword 50                           ;用户程序所在磁盘扇区
   910 00000538 51                              push ecx                                ;任务控制块的起始地址
   911 00000539 E806FBFFFF                      call load_relocate_program              ;加载并重定位用户程序
   912                                  
   913 0000053E 26FF5914                        call far [es:ecx+0x14]                  ;执行任务切换。和上一章不同，任务切换时要恢复TSS内容，所以在创建任务时TSS要填写完整
   914                                  
   915                                          ;重新加载并切换任务
   916                                          ;创建任务控制块。这不是处理器要求的，是我们自己定义的链表结构，用来记录任务的状态和信息
   917 00000542 B946000000                      mov ecx,0x46                            ;单个链表项的长度为70字节
   918 00000547 9A[22010000]2800                call sys_routine_seg_sel:allocate_memory;分配内存，返回ecx=已分配起始内存地址
   919 0000054E E855FEFFFF                      call append_to_tcb_link                 ;将当前任务控制块加入到任务控制链表尾部
   920                                  
   921                                          ;加载并重定位用户程序,使用栈传递参数
   922 00000553 6A32                            push dword 50                           ;用户程序所在磁盘扇区
   923 00000555 51                              push ecx                                ;任务控制块的起始地址
   924 00000556 E8E9FAFFFF                      call load_relocate_program              ;加载并重定位用户程序
   925                                  
   926 0000055B 26FF6914                        jmp far [es:ecx+0x14]                  ;使用jmp指令进行任务切换
   927                                  
   928 0000055F BB[2D0E0000]                    mov ebx,prgman_msg3
   929 00000564 9A[00000000]2800                call sys_routine_seg_sel:put_string
   930                                  
   931 0000056B F4                              hlt
   932                                      core_code_end:
   933                                  ;-----------尾部段-----------------------------------------------------------------------
   934                                  section core_trail
   935                                         core_end:   ;程序结尾标号，因为段没有定义vstart,所以该标号的偏移地址是从程序头开始的
