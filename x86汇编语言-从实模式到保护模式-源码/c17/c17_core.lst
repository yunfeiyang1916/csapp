     1                                           ;代码清单17-2
     2                                           ;文件名：c17_core.asm
     3                                           ;文件说明：保护模式微型核心程序 
     4                                           ;创建日期：2012-07-12 23:15
     5                                  ;-------------------------------------------------------------------------------
     6                                           ;以下定义常量
     7                                           flat_4gb_code_seg_sel  equ  0x0008      ;平坦模型下的4GB代码段选择子 
     8                                           flat_4gb_data_seg_sel  equ  0x0018      ;平坦模型下的4GB数据段选择子 
     9                                           idt_linear_address     equ  0x8001f000  ;中断描述符表的线性基地址 
    10                                  ;-------------------------------------------------------------------------------          
    11                                           ;以下定义宏
    12                                           %macro alloc_core_linear 0              ;在内核空间中分配虚拟内存 
    13                                                 mov ebx,[core_tcb+0x06]
    14                                                 add dword [core_tcb+0x06],0x1000
    15                                                 call flat_4gb_code_seg_sel:alloc_inst_a_page
    16                                           %endmacro 
    17                                  ;-------------------------------------------------------------------------------
    18                                           %macro alloc_user_linear 0              ;在任务空间中分配虚拟内存 
    19                                                 mov ebx,[esi+0x06]
    20                                                 add dword [esi+0x06],0x1000
    21                                                 call flat_4gb_code_seg_sel:alloc_inst_a_page
    22                                           %endmacro
    23                                           
    24                                  ;===============================================================================
    25                                  SECTION  core  vstart=0x80040000
    26                                  
    27                                           ;以下是系统核心的头部，用于加载核心程序 
    28 00000000 [00000000]                       core_length      dd core_end       ;核心程序总长度#00
    29                                  
    30 00000004 [9F0D0000]                       core_entry       dd start          ;核心代码段入口点#04
    31                                  
    32                                  ;-------------------------------------------------------------------------------
    33                                           [bits 32]
    34                                  ;-------------------------------------------------------------------------------
    35                                           ;字符串显示例程（适用于平坦内存模型） 
    36                                  put_string:                                 ;显示0终止的字符串并移动光标 
    37                                                                              ;输入：EBX=字符串的线性地址
    38                                  
    39 00000008 53                               push ebx
    40 00000009 51                               push ecx
    41                                  
    42 0000000A FA                               cli                                ;硬件操作期间，关中断
    43                                  
    44                                    .getc:
    45 0000000B 8A0B                             mov cl,[ebx]
    46 0000000D 08C9                             or cl,cl                           ;检测串结束标志（0） 
    47 0000000F 7408                             jz .exit                           ;显示完毕，返回 
    48 00000011 E807000000                       call put_char
    49 00000016 43                               inc ebx
    50 00000017 EBF2                             jmp .getc
    51                                  
    52                                    .exit:
    53                                  
    54 00000019 FB                               sti                                ;硬件操作完毕，开放中断
    55                                  
    56 0000001A 59                               pop ecx
    57 0000001B 5B                               pop ebx
    58                                  
    59 0000001C CB                               retf                               ;段间返回
    60                                  
    61                                  ;-------------------------------------------------------------------------------
    62                                  put_char:                                   ;在当前光标处显示一个字符,并推进
    63                                                                              ;光标。仅用于段内调用 
    64                                                                              ;输入：CL=字符ASCII码 
    65 0000001D 60                               pushad
    66                                  
    67                                           ;以下取当前光标位置
    68 0000001E 66BAD403                         mov dx,0x3d4
    69 00000022 B00E                             mov al,0x0e
    70 00000024 EE                               out dx,al
    71 00000025 6642                             inc dx                             ;0x3d5
    72 00000027 EC                               in al,dx                           ;高字
    73 00000028 88C4                             mov ah,al
    74                                  
    75 0000002A 664A                             dec dx                             ;0x3d4
    76 0000002C B00F                             mov al,0x0f
    77 0000002E EE                               out dx,al
    78 0000002F 6642                             inc dx                             ;0x3d5
    79 00000031 EC                               in al,dx                           ;低字
    80 00000032 6689C3                           mov bx,ax                          ;BX=代表光标位置的16位数
    81 00000035 81E3FFFF0000                     and ebx,0x0000ffff                 ;准备使用32位寻址方式访问显存 
    82                                           
    83 0000003B 80F90D                           cmp cl,0x0d                        ;回车符？
    84 0000003E 750E                             jnz .put_0a                         
    85                                           
    86 00000040 6689D8                           mov ax,bx                          ;以下按回车符处理 
    87 00000043 B350                             mov bl,80
    88 00000045 F6F3                             div bl
    89 00000047 F6E3                             mul bl
    90 00000049 6689C3                           mov bx,ax
    91 0000004C EB4E                             jmp .set_cursor
    92                                  
    93                                    .put_0a:
    94 0000004E 80F90A                           cmp cl,0x0a                        ;换行符？
    95 00000051 7506                             jnz .put_other
    96 00000053 6683C350                         add bx,80                          ;增加一行 
    97 00000057 EB0E                             jmp .roll_screen
    98                                  
    99                                    .put_other:                               ;正常显示字符
   100 00000059 66D1E3                           shl bx,1
   101 0000005C 888B00800B80                     mov [0x800b8000+ebx],cl            ;在光标位置处显示字符 
   102                                  
   103                                           ;以下将光标位置推进一个字符
   104 00000062 66D1EB                           shr bx,1
   105 00000065 6643                             inc bx
   106                                  
   107                                    .roll_screen:
   108 00000067 6681FBD007                       cmp bx,2000                        ;光标超出屏幕？滚屏
   109 0000006C 7C2E                             jl .set_cursor
   110                                  
   111 0000006E FC                               cld
   112 0000006F BEA0800B80                       mov esi,0x800b80a0                 ;小心！32位模式下movsb/w/d 
   113 00000074 BF00800B80                       mov edi,0x800b8000                 ;使用的是esi/edi/ecx 
   114 00000079 B980070000                       mov ecx,1920
   115 0000007E F3A5                             rep movsd
   116 00000080 66BB000F                         mov bx,3840                        ;清除屏幕最底一行
   117 00000084 B950000000                       mov ecx,80                         ;32位程序应该使用ECX
   118                                    .cls:
   119 00000089 66C78300800B802007               mov word [0x800b8000+ebx],0x0720
   120 00000092 6683C302                         add bx,2
   121 00000096 E2F1                             loop .cls
   122                                  
   123 00000098 66BB8007                         mov bx,1920
   124                                  
   125                                    .set_cursor:
   126 0000009C 66BAD403                         mov dx,0x3d4
   127 000000A0 B00E                             mov al,0x0e
   128 000000A2 EE                               out dx,al
   129 000000A3 6642                             inc dx                             ;0x3d5
   130 000000A5 88F8                             mov al,bh
   131 000000A7 EE                               out dx,al
   132 000000A8 664A                             dec dx                             ;0x3d4
   133 000000AA B00F                             mov al,0x0f
   134 000000AC EE                               out dx,al
   135 000000AD 6642                             inc dx                             ;0x3d5
   136 000000AF 88D8                             mov al,bl
   137 000000B1 EE                               out dx,al
   138                                           
   139 000000B2 61                               popad
   140                                           
   141 000000B3 C3                               ret                              
   142                                  
   143                                  ;-------------------------------------------------------------------------------
   144                                  read_hard_disk_0:                           ;从硬盘读取一个逻辑扇区（平坦模型） 
   145                                                                              ;EAX=逻辑扇区号
   146                                                                              ;EBX=目标缓冲区线性地址
   147                                                                              ;返回：EBX=EBX+512
   148 000000B4 FA                               cli
   149                                           
   150 000000B5 50                               push eax 
   151 000000B6 51                               push ecx
   152 000000B7 52                               push edx
   153                                        
   154 000000B8 50                               push eax
   155                                           
   156 000000B9 66BAF201                         mov dx,0x1f2
   157 000000BD B001                             mov al,1
   158 000000BF EE                               out dx,al                          ;读取的扇区数
   159                                  
   160 000000C0 6642                             inc dx                             ;0x1f3
   161 000000C2 58                               pop eax
   162 000000C3 EE                               out dx,al                          ;LBA地址7~0
   163                                  
   164 000000C4 6642                             inc dx                             ;0x1f4
   165 000000C6 B108                             mov cl,8
   166 000000C8 D3E8                             shr eax,cl
   167 000000CA EE                               out dx,al                          ;LBA地址15~8
   168                                  
   169 000000CB 6642                             inc dx                             ;0x1f5
   170 000000CD D3E8                             shr eax,cl
   171 000000CF EE                               out dx,al                          ;LBA地址23~16
   172                                  
   173 000000D0 6642                             inc dx                             ;0x1f6
   174 000000D2 D3E8                             shr eax,cl
   175 000000D4 0CE0                             or al,0xe0                         ;第一硬盘  LBA地址27~24
   176 000000D6 EE                               out dx,al
   177                                  
   178 000000D7 6642                             inc dx                             ;0x1f7
   179 000000D9 B020                             mov al,0x20                        ;读命令
   180 000000DB EE                               out dx,al
   181                                  
   182                                    .waits:
   183 000000DC EC                               in al,dx
   184 000000DD 2488                             and al,0x88
   185 000000DF 3C08                             cmp al,0x08
   186 000000E1 75F9                             jnz .waits                         ;不忙，且硬盘已准备好数据传输 
   187                                  
   188 000000E3 B900010000                       mov ecx,256                        ;总共要读取的字数
   189 000000E8 66BAF001                         mov dx,0x1f0
   190                                    .readw:
   191 000000EC 66ED                             in ax,dx
   192 000000EE 668903                           mov [ebx],ax
   193 000000F1 83C302                           add ebx,2
   194 000000F4 E2F6                             loop .readw
   195                                  
   196 000000F6 5A                               pop edx
   197 000000F7 59                               pop ecx
   198 000000F8 58                               pop eax
   199                                        
   200 000000F9 FB                               sti
   201                                        
   202 000000FA CB                               retf                               ;远返回 
   203                                  
   204                                  ;-------------------------------------------------------------------------------
   205                                  ;汇编语言程序是极难一次成功，而且调试非常困难。这个例程可以提供帮助 
   206                                  put_hex_dword:                              ;在当前光标处以十六进制形式显示
   207                                                                              ;一个双字并推进光标 
   208                                                                              ;输入：EDX=要转换并显示的数字
   209                                                                              ;输出：无
   210 000000FB 60                               pushad
   211                                  
   212 000000FC BB[4C080000]                     mov ebx,bin_hex                    ;指向核心地址空间内的转换表
   213 00000101 B908000000                       mov ecx,8
   214                                    .xlt:    
   215 00000106 C1C204                           rol edx,4
   216 00000109 89D0                             mov eax,edx
   217 0000010B 83E00F                           and eax,0x0000000f
   218 0000010E D7                               xlat
   219                                        
   220 0000010F 51                               push ecx
   221 00000110 88C1                             mov cl,al                           
   222 00000112 E806FFFFFF                       call put_char
   223 00000117 59                               pop ecx
   224                                         
   225 00000118 E2EC                             loop .xlt
   226                                        
   227 0000011A 61                               popad
   228 0000011B CB                               retf
   229                                        
   230                                  ;-------------------------------------------------------------------------------
   231                                  set_up_gdt_descriptor:                      ;在GDT内安装一个新的描述符
   232                                                                              ;输入：EDX:EAX=描述符 
   233                                                                              ;输出：CX=描述符的选择子
   234 0000011C 50                               push eax
   235 0000011D 53                               push ebx
   236 0000011E 52                               push edx
   237                                  
   238 0000011F 0F0105[CE020000]                 sgdt [pgdt]                        ;取得GDTR的界限和线性地址 
   239                                  
   240 00000126 0FB71D[CE020000]                 movzx ebx,word [pgdt]              ;GDT界限
   241 0000012D 6643                             inc bx                             ;GDT总字节数，也是下一个描述符偏移
   242 0000012F 031D[D0020000]                   add ebx,[pgdt+2]                   ;下一个描述符的线性地址
   243                                  
   244 00000135 8903                             mov [ebx],eax
   245 00000137 895304                           mov [ebx+4],edx
   246                                  
   247 0000013A 668305[CE020000]08               add word [pgdt],8                  ;增加一个描述符的大小
   248                                  
   249 00000142 0F0115[CE020000]                 lgdt [pgdt]                        ;对GDT的更改生效
   250                                  
   251 00000149 66A1[CE020000]                   mov ax,[pgdt]                      ;得到GDT界限值
   252 0000014F 6631D2                           xor dx,dx
   253 00000152 66BB0800                         mov bx,8
   254 00000156 66F7F3                           div bx                             ;除以8，去掉余数
   255 00000159 6689C1                           mov cx,ax
   256 0000015C 66C1E103                         shl cx,3                           ;将索引号移到正确位置
   257                                  
   258 00000160 5A                               pop edx
   259 00000161 5B                               pop ebx
   260 00000162 58                               pop eax
   261                                  
   262 00000163 CB                               retf
   263                                  ;-------------------------------------------------------------------------------
   264                                  make_seg_descriptor:                        ;构造存储器和系统的段描述符
   265                                                                              ;输入：EAX=线性基地址
   266                                                                              ;      EBX=段界限
   267                                                                              ;      ECX=属性。各属性位都在原始
   268                                                                              ;          位置，无关的位清零 
   269                                                                              ;返回：EDX:EAX=描述符
   270 00000164 89C2                             mov edx,eax
   271 00000166 C1E010                           shl eax,16
   272 00000169 6609D8                           or ax,bx                           ;描述符前32位(EAX)构造完毕
   273                                  
   274 0000016C 81E20000FFFF                     and edx,0xffff0000                 ;清除基地址中无关的位
   275 00000172 C1C208                           rol edx,8
   276 00000175 0FCA                             bswap edx                          ;装配基址的31~24和23~16  (80486+)
   277                                  
   278 00000177 6631DB                           xor bx,bx
   279 0000017A 09DA                             or edx,ebx                         ;装配段界限的高4位
   280                                  
   281 0000017C 09CA                             or edx,ecx                         ;装配属性
   282                                  
   283 0000017E CB                               retf
   284                                  
   285                                  ;-------------------------------------------------------------------------------
   286                                  make_gate_descriptor:                       ;构造门的描述符（调用门等）
   287                                                                              ;输入：EAX=门代码在段内偏移地址
   288                                                                              ;       BX=门代码所在段的选择子 
   289                                                                              ;       CX=段类型及属性等（各属
   290                                                                              ;          性位都在原始位置）
   291                                                                              ;返回：EDX:EAX=完整的描述符
   292 0000017F 53                               push ebx
   293 00000180 51                               push ecx
   294                                        
   295 00000181 89C2                             mov edx,eax
   296 00000183 81E20000FFFF                     and edx,0xffff0000                 ;得到偏移地址高16位 
   297 00000189 6609CA                           or dx,cx                           ;组装属性部分到EDX
   298                                         
   299 0000018C 25FFFF0000                       and eax,0x0000ffff                 ;得到偏移地址低16位 
   300 00000191 C1E310                           shl ebx,16                          
   301 00000194 09D8                             or eax,ebx                         ;组装段选择子部分
   302                                        
   303 00000196 59                               pop ecx
   304 00000197 5B                               pop ebx
   305                                        
   306 00000198 CB                               retf                                   
   307                                                               
   308                                  ;-------------------------------------------------------------------------------
   309                                  allocate_a_4k_page:                         ;分配一个4KB的页
   310                                                                              ;输入：无
   311                                                                              ;输出：EAX=页的物理地址
   312 00000199 53                               push ebx
   313 0000019A 51                               push ecx
   314 0000019B 52                               push edx
   315                                  
   316 0000019C 31C0                             xor eax,eax
   317                                    .b1:
   318 0000019E 0FAB05[FE020000]                 bts [page_bit_map],eax
   319 000001A5 7315                             jnc .b2
   320 000001A7 40                               inc eax
   321 000001A8 3D00020000                       cmp eax,page_map_len*8
   322 000001AD 7CEF                             jl .b1
   323                                           
   324 000001AF BB[10080000]                     mov ebx,message_3
   325 000001B4 9A[08000000]0800                 call flat_4gb_code_seg_sel:put_string
   326 000001BB F4                               hlt                                ;没有可以分配的页，停机 
   327                                           
   328                                    .b2:
   329 000001BC C1E00C                           shl eax,12                         ;乘以4096（0x1000） 
   330                                           
   331 000001BF 5A                               pop edx
   332 000001C0 59                               pop ecx
   333 000001C1 5B                               pop ebx
   334                                           
   335 000001C2 C3                               ret
   336                                           
   337                                  ;-------------------------------------------------------------------------------
   338                                  alloc_inst_a_page:                          ;分配一个页，并安装在当前活动的
   339                                                                              ;层级分页结构中
   340                                                                              ;输入：EBX=页的线性地址
   341 000001C3 50                               push eax
   342 000001C4 53                               push ebx
   343 000001C5 56                               push esi
   344                                           
   345                                           ;检查该线性地址所对应的页表是否存在
   346 000001C6 89DE                             mov esi,ebx
   347 000001C8 81E60000C0FF                     and esi,0xffc00000
   348 000001CE C1EE14                           shr esi,20                         ;得到页目录索引，并乘以4 
   349 000001D1 81CE00F0FFFF                     or esi,0xfffff000                  ;页目录自身的线性地址+表内偏移 
   350                                  
   351 000001D7 F70601000000                     test dword [esi],0x00000001        ;P位是否为“1”。检查该线性地址是 
   352 000001DD 750A                             jnz .b1                            ;否已经有对应的页表
   353                                            
   354                                           ;创建该线性地址所对应的页表 
   355 000001DF E8B5FFFFFF                       call allocate_a_4k_page            ;分配一个页做为页表 
   356 000001E4 83C807                           or eax,0x00000007
   357 000001E7 8906                             mov [esi],eax                      ;在页目录中登记该页表
   358                                            
   359                                    .b1:
   360                                           ;开始访问该线性地址所对应的页表 
   361 000001E9 89DE                             mov esi,ebx
   362 000001EB C1EE0A                           shr esi,10
   363 000001EE 81E600F03F00                     and esi,0x003ff000                 ;或者0xfffff000，因高10位是零 
   364 000001F4 81CE0000C0FF                     or esi,0xffc00000                  ;得到该页表的线性地址
   365                                           
   366                                           ;得到该线性地址在页表内的对应条目（页表项） 
   367 000001FA 81E300F03F00                     and ebx,0x003ff000
   368 00000200 C1EB0A                           shr ebx,10                         ;相当于右移12位，再乘以4
   369 00000203 09DE                             or esi,ebx                         ;页表项的线性地址 
   370 00000205 E88FFFFFFF                       call allocate_a_4k_page            ;分配一个页，这才是要安装的页
   371 0000020A 83C807                           or eax,0x00000007
   372 0000020D 8906                             mov [esi],eax 
   373                                            
   374 0000020F 5E                               pop esi
   375 00000210 5B                               pop ebx
   376 00000211 58                               pop eax
   377                                           
   378 00000212 CB                               retf  
   379                                  
   380                                  ;-------------------------------------------------------------------------------
   381                                  create_copy_cur_pdir:                       ;创建新页目录，并复制当前页目录内容
   382                                                                              ;输入：无
   383                                                                              ;输出：EAX=新页目录的物理地址 
   384 00000213 56                               push esi
   385 00000214 57                               push edi
   386 00000215 53                               push ebx
   387 00000216 51                               push ecx
   388                                           
   389 00000217 E87DFFFFFF                       call allocate_a_4k_page            
   390 0000021C 89C3                             mov ebx,eax
   391 0000021E 83CB07                           or ebx,0x00000007
   392 00000221 891DF8FFFFFF                     mov [0xfffffff8],ebx
   393                                  
   394 00000227 0F013DF8FFFFFF                   invlpg [0xfffffff8]
   395                                  
   396 0000022E BE00F0FFFF                       mov esi,0xfffff000                 ;ESI->当前页目录的线性地址
   397 00000233 BF00E0FFFF                       mov edi,0xffffe000                 ;EDI->新页目录的线性地址
   398 00000238 B900040000                       mov ecx,1024                       ;ECX=要复制的目录项数
   399 0000023D FC                               cld
   400 0000023E F3A5                             repe movsd 
   401                                           
   402 00000240 59                               pop ecx
   403 00000241 5B                               pop ebx
   404 00000242 5F                               pop edi
   405 00000243 5E                               pop esi
   406                                           
   407 00000244 CB                               retf
   408                                           
   409                                  ;-------------------------------------------------------------------------------
   410                                  general_interrupt_handler:                  ;通用的中断处理过程
   411 00000245 50                               push eax
   412                                            
   413 00000246 B020                             mov al,0x20                        ;中断结束命令EOI 
   414 00000248 E6A0                             out 0xa0,al                        ;向从片发送 
   415 0000024A E620                             out 0x20,al                        ;向主片发送
   416                                           
   417 0000024C 58                               pop eax
   418                                            
   419 0000024D CF                               iretd
   420                                  
   421                                  ;-------------------------------------------------------------------------------
   422                                  general_exception_handler:                  ;通用的异常处理过程
   423 0000024E BB[56070000]                     mov ebx,excep_msg
   424 00000253 9A[08000000]0800                 call flat_4gb_code_seg_sel:put_string
   425                                           
   426 0000025A F4                               hlt
   427                                  
   428                                  ;-------------------------------------------------------------------------------
   429                                  rtm_0x70_interrupt_handle:                  ;实时时钟中断处理过程
   430                                  
   431 0000025B 60                               pushad
   432                                  
   433 0000025C B020                             mov al,0x20                        ;中断结束命令EOI
   434 0000025E E6A0                             out 0xa0,al                        ;向8259A从片发送
   435 00000260 E620                             out 0x20,al                        ;向8259A主片发送
   436                                  
   437 00000262 B00C                             mov al,0x0c                        ;寄存器C的索引。且开放NMI
   438 00000264 E670                             out 0x70,al
   439 00000266 E471                             in al,0x71                         ;读一下RTC的寄存器C，否则只发生一次中断
   440                                                                              ;此处不考虑闹钟和周期性中断的情况
   441                                           ;找当前任务（状态为忙的任务）在链表中的位置
   442 00000268 B8[DA020000]                     mov eax,tcb_chain                  
   443                                    .b0:                                      ;EAX=链表头或当前TCB线性地址
   444 0000026D 8B18                             mov ebx,[eax]                      ;EBX=下一个TCB线性地址
   445 0000026F 09DB                             or ebx,ebx
   446 00000271 743E                             jz .irtn                           ;链表为空，或已到末尾，从中断返回
   447 00000273 66837B04FF                       cmp word [ebx+0x04],0xffff         ;是忙任务（当前任务）？
   448 00000278 7404                             je .b1
   449 0000027A 89D8                             mov eax,ebx                        ;定位到下一个TCB（的线性地址）
   450 0000027C EBEF                             jmp .b0         
   451                                  
   452                                           ;将当前为忙的任务移到链尾
   453                                    .b1:
   454 0000027E 8B0B                             mov ecx,[ebx]                      ;下游TCB的线性地址
   455 00000280 8908                             mov [eax],ecx                      ;将当前任务从链中拆除
   456                                  
   457                                    .b2:                                      ;此时，EBX=当前任务的线性地址
   458 00000282 8B10                             mov edx,[eax]
   459 00000284 09D2                             or edx,edx                         ;已到链表尾端？
   460 00000286 7404                             jz .b3
   461 00000288 89D0                             mov eax,edx
   462 0000028A EBF6                             jmp .b2
   463                                  
   464                                    .b3:
   465 0000028C 8918                             mov [eax],ebx                      ;将忙任务的TCB挂在链表尾端
   466 0000028E C70300000000                     mov dword [ebx],0x00000000         ;将忙任务的TCB标记为链尾
   467                                  
   468                                           ;从链首搜索第一个空闲任务
   469 00000294 B8[DA020000]                     mov eax,tcb_chain
   470                                    .b4:
   471 00000299 8B00                             mov eax,[eax]
   472 0000029B 09C0                             or eax,eax                         ;已到链尾（未发现空闲任务）
   473 0000029D 7412                             jz .irtn                           ;未发现空闲任务，从中断返回
   474 0000029F 6683780400                       cmp word [eax+0x04],0x0000         ;是空闲任务？
   475 000002A4 75F3                             jnz .b4
   476                                  
   477                                           ;将空闲任务和当前任务的状态都取反
   478 000002A6 66F75004                         not word [eax+0x04]                ;设置空闲任务的状态为忙
   479 000002AA 66F75304                         not word [ebx+0x04]                ;设置当前任务（忙）的状态为空闲
   480 000002AE FF6814                           jmp far [eax+0x14]                 ;任务转换
   481                                  
   482                                    .irtn:
   483 000002B1 61                               popad
   484                                  
   485 000002B2 CF                               iretd
   486                                  
   487                                  ;-------------------------------------------------------------------------------
   488                                  terminate_current_task:                     ;终止当前任务
   489                                                                              ;注意，执行此例程时，当前任务仍在
   490                                                                              ;运行中。此例程其实也是当前任务的
   491                                                                              ;一部分 
   492                                           ;找当前任务（状态为忙的任务）在链表中的位置
   493 000002B3 B8[DA020000]                     mov eax,tcb_chain
   494                                    .b0:                                      ;EAX=链表头或当前TCB线性地址
   495 000002B8 8B18                             mov ebx,[eax]                      ;EBX=下一个TCB线性地址
   496 000002BA 66837B04FF                       cmp word [ebx+0x04],0xffff         ;是忙任务（当前任务）？
   497 000002BF 7404                             je .b1
   498 000002C1 89D8                             mov eax,ebx                        ;定位到下一个TCB（的线性地址）
   499 000002C3 EBF3                             jmp .b0
   500                                           
   501                                    .b1:
   502 000002C5 66C743043333                     mov word [ebx+0x04],0x3333         ;修改当前任务的状态为“退出”
   503                                           
   504                                    .b2:
   505 000002CB F4                               hlt                                ;停机，等待程序管理器恢复运行时，
   506                                                                              ;将其回收 
   507 000002CC EBFD                             jmp .b2 
   508                                  
   509                                  ;------------------------------------------------------------------------------- 
   510 000002CE 0000                             pgdt             dw  0             ;用于设置和修改GDT 
   511 000002D0 00000000                                          dd  0
   512                                  
   513 000002D4 0000                             pidt             dw  0
   514 000002D6 00000000                                          dd  0
   515                                                            
   516                                           ;任务控制块链
   517 000002DA 00000000                         tcb_chain        dd  0 
   518                                  
   519 000002DE 00<rep 20h>                      core_tcb   times  32  db 0         ;内核（程序管理器）的TCB
   520                                  
   521 000002FE FFFFFFFFFFFF5555                 page_bit_map     db  0xff,0xff,0xff,0xff,0xff,0xff,0x55,0x55
   522 00000306 FFFFFFFFFFFFFFFF                                  db  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
   523 0000030E FFFFFFFFFFFFFFFF                                  db  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
   524 00000316 FFFFFFFFFFFFFFFF                                  db  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
   525 0000031E 5555555555555555                                  db  0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55
   526 00000326 0000000000000000                                  db  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   527 0000032E 0000000000000000                                  db  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   528 00000336 0000000000000000                                  db  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
   529                                           page_map_len     equ $-page_bit_map
   530                                                            
   531                                           ;符号地址检索表
   532                                           salt:
   533 0000033E 405072696E74537472-              salt_1           db  '@PrintString'
   533 00000347 696E67             
   534 0000034A 00<rep F4h>                                  times 256-($-salt_1) db 0
   535 0000043E [08000000]                                        dd  put_string
   536 00000442 0800                                              dw  flat_4gb_code_seg_sel
   537                                  
   538 00000444 40526561644469736B-              salt_2           db  '@ReadDiskData'
   538 0000044D 44617461           
   539 00000451 00<rep F3h>                                  times 256-($-salt_2) db 0
   540 00000544 [B4000000]                                        dd  read_hard_disk_0
   541 00000548 0800                                              dw  flat_4gb_code_seg_sel
   542                                  
   543 0000054A 405072696E7444776F-              salt_3           db  '@PrintDwordAsHexString'
   543 00000553 726441734865785374-
   543 0000055C 72696E67           
   544 00000560 00<rep EAh>                                  times 256-($-salt_3) db 0
   545 0000064A [FB000000]                                        dd  put_hex_dword
   546 0000064E 0800                                              dw  flat_4gb_code_seg_sel
   547                                  
   548 00000650 405465726D696E6174-              salt_4           db  '@TerminateProgram'
   548 00000659 6550726F6772616D   
   549 00000661 00<rep EFh>                                  times 256-($-salt_4) db 0
   550 00000750 [B3020000]                                        dd  terminate_current_task
   551 00000754 0800                                              dw  flat_4gb_code_seg_sel
   552                                  
   553                                           salt_item_len   equ $-salt_4
   554                                           salt_items      equ ($-salt)/salt_item_len
   555                                  
   556 00000756 2A2A2A2A2A2A2A2A45-              excep_msg        db  '********Exception encounted********',0
   556 0000075F 7863657074696F6E20-
   556 00000768 656E636F756E746564-
   556 00000771 2A2A2A2A2A2A2A2A00 
   557                                  
   558 0000077A 2020576F726B696E67-              message_0        db  '  Working in system core with protection '
   558 00000783 20696E207379737465-
   558 0000078C 6D20636F7265207769-
   558 00000795 74682070726F746563-
   558 0000079E 74696F6E20         
   559 000007A3 616E6420706167696E-                               db  'and paging are all enabled.System core is mapped '
   559 000007AC 672061726520616C6C-
   559 000007B5 20656E61626C65642E-
   559 000007BE 53797374656D20636F-
   559 000007C7 7265206973206D6170-
   559 000007D0 70656420           
   560 000007D4 746F20616464726573-                               db  'to address 0x80000000.',0x0d,0x0a,0
   560 000007DD 732030783830303030-
   560 000007E6 3030302E0D0A00     
   561                                  
   562 000007ED 202053797374656D20-              message_1        db  '  System wide CALL-GATE mounted.',0x0d,0x0a,0
   562 000007F6 776964652043414C4C-
   562 000007FF 2D47415445206D6F75-
   562 00000808 6E7465642E0D0A00   
   563                                           
   564 00000810 2A2A2A2A2A2A2A2A4E-              message_3        db  '********No more pages********',0
   564 00000819 6F206D6F7265207061-
   564 00000822 6765732A2A2A2A2A2A-
   564 0000082B 2A2A00             
   565                                           
   566 0000082E 202053797374656D20-              core_msg0        db  '  System core task running!',0x0d,0x0a,0
   566 00000837 636F7265207461736B-
   566 00000840 2072756E6E696E6721-
   566 00000849 0D0A00             
   567                                           
   568 0000084C 303132333435363738-              bin_hex          db '0123456789ABCDEF'
   568 00000855 39414243444546     
   569                                                                              ;put_hex_dword子过程用的查找表 
   570                                  
   571 0000085C 00<rep 200h>                     core_buf   times 512 db 0          ;内核用的缓冲区
   572                                  
   573 00000A5C 0D0A202000                       cpu_brnd0        db 0x0d,0x0a,'  ',0
   574 00000A61 00<rep 34h>                      cpu_brand  times 52 db 0
   575 00000A95 0D0A0D0A00                       cpu_brnd1        db 0x0d,0x0a,0x0d,0x0a,0
   576                                  
   577                                  ;-------------------------------------------------------------------------------
   578                                  fill_descriptor_in_ldt:                     ;在LDT内安装一个新的描述符
   579                                                                              ;输入：EDX:EAX=描述符
   580                                                                              ;          EBX=TCB基地址
   581                                                                              ;输出：CX=描述符的选择子
   582 00000A9A 50                               push eax
   583 00000A9B 52                               push edx
   584 00000A9C 57                               push edi
   585                                  
   586 00000A9D 8B7B0C                           mov edi,[ebx+0x0c]                 ;获得LDT基地址
   587                                           
   588 00000AA0 31C9                             xor ecx,ecx
   589 00000AA2 668B4B0A                         mov cx,[ebx+0x0a]                  ;获得LDT界限
   590 00000AA6 6641                             inc cx                             ;LDT的总字节数，即新描述符偏移地址
   591                                           
   592 00000AA8 89040F                           mov [edi+ecx+0x00],eax
   593 00000AAB 89540F04                         mov [edi+ecx+0x04],edx             ;安装描述符
   594                                  
   595 00000AAF 6683C108                         add cx,8                           
   596 00000AB3 6649                             dec cx                             ;得到新的LDT界限值 
   597                                  
   598 00000AB5 66894B0A                         mov [ebx+0x0a],cx                  ;更新LDT界限值到TCB
   599                                  
   600 00000AB9 6689C8                           mov ax,cx
   601 00000ABC 6631D2                           xor dx,dx
   602 00000ABF 66B90800                         mov cx,8
   603 00000AC3 66F7F1                           div cx
   604                                           
   605 00000AC6 6689C1                           mov cx,ax
   606 00000AC9 66C1E103                         shl cx,3                           ;左移3位，并且
   607 00000ACD 6683C904                         or cx,0000_0000_0000_0100B         ;使TI位=1，指向LDT，最后使RPL=00 
   608                                  
   609 00000AD1 5F                               pop edi
   610 00000AD2 5A                               pop edx
   611 00000AD3 58                               pop eax
   612                                       
   613 00000AD4 C3                               ret
   614                                        
   615                                  ;-------------------------------------------------------------------------------
   616                                  load_relocate_program:                      ;加载并重定位用户程序
   617                                                                              ;输入: PUSH 逻辑扇区号
   618                                                                              ;      PUSH 任务控制块基地址
   619                                                                              ;输出：无 
   620 00000AD5 60                               pushad
   621                                        
   622 00000AD6 89E5                             mov ebp,esp                        ;为访问通过堆栈传递的参数做准备
   623                                        
   624                                           ;清空当前页目录的前半部分（对应低2GB的局部地址空间） 
   625 00000AD8 BB00F0FFFF                       mov ebx,0xfffff000
   626 00000ADD 31F6                             xor esi,esi
   627                                    .b1:
   628 00000ADF C704B300000000                   mov dword [ebx+esi*4],0x00000000
   629 00000AE6 46                               inc esi
   630 00000AE7 81FE00020000                     cmp esi,512
   631 00000AED 7CF0                             jl .b1
   632                                  
   633 00000AEF 0F20D8                           mov eax,cr3
   634 00000AF2 0F22D8                           mov cr3,eax                        ;刷新TLB 
   635                                           
   636                                           ;以下开始分配内存并加载用户程序
   637 00000AF5 8B4528                           mov eax,[ebp+40]                   ;从堆栈中取出用户程序起始扇区号
   638 00000AF8 BB[5C080000]                     mov ebx,core_buf                   ;读取程序头部数据
   639 00000AFD 9A[B4000000]0800                 call flat_4gb_code_seg_sel:read_hard_disk_0
   640                                  
   641                                           ;以下判断整个程序有多大
   642 00000B04 A1[5C080000]                     mov eax,[core_buf]                 ;程序尺寸
   643 00000B09 89C3                             mov ebx,eax
   644 00000B0B 81E300F0FFFF                     and ebx,0xfffff000                 ;使之4KB对齐 
   645 00000B11 81C300100000                     add ebx,0x1000                        
   646 00000B17 A9FF0F0000                       test eax,0x00000fff                ;程序的大小正好是4KB的倍数吗? 
   647 00000B1C 0F45C3                           cmovnz eax,ebx                     ;不是。使用凑整的结果
   648                                  
   649 00000B1F 89C1                             mov ecx,eax
   650 00000B21 C1E90C                           shr ecx,12                         ;程序占用的总4KB页数 
   651                                           
   652 00000B24 8B4528                           mov eax,[ebp+40]                   ;起始扇区号
   653 00000B27 8B7524                           mov esi,[ebp+36]                   ;从堆栈中取得TCB的基地址
   654                                    .b2:
   655                                           alloc_user_linear                  ;宏：在用户任务地址空间上分配内存 
    19 00000B2A 8B5E06              <1>  mov ebx,[esi+0x06]
    20 00000B2D 81460600100000      <1>  add dword [esi+0x06],0x1000
    21 00000B34 9A[C3010000]0800    <1>  call flat_4gb_code_seg_sel:alloc_inst_a_page
   656                                           
   657 00000B3B 51                               push ecx
   658 00000B3C B908000000                       mov ecx,8
   659                                    .b3:
   660 00000B41 9A[B4000000]0800                 call flat_4gb_code_seg_sel:read_hard_disk_0               
   661 00000B48 40                               inc eax
   662 00000B49 E2F6                             loop .b3
   663                                  
   664 00000B4B 59                               pop ecx
   665 00000B4C E2DC                             loop .b2
   666                                  
   667                                           ;在内核地址空间内创建用户任务的TSS
   668                                           alloc_core_linear                  ;宏：在内核的地址空间上分配内存
    13 00000B4E 8B1D[E4020000]      <1>  mov ebx,[core_tcb+0x06]
    14 00000B54 8105[E4020000]0010- <1>  add dword [core_tcb+0x06],0x1000
    14 00000B5C 0000                <1>
    15 00000B5E 9A[C3010000]0800    <1>  call flat_4gb_code_seg_sel:alloc_inst_a_page
   669                                                                              ;用户任务的TSS必须在全局空间上分配 
   670                                           
   671 00000B65 895E14                           mov [esi+0x14],ebx                 ;在TCB中填写TSS的线性地址 
   672 00000B68 66C746126700                     mov word [esi+0x12],103            ;在TCB中填写TSS的界限值 
   673                                            
   674                                           ;在用户任务的局部地址空间内创建LDT 
   675                                           alloc_user_linear                  ;宏：在用户任务地址空间上分配内存
    19 00000B6E 8B5E06              <1>  mov ebx,[esi+0x06]
    20 00000B71 81460600100000      <1>  add dword [esi+0x06],0x1000
    21 00000B78 9A[C3010000]0800    <1>  call flat_4gb_code_seg_sel:alloc_inst_a_page
   676                                  
   677 00000B7F 895E0C                           mov [esi+0x0c],ebx                 ;填写LDT线性地址到TCB中 
   678                                  
   679                                           ;建立程序代码段描述符
   680 00000B82 B800000000                       mov eax,0x00000000
   681 00000B87 BBFFFF0F00                       mov ebx,0x000fffff                 
   682 00000B8C B900F8C000                       mov ecx,0x00c0f800                 ;4KB粒度的代码段描述符，特权级3
   683 00000B91 9A[64010000]0800                 call flat_4gb_code_seg_sel:make_seg_descriptor
   684 00000B98 89F3                             mov ebx,esi                        ;TCB的基地址
   685 00000B9A E8FBFEFFFF                       call fill_descriptor_in_ldt
   686 00000B9F 6683C903                         or cx,0000_0000_0000_0011B         ;设置选择子的特权级为3
   687                                           
   688 00000BA3 8B5E14                           mov ebx,[esi+0x14]                 ;从TCB中获取TSS的线性地址
   689 00000BA6 66894B4C                         mov [ebx+76],cx                    ;填写TSS的CS域 
   690                                  
   691                                           ;建立程序数据段描述符
   692 00000BAA B800000000                       mov eax,0x00000000
   693 00000BAF BBFFFF0F00                       mov ebx,0x000fffff                 
   694 00000BB4 B900F2C000                       mov ecx,0x00c0f200                 ;4KB粒度的数据段描述符，特权级3
   695 00000BB9 9A[64010000]0800                 call flat_4gb_code_seg_sel:make_seg_descriptor
   696 00000BC0 89F3                             mov ebx,esi                        ;TCB的基地址
   697 00000BC2 E8D3FEFFFF                       call fill_descriptor_in_ldt
   698 00000BC7 6683C903                         or cx,0000_0000_0000_0011B         ;设置选择子的特权级为3
   699                                           
   700 00000BCB 8B5E14                           mov ebx,[esi+0x14]                 ;从TCB中获取TSS的线性地址
   701 00000BCE 66894B54                         mov [ebx+84],cx                    ;填写TSS的DS域 
   702 00000BD2 66894B48                         mov [ebx+72],cx                    ;填写TSS的ES域
   703 00000BD6 66894B58                         mov [ebx+88],cx                    ;填写TSS的FS域
   704 00000BDA 66894B5C                         mov [ebx+92],cx                    ;填写TSS的GS域
   705                                           
   706                                           ;将数据段作为用户任务的3特权级固有堆栈 
   707                                           alloc_user_linear                  ;宏：在用户任务地址空间上分配内存
    19 00000BDE 8B5E06              <1>  mov ebx,[esi+0x06]
    20 00000BE1 81460600100000      <1>  add dword [esi+0x06],0x1000
    21 00000BE8 9A[C3010000]0800    <1>  call flat_4gb_code_seg_sel:alloc_inst_a_page
   708                                           
   709 00000BEF 8B5E14                           mov ebx,[esi+0x14]                 ;从TCB中获取TSS的线性地址
   710 00000BF2 66894B50                         mov [ebx+80],cx                    ;填写TSS的SS域
   711 00000BF6 8B5606                           mov edx,[esi+0x06]                 ;堆栈的高端线性地址 
   712 00000BF9 895338                           mov [ebx+56],edx                   ;填写TSS的ESP域 
   713                                  
   714                                           ;在用户任务的局部地址空间内创建0特权级堆栈
   715                                           alloc_user_linear                  ;宏：在用户任务地址空间上分配内存
    19 00000BFC 8B5E06              <1>  mov ebx,[esi+0x06]
    20 00000BFF 81460600100000      <1>  add dword [esi+0x06],0x1000
    21 00000C06 9A[C3010000]0800    <1>  call flat_4gb_code_seg_sel:alloc_inst_a_page
   716                                  
   717 00000C0D B800000000                       mov eax,0x00000000
   718 00000C12 BBFFFF0F00                       mov ebx,0x000fffff
   719 00000C17 B90092C000                       mov ecx,0x00c09200                 ;4KB粒度的堆栈段描述符，特权级0
   720 00000C1C 9A[64010000]0800                 call flat_4gb_code_seg_sel:make_seg_descriptor
   721 00000C23 89F3                             mov ebx,esi                        ;TCB的基地址
   722 00000C25 E870FEFFFF                       call fill_descriptor_in_ldt
   723 00000C2A 6683C900                         or cx,0000_0000_0000_0000B         ;设置选择子的特权级为0
   724                                  
   725 00000C2E 8B5E14                           mov ebx,[esi+0x14]                 ;从TCB中获取TSS的线性地址
   726 00000C31 66894B08                         mov [ebx+8],cx                     ;填写TSS的SS0域
   727 00000C35 8B5606                           mov edx,[esi+0x06]                 ;堆栈的高端线性地址
   728 00000C38 895304                           mov [ebx+4],edx                    ;填写TSS的ESP0域 
   729                                  
   730                                           ;在用户任务的局部地址空间内创建1特权级堆栈
   731                                           alloc_user_linear                  ;宏：在用户任务地址空间上分配内存
    19 00000C3B 8B5E06              <1>  mov ebx,[esi+0x06]
    20 00000C3E 81460600100000      <1>  add dword [esi+0x06],0x1000
    21 00000C45 9A[C3010000]0800    <1>  call flat_4gb_code_seg_sel:alloc_inst_a_page
   732                                  
   733 00000C4C B800000000                       mov eax,0x00000000
   734 00000C51 BBFFFF0F00                       mov ebx,0x000fffff
   735 00000C56 B900B2C000                       mov ecx,0x00c0b200                 ;4KB粒度的堆栈段描述符，特权级1
   736 00000C5B 9A[64010000]0800                 call flat_4gb_code_seg_sel:make_seg_descriptor
   737 00000C62 89F3                             mov ebx,esi                        ;TCB的基地址
   738 00000C64 E831FEFFFF                       call fill_descriptor_in_ldt
   739 00000C69 6683C901                         or cx,0000_0000_0000_0001B         ;设置选择子的特权级为1
   740                                  
   741 00000C6D 8B5E14                           mov ebx,[esi+0x14]                 ;从TCB中获取TSS的线性地址
   742 00000C70 66894B10                         mov [ebx+16],cx                    ;填写TSS的SS1域
   743 00000C74 8B5606                           mov edx,[esi+0x06]                 ;堆栈的高端线性地址
   744 00000C77 89530C                           mov [ebx+12],edx                   ;填写TSS的ESP1域 
   745                                  
   746                                           ;在用户任务的局部地址空间内创建2特权级堆栈
   747                                           alloc_user_linear                  ;宏：在用户任务地址空间上分配内存
    19 00000C7A 8B5E06              <1>  mov ebx,[esi+0x06]
    20 00000C7D 81460600100000      <1>  add dword [esi+0x06],0x1000
    21 00000C84 9A[C3010000]0800    <1>  call flat_4gb_code_seg_sel:alloc_inst_a_page
   748                                  
   749 00000C8B B800000000                       mov eax,0x00000000
   750 00000C90 BBFFFF0F00                       mov ebx,0x000fffff
   751 00000C95 B900D2C000                       mov ecx,0x00c0d200                 ;4KB粒度的堆栈段描述符，特权级2
   752 00000C9A 9A[64010000]0800                 call flat_4gb_code_seg_sel:make_seg_descriptor
   753 00000CA1 89F3                             mov ebx,esi                        ;TCB的基地址
   754 00000CA3 E8F2FDFFFF                       call fill_descriptor_in_ldt
   755 00000CA8 6683C902                         or cx,0000_0000_0000_0010B         ;设置选择子的特权级为2
   756                                  
   757 00000CAC 8B5E14                           mov ebx,[esi+0x14]                 ;从TCB中获取TSS的线性地址
   758 00000CAF 66894B18                         mov [ebx+24],cx                    ;填写TSS的SS2域
   759 00000CB3 8B5606                           mov edx,[esi+0x06]                 ;堆栈的高端线性地址
   760 00000CB6 895314                           mov [ebx+20],edx                   ;填写TSS的ESP2域 
   761                                  
   762                                           ;重定位U-SALT 
   763 00000CB9 FC                               cld
   764                                  
   765 00000CBA 8B0D0C000000                     mov ecx,[0x0c]                     ;U-SALT条目数 
   766 00000CC0 8B3D08000000                     mov edi,[0x08]                     ;U-SALT在4GB空间内的偏移 
   767                                    .b4:
   768 00000CC6 51                               push ecx
   769 00000CC7 57                               push edi
   770                                        
   771 00000CC8 B904000000                       mov ecx,salt_items
   772 00000CCD BE[3E030000]                     mov esi,salt
   773                                    .b5:
   774 00000CD2 57                               push edi
   775 00000CD3 56                               push esi
   776 00000CD4 51                               push ecx
   777                                  
   778 00000CD5 B940000000                       mov ecx,64                         ;检索表中，每条目的比较次数 
   779 00000CDA F3A7                             repe cmpsd                         ;每次比较4字节 
   780 00000CDC 7517                             jnz .b6
   781 00000CDE 8B06                             mov eax,[esi]                      ;若匹配，则esi恰好指向其后的地址
   782 00000CE0 898700FFFFFF                     mov [edi-256],eax                  ;将字符串改写成偏移地址 
   783 00000CE6 668B4604                         mov ax,[esi+4]
   784 00000CEA 6683C803                         or ax,0000000000000011B            ;以用户程序自己的特权级使用调用门
   785                                                                              ;故RPL=3 
   786 00000CEE 66898704FFFFFF                   mov [edi-252],ax                   ;回填调用门选择子 
   787                                    .b6:
   788                                        
   789 00000CF5 59                               pop ecx
   790 00000CF6 5E                               pop esi
   791 00000CF7 81C606010000                     add esi,salt_item_len
   792 00000CFD 5F                               pop edi                            ;从头比较 
   793 00000CFE E2D2                             loop .b5
   794                                        
   795 00000D00 5F                               pop edi
   796 00000D01 81C700010000                     add edi,256
   797 00000D07 59                               pop ecx
   798 00000D08 E2BC                             loop .b4
   799                                  
   800                                           ;在GDT中登记LDT描述符
   801 00000D0A 8B7524                           mov esi,[ebp+36]                   ;从堆栈中取得TCB的基地址
   802 00000D0D 8B460C                           mov eax,[esi+0x0c]                 ;LDT的起始线性地址
   803 00000D10 0FB75E0A                         movzx ebx,word [esi+0x0a]          ;LDT段界限
   804 00000D14 B900824000                       mov ecx,0x00408200                 ;LDT描述符，特权级0
   805 00000D19 9A[64010000]0800                 call flat_4gb_code_seg_sel:make_seg_descriptor
   806 00000D20 9A[1C010000]0800                 call flat_4gb_code_seg_sel:set_up_gdt_descriptor
   807 00000D27 66894E10                         mov [esi+0x10],cx                  ;登记LDT选择子到TCB中
   808                                  
   809 00000D2B 8B5E14                           mov ebx,[esi+0x14]                 ;从TCB中获取TSS的线性地址
   810 00000D2E 66894B60                         mov [ebx+96],cx                    ;填写TSS的LDT域 
   811                                  
   812 00000D32 66C7030000                       mov word [ebx+0],0                 ;反向链=0
   813                                        
   814 00000D37 668B5612                         mov dx,[esi+0x12]                  ;段长度（界限）
   815 00000D3B 66895366                         mov [ebx+102],dx                   ;填写TSS的I/O位图偏移域 
   816                                        
   817 00000D3F 66C743640000                     mov word [ebx+100],0               ;T=0
   818                                        
   819 00000D45 A104000000                       mov eax,[0x04]                     ;从任务的4GB地址空间获取入口点 
   820 00000D4A 894320                           mov [ebx+32],eax                   ;填写TSS的EIP域 
   821                                  
   822 00000D4D 9C                               pushfd
   823 00000D4E 5A                               pop edx
   824 00000D4F 895324                           mov [ebx+36],edx                   ;填写TSS的EFLAGS域 
   825                                  
   826                                           ;在GDT中登记TSS描述符
   827 00000D52 8B4614                           mov eax,[esi+0x14]                 ;从TCB中获取TSS的起始线性地址
   828 00000D55 0FB75E12                         movzx ebx,word [esi+0x12]          ;段长度（界限）
   829 00000D59 B900894000                       mov ecx,0x00408900                 ;TSS描述符，特权级0
   830 00000D5E 9A[64010000]0800                 call flat_4gb_code_seg_sel:make_seg_descriptor
   831 00000D65 9A[1C010000]0800                 call flat_4gb_code_seg_sel:set_up_gdt_descriptor
   832 00000D6C 66894E18                         mov [esi+0x18],cx                  ;登记TSS选择子到TCB
   833                                  
   834                                           ;创建用户任务的页目录
   835                                           ;注意！页的分配和使用是由页位图决定的，可以不占用线性地址空间 
   836 00000D70 9A[13020000]0800                 call flat_4gb_code_seg_sel:create_copy_cur_pdir
   837 00000D77 8B5E14                           mov ebx,[esi+0x14]                 ;从TCB中获取TSS的线性地址
   838 00000D7A 89431C                           mov dword [ebx+28],eax             ;填写TSS的CR3(PDBR)域
   839                                                     
   840 00000D7D 61                               popad
   841                                        
   842 00000D7E C20800                           ret 8                              ;丢弃调用本过程前压入的参数 
   843                                        
   844                                  ;-------------------------------------------------------------------------------
   845                                  append_to_tcb_link:                         ;在TCB链上追加任务控制块
   846                                                                              ;输入：ECX=TCB线性基地址
   847 00000D81 FA                               cli
   848                                           
   849 00000D82 50                               push eax
   850 00000D83 53                               push ebx
   851                                  
   852 00000D84 B8[DA020000]                     mov eax,tcb_chain
   853                                    .b0:                                      ;EAX=链表头或当前TCB线性地址
   854 00000D89 8B18                             mov ebx,[eax]                      ;EBX=下一个TCB线性地址
   855 00000D8B 09DB                             or ebx,ebx
   856 00000D8D 7404                             jz .b1                             ;链表为空，或已到末尾
   857 00000D8F 89D8                             mov eax,ebx                        ;定位到下一个TCB（的线性地址）
   858 00000D91 EBF6                             jmp .b0
   859                                  
   860                                    .b1:
   861 00000D93 8908                             mov [eax],ecx
   862 00000D95 C70100000000                     mov dword [ecx],0x00000000         ;当前TCB指针域清零，以指示这是最
   863                                                                              ;后一个TCB
   864 00000D9B 5B                               pop ebx
   865 00000D9C 58                               pop eax
   866                                           
   867 00000D9D FB                               sti
   868                                           
   869 00000D9E C3                               ret
   870                                           
   871                                  ;-------------------------------------------------------------------------------
   872                                  start:
   873                                           ;创建中断描述符表IDT
   874                                           ;在此之前，禁止调用put_string过程，以及任何含有sti指令的过程。
   875                                            
   876                                           ;前20个向量是处理器异常使用的
   877 00000D9F B8[4E020000]                     mov eax,general_exception_handler  ;门代码在段内偏移地址
   878 00000DA4 66BB0800                         mov bx,flat_4gb_code_seg_sel       ;门代码所在段的选择子
   879 00000DA8 66B9008E                         mov cx,0x8e00                      ;32位中断门，0特权级
   880 00000DAC 9A[7F010000]0800                 call flat_4gb_code_seg_sel:make_gate_descriptor
   881                                  
   882 00000DB3 BB00F00180                       mov ebx,idt_linear_address         ;中断描述符表的线性地址
   883 00000DB8 31F6                             xor esi,esi
   884                                    .idt0:
   885 00000DBA 8904F3                           mov [ebx+esi*8],eax
   886 00000DBD 8954F304                         mov [ebx+esi*8+4],edx
   887 00000DC1 46                               inc esi
   888 00000DC2 83FE13                           cmp esi,19                         ;安装前20个异常中断处理过程
   889 00000DC5 7EF3                             jle .idt0
   890                                  
   891                                           ;其余为保留或硬件使用的中断向量
   892 00000DC7 B8[45020000]                     mov eax,general_interrupt_handler  ;门代码在段内偏移地址
   893 00000DCC 66BB0800                         mov bx,flat_4gb_code_seg_sel       ;门代码所在段的选择子
   894 00000DD0 66B9008E                         mov cx,0x8e00                      ;32位中断门，0特权级
   895 00000DD4 9A[7F010000]0800                 call flat_4gb_code_seg_sel:make_gate_descriptor
   896                                  
   897 00000DDB BB00F00180                       mov ebx,idt_linear_address         ;中断描述符表的线性地址
   898                                    .idt1:
   899 00000DE0 8904F3                           mov [ebx+esi*8],eax
   900 00000DE3 8954F304                         mov [ebx+esi*8+4],edx
   901 00000DE7 46                               inc esi
   902 00000DE8 81FEFF000000                     cmp esi,255                        ;安装普通的中断处理过程
   903 00000DEE 7EF0                             jle .idt1
   904                                  
   905                                           ;设置实时时钟中断处理过程
   906 00000DF0 B8[5B020000]                     mov eax,rtm_0x70_interrupt_handle  ;门代码在段内偏移地址
   907 00000DF5 66BB0800                         mov bx,flat_4gb_code_seg_sel       ;门代码所在段的选择子
   908 00000DF9 66B9008E                         mov cx,0x8e00                      ;32位中断门，0特权级
   909 00000DFD 9A[7F010000]0800                 call flat_4gb_code_seg_sel:make_gate_descriptor
   910                                  
   911 00000E04 BB00F00180                       mov ebx,idt_linear_address         ;中断描述符表的线性地址
   912 00000E09 898380030000                     mov [ebx+0x70*8],eax
   913 00000E0F 899384030000                     mov [ebx+0x70*8+4],edx
   914                                  
   915                                           ;准备开放中断
   916 00000E15 66C705[D4020000]FF-              mov word [pidt],256*8-1            ;IDT的界限
   916 00000E1D 07                 
   917 00000E1E C705[D6020000]00F0-              mov dword [pidt+2],idt_linear_address
   917 00000E26 0180               
   918 00000E28 0F011D[D4020000]                 lidt [pidt]                        ;加载中断描述符表寄存器IDTR
   919                                  
   920                                           ;设置8259A中断控制器
   921 00000E2F B011                             mov al,0x11
   922 00000E31 E620                             out 0x20,al                        ;ICW1：边沿触发/级联方式
   923 00000E33 B020                             mov al,0x20
   924 00000E35 E621                             out 0x21,al                        ;ICW2:起始中断向量
   925 00000E37 B004                             mov al,0x04
   926 00000E39 E621                             out 0x21,al                        ;ICW3:从片级联到IR2
   927 00000E3B B001                             mov al,0x01
   928 00000E3D E621                             out 0x21,al                        ;ICW4:非总线缓冲，全嵌套，正常EOI
   929                                  
   930 00000E3F B011                             mov al,0x11
   931 00000E41 E6A0                             out 0xa0,al                        ;ICW1：边沿触发/级联方式
   932 00000E43 B070                             mov al,0x70
   933 00000E45 E6A1                             out 0xa1,al                        ;ICW2:起始中断向量
   934 00000E47 B004                             mov al,0x04
   935 00000E49 E6A1                             out 0xa1,al                        ;ICW3:从片级联到IR2
   936 00000E4B B001                             mov al,0x01
   937 00000E4D E6A1                             out 0xa1,al                        ;ICW4:非总线缓冲，全嵌套，正常EOI
   938                                  
   939                                           ;设置和时钟中断相关的硬件 
   940 00000E4F B00B                             mov al,0x0b                        ;RTC寄存器B
   941 00000E51 0C80                             or al,0x80                         ;阻断NMI
   942 00000E53 E670                             out 0x70,al
   943 00000E55 B012                             mov al,0x12                        ;设置寄存器B，禁止周期性中断，开放更
   944 00000E57 E671                             out 0x71,al                        ;新结束后中断，BCD码，24小时制
   945                                  
   946 00000E59 E4A1                             in al,0xa1                         ;读8259从片的IMR寄存器
   947 00000E5B 24FE                             and al,0xfe                        ;清除bit 0(此位连接RTC)
   948 00000E5D E6A1                             out 0xa1,al                        ;写回此寄存器
   949                                  
   950 00000E5F B00C                             mov al,0x0c
   951 00000E61 E670                             out 0x70,al
   952 00000E63 E471                             in al,0x71                         ;读RTC寄存器C，复位未决的中断状态
   953                                  
   954 00000E65 FB                               sti                                ;开放硬件中断
   955                                  
   956 00000E66 BB[7A070000]                     mov ebx,message_0
   957 00000E6B 9A[08000000]0800                 call flat_4gb_code_seg_sel:put_string
   958                                  
   959                                           ;显示处理器品牌信息 
   960 00000E72 B802000080                       mov eax,0x80000002
   961 00000E77 0FA2                             cpuid
   962 00000E79 A3[610A0000]                     mov [cpu_brand + 0x00],eax
   963 00000E7E 891D[650A0000]                   mov [cpu_brand + 0x04],ebx
   964 00000E84 890D[690A0000]                   mov [cpu_brand + 0x08],ecx
   965 00000E8A 8915[6D0A0000]                   mov [cpu_brand + 0x0c],edx
   966                                        
   967 00000E90 B803000080                       mov eax,0x80000003
   968 00000E95 0FA2                             cpuid
   969 00000E97 A3[710A0000]                     mov [cpu_brand + 0x10],eax
   970 00000E9C 891D[750A0000]                   mov [cpu_brand + 0x14],ebx
   971 00000EA2 890D[790A0000]                   mov [cpu_brand + 0x18],ecx
   972 00000EA8 8915[7D0A0000]                   mov [cpu_brand + 0x1c],edx
   973                                  
   974 00000EAE B804000080                       mov eax,0x80000004
   975 00000EB3 0FA2                             cpuid
   976 00000EB5 A3[810A0000]                     mov [cpu_brand + 0x20],eax
   977 00000EBA 891D[850A0000]                   mov [cpu_brand + 0x24],ebx
   978 00000EC0 890D[890A0000]                   mov [cpu_brand + 0x28],ecx
   979 00000EC6 8915[8D0A0000]                   mov [cpu_brand + 0x2c],edx
   980                                  
   981 00000ECC BB[5C0A0000]                     mov ebx,cpu_brnd0                  ;显示处理器品牌信息 
   982 00000ED1 9A[08000000]0800                 call flat_4gb_code_seg_sel:put_string
   983 00000ED8 BB[610A0000]                     mov ebx,cpu_brand
   984 00000EDD 9A[08000000]0800                 call flat_4gb_code_seg_sel:put_string
   985 00000EE4 BB[950A0000]                     mov ebx,cpu_brnd1
   986 00000EE9 9A[08000000]0800                 call flat_4gb_code_seg_sel:put_string
   987                                  
   988                                           ;以下开始安装为整个系统服务的调用门。特权级之间的控制转移必须使用门
   989 00000EF0 BF[3E030000]                     mov edi,salt                       ;C-SALT表的起始位置 
   990 00000EF5 B904000000                       mov ecx,salt_items                 ;C-SALT表的条目数量 
   991                                    .b4:
   992 00000EFA 51                               push ecx   
   993 00000EFB 8B8700010000                     mov eax,[edi+256]                  ;该条目入口点的32位偏移地址 
   994 00000F01 668B9F04010000                   mov bx,[edi+260]                   ;该条目入口点的段选择子 
   995 00000F08 66B900EC                         mov cx,1_11_0_1100_000_00000B      ;特权级3的调用门(3以上的特权级才
   996                                                                              ;允许访问)，0个参数(因为用寄存器
   997                                                                              ;传递参数，而没有用栈) 
   998 00000F0C 9A[7F010000]0800                 call flat_4gb_code_seg_sel:make_gate_descriptor
   999 00000F13 9A[1C010000]0800                 call flat_4gb_code_seg_sel:set_up_gdt_descriptor
  1000 00000F1A 66898F04010000                   mov [edi+260],cx                   ;将返回的门描述符选择子回填
  1001 00000F21 81C706010000                     add edi,salt_item_len              ;指向下一个C-SALT条目 
  1002 00000F27 59                               pop ecx
  1003 00000F28 E2D0                             loop .b4
  1004                                  
  1005                                           ;对门进行测试 
  1006 00000F2A BB[ED070000]                     mov ebx,message_1
  1007 00000F2F FF1D[3E040000]                   call far [salt_1+256]              ;通过门显示信息(偏移量将被忽略) 
  1008                                  
  1009                                           ;初始化创建程序管理器任务的任务控制块TCB
  1010 00000F35 66C705[E2020000]FF-              mov word [core_tcb+0x04],0xffff    ;任务状态：忙碌
  1010 00000F3D FF                 
  1011 00000F3E C705[E4020000]0000-              mov dword [core_tcb+0x06],0x80100000    
  1011 00000F46 1080               
  1012                                                                              ;内核虚拟空间的分配从这里开始。
  1013 00000F48 66C705[E8020000]FF-              mov word [core_tcb+0x0a],0xffff    ;登记LDT初始的界限到TCB中（未使用）
  1013 00000F50 FF                 
  1014 00000F51 B9[DE020000]                     mov ecx,core_tcb
  1015 00000F56 E826FEFFFF                       call append_to_tcb_link            ;将此TCB添加到TCB链中
  1016                                  
  1017                                           ;为程序管理器的TSS分配内存空间
  1018                                           alloc_core_linear                  ;宏：在内核的虚拟地址空间分配内存
    13 00000F5B 8B1D[E4020000]      <1>  mov ebx,[core_tcb+0x06]
    14 00000F61 8105[E4020000]0010- <1>  add dword [core_tcb+0x06],0x1000
    14 00000F69 0000                <1>
    15 00000F6B 9A[C3010000]0800    <1>  call flat_4gb_code_seg_sel:alloc_inst_a_page
  1019                                  
  1020                                           ;在程序管理器的TSS中设置必要的项目 
  1021 00000F72 66C7030000                       mov word [ebx+0],0                 ;反向链=0
  1022 00000F77 0F20D8                           mov eax,cr3
  1023 00000F7A 89431C                           mov dword [ebx+28],eax             ;登记CR3(PDBR)
  1024 00000F7D 66C743600000                     mov word [ebx+96],0                ;没有LDT。处理器允许没有LDT的任务。
  1025 00000F83 66C743640000                     mov word [ebx+100],0               ;T=0
  1026 00000F89 66C743666700                     mov word [ebx+102],103             ;没有I/O位图。0特权级事实上不需要。
  1027                                           
  1028                                           ;创建程序管理器的TSS描述符，并安装到GDT中 
  1029 00000F8F 89D8                             mov eax,ebx                        ;TSS的起始线性地址
  1030 00000F91 BB67000000                       mov ebx,103                        ;段长度（界限）
  1031 00000F96 B900894000                       mov ecx,0x00408900                 ;TSS描述符，特权级0
  1032 00000F9B 9A[64010000]0800                 call flat_4gb_code_seg_sel:make_seg_descriptor
  1033 00000FA2 9A[1C010000]0800                 call flat_4gb_code_seg_sel:set_up_gdt_descriptor
  1034 00000FA9 66890D[F6020000]                 mov [core_tcb+0x18],cx             ;登记内核任务的TSS选择子到其TCB
  1035                                  
  1036                                           ;任务寄存器TR中的内容是任务存在的标志，该内容也决定了当前任务是谁。
  1037                                           ;下面的指令为当前正在执行的0特权级任务“程序管理器”后补手续（TSS）。
  1038 00000FB0 0F00D9                           ltr cx
  1039                                  
  1040                                           ;现在可认为“程序管理器”任务正执行中
  1041                                  
  1042                                           ;创建用户任务的任务控制块 
  1043                                           alloc_core_linear                  ;宏：在内核的虚拟地址空间分配内存
    13 00000FB3 8B1D[E4020000]      <1>  mov ebx,[core_tcb+0x06]
    14 00000FB9 8105[E4020000]0010- <1>  add dword [core_tcb+0x06],0x1000
    14 00000FC1 0000                <1>
    15 00000FC3 9A[C3010000]0800    <1>  call flat_4gb_code_seg_sel:alloc_inst_a_page
  1044                                           
  1045 00000FCA 66C743040000                     mov word [ebx+0x04],0              ;任务状态：空闲 
  1046 00000FD0 C7430600000000                   mov dword [ebx+0x06],0             ;用户任务局部空间的分配从0开始。
  1047 00000FD7 66C7430AFFFF                     mov word [ebx+0x0a],0xffff         ;登记LDT初始的界限到TCB中
  1048                                        
  1049 00000FDD 6A32                             push dword 50                      ;用户程序位于逻辑50扇区
  1050 00000FDF 53                               push ebx                           ;压入任务控制块起始线性地址 
  1051 00000FE0 E8F0FAFFFF                       call load_relocate_program
  1052 00000FE5 89D9                             mov ecx,ebx         
  1053 00000FE7 E895FDFFFF                       call append_to_tcb_link            ;将此TCB添加到TCB链中
  1054                                  
  1055                                           ;创建用户任务的任务控制块
  1056                                           alloc_core_linear                  ;宏：在内核的虚拟地址空间分配内存
    13 00000FEC 8B1D[E4020000]      <1>  mov ebx,[core_tcb+0x06]
    14 00000FF2 8105[E4020000]0010- <1>  add dword [core_tcb+0x06],0x1000
    14 00000FFA 0000                <1>
    15 00000FFC 9A[C3010000]0800    <1>  call flat_4gb_code_seg_sel:alloc_inst_a_page
  1057                                  
  1058 00001003 66C743040000                     mov word [ebx+0x04],0              ;任务状态：空闲
  1059 00001009 C7430600000000                   mov dword [ebx+0x06],0             ;用户任务局部空间的分配从0开始。
  1060 00001010 66C7430AFFFF                     mov word [ebx+0x0a],0xffff         ;登记LDT初始的界限到TCB中
  1061                                  
  1062 00001016 6A64                             push dword 100                     ;用户程序位于逻辑100扇区
  1063 00001018 53                               push ebx                           ;压入任务控制块起始线性地址
  1064 00001019 E8B7FAFFFF                       call load_relocate_program
  1065 0000101E 89D9                             mov ecx,ebx
  1066 00001020 E85CFDFFFF                       call append_to_tcb_link            ;将此TCB添加到TCB链中
  1067                                  
  1068                                    .core:
  1069 00001025 BB[2E080000]                     mov ebx,core_msg0
  1070 0000102A 9A[08000000]0800                 call flat_4gb_code_seg_sel:put_string
  1071                                           
  1072                                           ;这里可以编写回收已终止任务内存的代码
  1073                                            
  1074 00001031 EBF2                             jmp .core
  1075                                              
  1076                                  core_code_end:
  1077                                  
  1078                                  ;-------------------------------------------------------------------------------
  1079                                  SECTION core_trail
  1080                                  ;-------------------------------------------------------------------------------
  1081                                  core_end:
